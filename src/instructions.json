[
    {
        "description": "Unsigned Minimum (vector). This instruction compares corresponding vector \nelements in the two source SIMD&FP registers, places the smaller of each of \nthe two unsigned integer values into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMIN", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx011011xxxxxxxxxx", 
                "title": "UMIN"
            }
        ], 
        "file": "umin_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise NOT (vector). This instruction reads each vector element from the \nsource SIMD&FP register, places the inverse of each value into a vector, and \nwrites the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias MVN.", 
        "title": "NOT", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "NOT  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x10111000100000010110xxxxxxxxxx", 
                "title": "NOT"
            }
        ], 
        "file": "not_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating \nthe vector elements of the first source SIMD&FP register after the vector \nelements of the second source SIMD&FP register, reads each pair of adjacent \nvector elements in the two source SIMD&FP registers, writes the largest of \neach pair of unsigned integer values into a vector, and writes the vector to \nthe destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMAXP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx101001xxxxxxxxxx", 
                "title": "UMAXP"
            }
        ], 
        "file": "umaxp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Absolute difference and Accumulate. This instruction subtracts the \nelements of the vector of the second source SIMD&FP register from the \ncorresponding elements of the first source SIMD&FP register, and accumulates \nthe absolute values of the results into the elements of the vector of the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SABA", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx011111xxxxxxxxxx", 
                "title": "SABA"
            }
        ], 
        "file": "saba_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "AES inverse mix columns.", 
        "title": "AESIMC", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "D": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "AESIMC  <Vd>.16B, <Vn>.16B", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0100111000101000011110xxxxxxxxxx", 
                "title": "AESIMC"
            }
        ], 
        "file": "aesimc_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a \n2-bit immediate index value, and returns a 128-bit result in the destination \nSIMD&FP register. It performs a 32-bit majority function between the three \n32-bit fields held in the upper three elements of the first source vector, and \nadds the resulting 32-bit value and the following three other 32-bit values: \n\n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the 32-bit majority function. \n* The result of the exclusive OR of the top 32-bit element of the second \n  source vector, Vn, with a rotation left by 12 of the top 32-bit element of \n  the first source vector. \n* A 32-bit element indexed out of the third source vector, Vm. \nThe result of this addition is returned as the top element of the result. The \nother elements of the result are taken from elements of the first source \nvector, with the element returned in bits<63:32> being rotated left by 9. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM3TT1B", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm2": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110010xxxxx10xx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm3tt1b_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add (vector). This instruction adds corresponding elements in the two source \nSIMD&FP registers, places the results into a vector, and writes the vector to \nthe destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "ADD (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADD  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "add_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Select Negation returns, in the destination register, the value of \nthe first source register if the condition is TRUE, and otherwise returns the \nnegated value of the second source register. \n\nThis instruction is used by the alias CNEG.", 
        "title": "CSNEG", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CSNEG  <Wd>, <Wn>, <Wm>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CSNEG  <Xd>, <Xn>, <Xm>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1011010100xxxxxxxxx01xxxxxxxxxx", 
                "title": "CSNEG"
            }
        ], 
        "file": "csneg.html", 
        "type": "instruction", 
        "aliases": [
            "cneg_csneg.html"
        ]
    }, 
    {
        "description": "SHA256 hash update (part 2).", 
        "title": "SHA256H2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "P": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA256H2  <Qd>, <Qn>, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx010100xxxxxxxxxx", 
                "title": "SHA256H2"
            }
        ], 
        "file": "sha256h2_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA1 schedule update 1.", 
        "title": "SHA1SU1", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA1SU1  <Vd>.4S, <Vn>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0101111000101000000110xxxxxxxxxx", 
                "title": "SHA1SU1"
            }
        ], 
        "file": "sha1su1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a \nregister, keeping other bits unchanged.", 
        "title": "MOVK", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "hw": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MOVK  <Wd>, #<imm>{, LSL #<shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOVK  <Xd>, #<imm>{, LSL #<shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x11100101xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "MOVK"
            }
        ], 
        "file": "movk.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load multiple 2-element structures to two registers. This instruction loads \nmultiple 2-element structures from memory and writes the result to the two \nSIMD&FP registers, with de-interleaving. \n\nFor an example of de-interleaving, see LD3 (multiple structures). \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD2 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100010000001000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1000"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100110xxxxx1000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld2_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Exclusive Register Byte stores a byte from a register to memory if the \nPE has exclusive access to the memory address, and returns a status value of 0 \nif the store was successful, or of 1 if no store was performed. See \nSynchronization and semaphores. The memory access is atomic. \n\nFor information about memory accesses see Load/Store addressing modes.", 
        "title": "STXRB", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00001000000xxxxx0xxxxxxxxxxxxxxx", 
                "title": "STXRB"
            }
        ], 
        "file": "stxrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Reciprocal Estimate. This instruction reads each vector element from \nthe source SIMD&FP register, calculates an approximate inverse for the \nunsigned integer value, places the result into a vector, and writes the vector \nto the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "URECPE", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URECPE  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x0011101x100001110010xxxxxxxxxx", 
                "title": "URECPE"
            }
        ], 
        "file": "urecpe_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Negate with Carry, setting flags, negates the sum of a register value and the \nvalue of NOT (Carry flag), and writes the result to the destination register. \nIt updates the condition flags based on the result. \n\nThis is an alias of SBCS. This means: \n\n* The encodings in this description are named to match the encodings of SBCS. \n* The description of SBCS gives the operational pseudocode for this \n  instruction.", 
        "title": "NGCS", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "NGCS  <Wd>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "NGCS  <Xd>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1111010000xxxxx00000011111xxxxx", 
                "title": "NGCS"
            }
        ], 
        "file": "ngcs_sbcs.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Pair of Registers, with non-temporal hint, calculates an address from a \nbase register value and an immediate offset, and stores two 32-bit words or \ntwo 64-bit doublewords to the calculated address, from two registers. For \ninformation about memory accesses, see Load/Store addressing modes. For \ninformation about Non-temporal pair instructions, see Load/Store Non-temporal \npair.", 
        "title": "STNP", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x010100000xxxxxxxxxxxxxxxxxxxxxx", 
                "title": "STNP"
            }
        ], 
        "file": "stnp_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word \nor 64-bit doubleword from memory, performs a bitwise OR with the value held in \na register on it, and stores the result back to memory. The value initially \nloaded from memory is returned in the destination register. \n\n* If the destination register is not one of WZR or XZR, LDSETA and LDSETAL \n  load from memory with acquire semantics. \n* LDSETL and LDSETAL store to memory with release semantics. \n* LDSET has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSET, STSETL.", 
        "title": "LDSET, LDSETA, LDSETAL, LDSETL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx001100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSET  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSET"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSETA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSETA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSETAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSETL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSET  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSET"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSETA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSETA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSETAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSETL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldset.html", 
        "type": "instruction", 
        "aliases": [
            "stset_ldset.html"
        ]
    }, 
    {
        "description": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from \nmemory, compares it against the value held in a register, and stores the \nsmaller value back to memory, treating the values as signed numbers. The value \ninitially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDSMINAB and LDSMINALB load from \n  memory with acquire semantics. \n* LDSMINLB and LDSMINALB store to memory with release semantics. \n* LDSMINB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMINB, STSMINLB.", 
        "title": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx010100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMINB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldsminb.html", 
        "type": "instruction", 
        "aliases": [
            "stsminb_ldsminb.html"
        ]
    }, 
    {
        "description": "Reverse Bytes reverses the byte order in a 64-bit general-purpose register. \n\nWhen assembling for ARMv8.2, an assembler must support this \npseudo-instruction. It is optional whether an assembler supports this \npseudo-instruction when assembling for an architecture earlier than ARMv8.2. \n\nThis is a pseudo-instruction of REV. This means: \n\n* The encodings in this description are named to match the encodings of REV. \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of REV gives the operational pseudocode for this \n  instruction.", 
        "title": "REV64", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "REV64  <Xd>, <Xn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101101011000000000011xxxxxxxxxx", 
                "title": "REV64"
            }
        ], 
        "file": "rev64_rev.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Negate (vector). This instruction negates the value of each \nvector element in the source SIMD&FP register, writes the result to a vector, \nand writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FNEG (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FNEG  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FNEG  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fneg_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store SIMD&FP register (unscaled offset). This instruction stores a single \nSIMD&FP register to memory. The address that is used for the store is \ncalculated from a base register value and an optional immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "STUR (SIMD&FP)", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 00)", 
                        "arch": null, 
                        "asm": "STUR  <Bt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 00)", 
                        "arch": null, 
                        "asm": "STUR  <Ht>, [<Xn|SP>{, #<simm>}]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 00)", 
                        "arch": null, 
                        "asm": "STUR  <St>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 00)", 
                        "arch": null, 
                        "asm": "STUR  <Dt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 10)", 
                        "arch": null, 
                        "asm": "STUR  <Qt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "xx111100x00xxxxxxxxx00xxxxxxxxxx", 
                "title": "STUR (SIMD&FP)"
            }
        ], 
        "file": "stur_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Halving Subtract. This instruction subtracts the vector elements in \nthe second source SIMD&FP register from the corresponding vector elements in \nthe first source SIMD&FP register, shifts each result right one bit, places \neach result into a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UHSUB", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx001001xxxxxxxxxx", 
                "title": "UHSUB"
            }
        ], 
        "file": "uhsub_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Add Long to accumulator (vector). This \ninstruction multiplies corresponding half-precision floating-point values in \nthe vectors in the two source SIMD&FP registers, and accumulates the product \nto the corresponding vector element of the destination SIMD&FP register. The \ninstruction does not round the result of the multiply before the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLAL and FMLAL2", 
        "title": "FMLAL, FMLAL2 (vector)", 
        "classes": [
            {
                "title": "FMLAL", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx111011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "FMLAL"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "FMLAL2", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx110011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "FMLAL2"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "fmlal_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Pointer Authentication Code, using Generic key. This instruction computes the \npointer authentication code for an address in the first source register, using \na modifier in the second source register, and the Generic key. The computed \npointer authentication code is returned in the upper 32 bits of the \ndestination register.", 
        "title": "PACGA", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "10011010110xxxxx001100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PACGA  <Xd>, <Xn>, <Xm|SP>", 
                        "title": "Integer"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "pacga.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to \nmemory. The address that is used for the store is calculated from a base \nregister and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "STTRB", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STTRB  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00111000000xxxxxxxxx10xxxxxxxxxx", 
                "title": "STTRB"
            }
        ], 
        "file": "sttrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load SIMD&FP Register (immediate offset). This instruction loads an element \nfrom memory, and writes the result as a scalar to the SIMD&FP register. The \naddress that is used for the load is calculated from a base register value, a \nsigned immediate offset, and an optional offset that is a multiple of the \nelement size. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "LDR (immediate, SIMD&FP)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx111100x10xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Bt>, [<Xn|SP>], #<simm>", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Ht>, [<Xn|SP>], #<simm>", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <St>, [<Xn|SP>], #<simm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Dt>, [<Xn|SP>], #<simm>", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Qt>, [<Xn|SP>], #<simm>", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx111100x10xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Bt>, [<Xn|SP>, #<simm>]!", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Ht>, [<Xn|SP>, #<simm>]!", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <St>, [<Xn|SP>, #<simm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Dt>, [<Xn|SP>, #<simm>]!", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Qt>, [<Xn|SP>, #<simm>]!", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx111101x1xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Ht>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <St>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Dt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldr_imm_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit \nwords or 64-bit doublewords from memory, and compares them against the values \nheld in the first pair of registers. If the comparison is equal, the values in \nthe second pair of registers are written to memory. If the writes are \nperformed, the reads and writes occur atomically such that no other \nmodification of the memory location can take place between the reads and \nwrites. \n\n* CASPA and CASPAL load from memory with acquire semantics. \n* CASPL and CASPAL store to memory with release semantics. \n* CAS has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors \nassociated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the registers which are \ncompared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are \nrestored to the values held in the registers before the instruction was \nexecuted.", 
        "title": "CASP, CASPA, CASPAL, CASPL", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0010000x1xxxxxx11111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(sz == 0 && L == 0 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CASP"
                    }, 
                    {
                        "bitdiff": "(sz == 0 && L == 1 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASPA  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CASPA"
                    }, 
                    {
                        "bitdiff": "(sz == 0 && L == 1 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASPAL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CASPAL"
                    }, 
                    {
                        "bitdiff": "(sz == 0 && L == 0 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASPL  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CASPL"
                    }, 
                    {
                        "bitdiff": "(sz == 1 && L == 0 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASP  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CASP"
                    }, 
                    {
                        "bitdiff": "(sz == 1 && L == 1 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASPA  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CASPA"
                    }, 
                    {
                        "bitdiff": "(sz == 1 && L == 1 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASPAL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CASPAL"
                    }, 
                    {
                        "bitdiff": "(sz == 1 && L == 0 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CASPL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "casp.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise bit Clear (vector, immediate). This instruction reads each vector \nelement from the destination SIMD&FP register, performs a bitwise AND between \neach result and the complement of an immediate constant, places the result \ninto a vector, and writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "BIC (vector, immediate)", 
        "classes": [
            {
                "fields": {
                    "a": {
                        "lo": 18, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "c": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "b": {
                        "lo": 17, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "e": {
                        "lo": 8, 
                        "hi": 8, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "d": {
                        "lo": 9, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "g": {
                        "lo": 6, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "f": {
                        "lo": 7, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "h": {
                        "lo": 5, 
                        "hi": 5, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "cmode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(cmode == 10x1)", 
                        "arch": null, 
                        "asm": "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(cmode == 0xx1)", 
                        "arch": null, 
                        "asm": "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "32-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x10111100000xxxxxx101xxxxxxxxxx", 
                "title": "BIC (vector, immediate)"
            }
        ], 
        "file": "bic_advsimd_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add (extended register), setting flags, adds a register value and a sign or \nzero-extended register value, followed by an optional left shift amount, and \nwrites the result to the destination register. The argument that is extended \nfrom the <Rm> register can be a byte, halfword, word, or doubleword. It \nupdates the condition flags based on the result. \n\nThis instruction is used by the alias CMN (extended register).", 
        "title": "ADDS (extended register)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm3": {
                        "lo": 10, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101011001xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADDS (extended register)"
            }
        ], 
        "file": "adds_addsub_ext.html", 
        "type": "instruction", 
        "aliases": [
            "cmn_adds_addsub_ext.html"
        ]
    }, 
    {
        "description": "Unsigned Maximum (vector). This instruction compares corresponding elements in \nthe vectors in the two source SIMD&FP registers, places the larger of each \npair of unsigned integer values into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMAX", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx011001xxxxxxxxxx", 
                "title": "UMAX"
            }
        ], 
        "file": "umax_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Shift Left and Insert (immediate). This instruction reads each vector element \nin the source SIMD&FP register, left shifts each vector element by an \nimmediate value, and inserts the result into the corresponding vector element \nin the destination SIMD&FP register such that the new zero bits created by the \nshift are not inserted but retain their existing value. Bits shifted out of \nthe left of each vector element in the source register are lost. \n\nThe following figure shows an example of the operation of shift left by 3 for \nan 8-bit vector element. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SLI", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SLI  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sli_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, toward Zero (vector). This instruction \nrounds a vector of floating-point values in the SIMD&FP source register to \nintegral floating-point values of the same size using the Round towards Zero \nrounding mode, and writes the result to the SIMD&FP destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRINTZ (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTZ  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTZ  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frintz_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum Number Pairwise (vector). This instruction creates a \nvector by concatenating the vector elements of the first source SIMD&FP \nregister after the vector elements of the second source SIMD&FP register, \nreads each pair of adjacent vector elements in the two source SIMD&FP \nregisters, writes the largest of each pair of values into a vector, and writes \nthe vector to the destination SIMD&FP register. All the values in this \ninstruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result is the numerical \nvalue, otherwise the result is identical to FMAX (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAXNMP (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "a": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110010xxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx110001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmaxnmp_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Rounding Halving Add. This instruction adds corresponding signed \ninteger values from the two source SIMD&FP registers, shifts each result right \none bit, places the results into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThe results are rounded. For truncated results, see SHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SRHADD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx000101xxxxxxxxxx", 
                "title": "SRHADD"
            }
        ], 
        "file": "srhadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Divide divides a signed integer register value by another signed \ninteger register value, and writes the result to the destination register. The \ncondition flags are not affected.", 
        "title": "SDIV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "o1": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SDIV  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SDIV  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx000011xxxxxxxxxx", 
                "title": "SDIV"
            }
        ], 
        "file": "sdiv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector \nelement in the first source SIMD&FP register, performs an AND with the \ncorresponding vector element in the second source SIMD&FP register, and if the \nresult is not zero, sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to one, otherwise sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMTST", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMTST  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmtst_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store-Release Register Byte stores a byte from a 32-bit register to a memory \nlocation. The instruction also has memory ordering semantics as described in \nLoad-Acquire, Store-Release. For information about memory accesses, see \nLoad/Store addressing modes.", 
        "title": "STLRB", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STLRB  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00001000100xxxxx1xxxxxxxxxxxxxxx", 
                "title": "STLRB"
            }
        ], 
        "file": "stlrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed minimum on halfword in memory, without return, atomically loads \na 16-bit halfword from memory, compares it against the value held in a \nregister, and stores the smaller value back to memory, treating the values as \nsigned numbers. \n\n* STSMINH has no memory ordering semantics. \n* STSMINLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH. \n* The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the \n  operational pseudocode for this instruction.", 
        "title": "STSMINH, STSMINLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx010100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STSMINH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STSMINLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stsminh_ldsminh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Exclusive Register derives an address from a base register value, loads a \n32-bit word or a 64-bit doubleword from memory, and writes it to a register. \nThe memory access is atomic. The PE marks the physical address being accessed \nas an exclusive access. This exclusive access mark is checked by Store \nExclusive instructions. See Synchronization and semaphores. For information \nabout memory accesses see Load/Store addressing modes.", 
        "title": "LDXR", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDXR  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDXR  <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000010xxxxx0xxxxxxxxxxxxxxx", 
                "title": "LDXR"
            }
        ], 
        "file": "ldxr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add across Vector. This instruction adds every vector element in the source \nSIMD&FP register together, and writes the scalar result to the destination \nSIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ADDV", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADDV  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx110001101110xxxxxxxxxx", 
                "title": "ADDV"
            }
        ], 
        "file": "addv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load single 4-element structure to one lane of four registers. This \ninstruction loads a 4-element structure from memory and writes the result to \nthe corresponding elements of the four SIMD&FP registers without affecting the \nother bits of the registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD4 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110101100000xx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 001)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101111xxxxxxx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld4_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Transpose vectors (primary). This instruction reads corresponding \neven-numbered vector elements from the two source SIMD&FP registers, starting \nat zero, places each result into consecutive elements of a vector, and writes \nthe vector to the destination SIMD&FP register. Vector elements from the first \nsource register are placed into even-numbered elements of the destination \nvector, starting at zero, while vector elements from the second source \nregister are placed into odd-numbered elements of the destination vector. \n\nBy using this instruction with TRN2, a 2 x 2 matrix can be transposed. \n\nThe following figure shows an example of the operation of TRN1 and TRN2 \nhalfword operations where Q = 0. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "TRN1", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx0xxxxx001010xxxxxxxxxx", 
                "title": "TRN1"
            }
        ], 
        "file": "trn1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half \n(vector). This instruction multiplies the vector elements of the first source \nSIMD&FP register with the corresponding vector elements of the second source \nSIMD&FP register without saturating the multiply results, doubles the results, \nand accumulates the most significant half of the final results with the vector \nelements of the destination SIMD&FP register. The results are rounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation \nbit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRDMLAH (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx0xxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLAH  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": "ARMv8.1"
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx0xxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "sqrdmlah_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move inverted Immediate (vector). This instruction places the inverse of an \nimmediate constant into every vector element of the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MVNI", 
        "classes": [
            {
                "fields": {
                    "a": {
                        "lo": 18, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "c": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "b": {
                        "lo": 17, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "e": {
                        "lo": 8, 
                        "hi": 8, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "d": {
                        "lo": 9, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "g": {
                        "lo": 6, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "cmode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "h": {
                        "lo": 5, 
                        "hi": 5, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "f": {
                        "lo": 7, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(cmode == 10x0)", 
                        "arch": null, 
                        "asm": "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "16-bit shifted immediate"
                    }, 
                    {
                        "bitdiff": "(cmode == 0xx0)", 
                        "arch": null, 
                        "asm": "MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "32-bit shifted immediate"
                    }, 
                    {
                        "bitdiff": "(cmode == 110x)", 
                        "arch": null, 
                        "asm": "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>", 
                        "title": "32-bit shifting ones"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x10111100000xxxxxxx01xxxxxxxxxx", 
                "title": "MVNI"
            }
        ], 
        "file": "mvni_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Minimum across Vector. This instruction compares all the vector \nelements in the source SIMD&FP register, and writes the smallest of the values \nas a scalar to the destination SIMD&FP register. All the values in this \ninstruction are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMINV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMINV  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx110001101010xxxxxxxxxx", 
                "title": "UMINV"
            }
        ], 
        "file": "uminv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Compare Negative (register) sets the value of the condition flags \nto the result of the comparison of a register value and the inverse of another \nregister value if the condition is TRUE, and an immediate value otherwise.", 
        "title": "CCMN (register)", 
        "classes": [
            {
                "fields": {
                    "nzcv": {
                        "lo": 0, 
                        "hi": 3, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CCMN  <Wn>, <Wm>, #<nzcv>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0111010010xxxxxxxxx00xxxxx0xxxx", 
                "title": "CCMN (register)"
            }
        ], 
        "file": "ccmn_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, using current rounding mode (scalar). This \ninstruction rounds a floating-point value in the SIMD&FP source register to an \nintegral floating-point value of the same size using the rounding mode that is \ndetermined by the FPCR, and writes the result to the SIMD&FP destination \nregister. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FRINTI (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "rmode": {
                        "lo": 15, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "111"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FRINTI  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FRINTI  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FRINTI  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100111110000xxxxxxxxxx", 
                "title": "FRINTI (scalar)"
            }
        ], 
        "file": "frinti_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply returning High half. This instruction \nmultiplies the values of corresponding elements of the two source SIMD&FP \nregisters, doubles the results, places the most significant half of the final \nresults into a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nThe results are truncated. For rounded results, see SQRDMULH. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMULH (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx101101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULH  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx101101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmulh_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitfield Clear, leaving other bits unchanged. \n\nThis is an alias of BFM. This means: \n\n* The encodings in this description are named to match the encodings of BFM. \n* The description of BFM gives the operational pseudocode for this \n  instruction.", 
        "title": "BFC", 
        "classes": [
            {
                "title": "Leaving other bits unchanged", 
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "x01100110xxxxxxxxxxxxx11111xxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "BFC  <Wd>, #<lsb>, #<width>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "BFC  <Xd>, #<lsb>, #<width>", 
                        "title": "64-bit"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "bfc_bfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Halfword (unscaled) calculates an address from a base \nregister and an immediate offset, loads a signed halfword from memory, \nsign-extends it, and writes it to a register. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "LDURSH", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "011110001x0xxxxxxxxx00xxxxxxxxxx", 
                "title": "LDURSH"
            }
        ], 
        "file": "ldursh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move (register) copies the value in a source register to the destination \nregister. \n\nThis is an alias of ORR (shifted register). This means: \n\n* The encodings in this description are named to match the encodings of ORR \n  (shifted register). \n* The description of ORR (shifted register) gives the operational pseudocode \n  for this instruction.", 
        "title": "MOV (register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "000000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MOV  <Wd>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOV  <Xd>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101010000xxxxx00000011111xxxxx", 
                "title": "MOV (register)"
            }
        ], 
        "file": "mov_orr_log_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and \nwrites the result to a register. The address that is used for the load is \ncalculated from a base register and an immediate offset. For information about \nmemory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "LDRB (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000010xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRB  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "Post-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000010xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRB  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "Pre-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "0011100101xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "Unsigned offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldrb_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Prefetch Memory (literal) signals the memory system that data memory accesses \nfrom a specified address are likely to occur in the near future. The memory \nsystem can respond by taking actions that are expected to speed up the memory \naccesses when they do occur, such as preloading the cache line containing the \nspecified address into one or more caches. \n\nThe effect of an PRFM instruction is implementation defined. For more \ninformation, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "PRFM (literal)", 
        "classes": [
            {
                "fields": {
                    "imm19": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PRFM  (<prfop>|#<imm5>), <label>", 
                        "title": "Literal"
                    }
                ], 
                "unallocated": null, 
                "mask": "11011000xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "PRFM (literal)"
            }
        ], 
        "file": "prfm_lit.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise AND (immediate) performs a bitwise AND of a register value and an \nimmediate value, and writes the result to the destination register.", 
        "title": "AND (immediate)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "AND  <Wd|WSP>, <Wn>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "AND  <Xd|SP>, <Xn>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100100xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "AND (immediate)"
            }
        ], 
        "file": "and_log_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction \nreads each vector element in the source SIMD&FP register, right shifts each \nresult by an immediate value, puts the final result into a vector, and writes \nthe vector to the lower or upper half of the destination SIMD&FP register. All \nthe values in this instruction are unsigned integer values. The results are \nrounded. For truncated results, see UQSHRN. \n\nThe UQRSHRN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the UQRSHRN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQRSHRN, UQRSHRN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx100111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQRSHRN  <Vb><d>, <Va><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx100111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqrshrn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum Pairwise (vector). This instruction creates a vector by \nconcatenating the vector elements of the first source SIMD&FP register after \nthe vector elements of the second source SIMD&FP register, reads each pair of \nadjacent vector elements from the concatenated vector, writes the smaller of \neach pair of values into a vector, and writes the vector to the destination \nSIMD&FP register. All the values in this instruction are floating-point \nvalues. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMINP (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110110xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x1xxxxx111101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fminp_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP \nsource register to a 32-bit or 64-bit unsigned integer using the Round towards \nMinus Infinity rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTMU (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTMU  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTMU  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTMU  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTMU  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTMU  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTMU  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx110001000000xxxxxxxxxx", 
                "title": "FCVTMU (scalar)"
            }
        ], 
        "file": "fcvtmu_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply-Subtract Long (vector, by element). This instruction \nmultiplies each vector element in the lower or upper half of the first source \nSIMD&FP register by the specified vector element of the second source SIMD&FP \nregister and subtracts the results from the vector elements of the destination \nSIMD&FP register. The destination vector elements are twice as long as the \nelements that are multiplied. \n\nThe SMLSL instruction extracts vector elements from the lower half of the \nfirst source register, while the SMLSL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMLSL, SMLSL2 (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx0110x0xxxxxxxxxx", 
                "title": "SMLSL, SMLSL2 (by element)"
            }
        ], 
        "file": "smlsl_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire Register Halfword derives an address from a base register value, \nloads a halfword from memory, zero-extends it, and writes it to a register. \nThe instruction also has memory ordering semantics as described in \nLoad-Acquire, Store-Release. For information about memory accesses, see \nLoad/Store addressing modes. \n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for \nsoftware to observe the presence of the acquire semantic other than its effect \non the arrival at endpoints.", 
        "title": "LDARH", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDARH  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001000110xxxxx1xxxxxxxxxxxxxxx", 
                "title": "LDARH"
            }
        ], 
        "file": "ldarh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned maximum on byte in memory, without return, atomically loads an \n8-bit byte from memory, compares it against the value held in a register, and \nstores the larger value back to memory, treating the values as unsigned \nnumbers. \n\n* STUMAXB has no memory ordering semantics. \n* STUMAXLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB. \n* The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the \n  operational pseudocode for this instruction.", 
        "title": "STUMAXB, STUMAXLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx011000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STUMAXB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STUMAXLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stumaxb_ldumaxb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Bitfield Insert in Zero zeroes the destination register and copies \nany number of contiguous bits from a source register into any position in the \ndestination register. \n\nThis is an alias of UBFM. This means: \n\n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "UBFIZ", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "UBFIZ  <Xd>, <Xn>, #<lsb>, #<width>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "UBFIZ"
            }
        ], 
        "file": "ubfiz_ubfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Conditional signaling Compare (scalar). This instruction \ncompares the two SIMD&FP source register values and writes the result to the \nPSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N, \nZ, C, V} flags are set to the flag bit specifier. \n\nIf either operand is any type of NaN, or if either operand is a signaling NaN, \nthe instruction raises an Invalid Operation exception. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCCMPE", 
        "classes": [
            {
                "fields": {
                    "nzcv": {
                        "lo": 0, 
                        "hi": 3, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 4, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FCCMPE  <Sn>, <Sm>, #<nzcv>, <cond>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxxxxxx01xxxxx1xxxx", 
                "title": "FCCMPE"
            }
        ], 
        "file": "fccmpe_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum Number (scalar). This instruction compares the first \nand second source SIMD&FP register values, and writes the smaller of the two \nfloating-point values to the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result that is placed in \nthe vector is the numerical value, otherwise the result is identical to FMIN \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMINNM (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMINNM  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMINNM  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMINNM  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx011110xxxxxxxxxx", 
                "title": "FMINNM (scalar)"
            }
        ], 
        "file": "fminnm_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register (immediate) loads a word or doubleword from memory and writes it \nto a register. The address that is used for the load is calculated from a base \nregister and an immediate offset. For information about memory accesses, see \nLoad/Store addressing modes. The Unsigned offset variant scales the immediate \noffset value by the size of the value accessed before adding it to the base \nregister value. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "LDR (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000010xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDR  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Xt>, [<Xn|SP>], #<simm>", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000010xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDR  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Xt>, [<Xn|SP>, #<simm>]!", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x11100101xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldr_imm_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the \nvalues of the first two SIMD&FP source registers, adds the product to the \nvalue of the third SIMD&FP source register, and writes the result to the \nSIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMADD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "o1": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMADD  <Hd>, <Hn>, <Hm>, <Ha>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMADD  <Sd>, <Sn>, <Sm>, <Sa>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMADD  <Dd>, <Dn>, <Dm>, <Da>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011111xx0xxxxx0xxxxxxxxxxxxxxx", 
                "title": "FMADD"
            }
        ], 
        "file": "fmadd_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Data Synchronization Barrier is a memory barrier that ensures the completion \nof memory accesses, see Data Synchronization Barrier.", 
        "title": "DSB", 
        "classes": [
            {
                "fields": {
                    "opc": {
                        "lo": 5, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DSB  <option>|#<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110011xxxx10011111", 
                "title": "DSB"
            }
        ], 
        "file": "dsb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Compare (immediate) sets the value of the condition flags to the \nresult of the comparison of a register value and an immediate value if the \ncondition is TRUE, and an immediate value otherwise.", 
        "title": "CCMP (immediate)", 
        "classes": [
            {
                "fields": {
                    "nzcv": {
                        "lo": 0, 
                        "hi": 3, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CCMP  <Wn>, #<imm>, #<nzcv>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1111010010xxxxxxxxx10xxxxx0xxxx", 
                "title": "CCMP (immediate)"
            }
        ], 
        "file": "ccmp_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum Number (vector). This instruction compares \ncorresponding vector elements in the two source SIMD&FP registers, writes the \nsmaller of the two floating-point values into a vector, and writes the vector \nto the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result placed in the \nvector is the numerical value, otherwise the result is identical to FMIN \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMINNM (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "a": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110110xxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x1xxxxx110001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fminnm_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply-Add to accumulator (vector, by element). This instruction multiplies \nthe vector elements in the first source SIMD&FP register by the specified \nvalue in the second source SIMD&FP register, and accumulates the results with \nthe vector elements of the destination SIMD&FP register. All the values in \nthis instruction are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MLA (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx0000x0xxxxxxxxxx", 
                "title": "MLA (by element)"
            }
        ], 
        "file": "mla_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Pointer Authentication Code for Instruction address, using key B. This \ninstruction computes and inserts a pointer authentication code for an \ninstruction address, using a modifier and key B. \n\nThe address is: \n\n* In the general-purpose register that is specified by <Xd> for PACIB and \n  PACIZB. \n* In X17, for PACIB1716. \n* In X30, for PACIBSP and PACIBZ. \nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACIB. \n* The value zero, for PACIZB and PACIBZ. \n* In X16, for PACIB1716. \n* In SP, for PACIBSP. \nIt has encodings from 2 classes: Integer and System", 
        "title": "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "PACIB  <Xd>, <Xn|SP>", 
                        "title": "PACIB"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "PACIZB  <Xd>", 
                        "title": "PACIZB"
                    }
                ], 
                "arch": "ARMv8.3"
            }, 
            {
                "title": "System", 
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "01x"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "00x1"
                    }
                }, 
                "unallocated": null, 
                "mask": "1101010100000011001000x101x11111", 
                "encodings": [
                    {
                        "bitdiff": "(CRm == 0001 && op2 == 010)", 
                        "arch": null, 
                        "asm": "PACIB1716", 
                        "title": "PACIB1716"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 011)", 
                        "arch": null, 
                        "asm": "PACIBSP", 
                        "title": "PACIBSP"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 010)", 
                        "arch": null, 
                        "asm": "PACIBZ", 
                        "title": "PACIBZ"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "pacib.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Zip vectors (primary). This instruction reads adjacent vector elements from \nthe upper half of two source SIMD&FP registers as pairs, interleaves the pairs \nand places them into a vector, and writes the vector to the destination \nSIMD&FP register. The first pair from the first source register is placed into \nthe two lowest vector elements, with subsequent pairs taken alternately from \neach source register. \n\nThis instruction can be used with ZIP2 to interleave two vectors. \n\nThe following figure shows an example of the operation of ZIP1 and ZIP2 with \nthe arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ZIP1", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx0xxxxx001110xxxxxxxxxx", 
                "title": "ZIP1"
            }
        ], 
        "file": "zip1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare signed Greater than or Equal (vector). This instruction compares each \nvector element in the first source SIMD&FP register with the corresponding \nvector element in the second source SIMD&FP register and if the first signed \ninteger value is greater than or equal to the second signed integer value sets \nevery bit of the corresponding vector element in the destination SIMD&FP \nregister to one, otherwise sets every bit of the corresponding vector element \nin the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMGE (register)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGE  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmge_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Select. This instruction sets each bit in the destination SIMD&FP \nregister to the corresponding bit from the first source SIMD&FP register when \nthe original destination bit was 1, otherwise from the second source SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "BSL", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc2": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110011xxxxx000111xxxxxxxxxx", 
                "title": "BSL"
            }
        ], 
        "file": "bsl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum Number (scalar). This instruction compares the first \nand second source SIMD&FP register values, and writes the larger of the two \nfloating-point values to the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result that is placed in \nthe vector is the numerical value, otherwise the result is identical to FMAX \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMAXNM (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMAXNM  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMAXNM  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMAXNM  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx011010xxxxxxxxxx", 
                "title": "FMAXNM (scalar)"
            }
        ], 
        "file": "fmaxnm_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare signed Less than or Equal to zero (vector). This instruction reads \neach vector element in the source SIMD&FP register and if the signed integer \nvalue is less than or equal to zero sets every bit of the corresponding vector \nelement in the destination SIMD&FP register to one, otherwise sets every bit \nof the corresponding vector element in the destination SIMD&FP register to \nzero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMLE (zero)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx100000100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMLE  <V><d>, <V><n>, #0", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx100000100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMLE  <Vd>.<T>, <Vn>.<T>, #0", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmle_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, toward Zero (scalar). This instruction \nrounds a floating-point value in the SIMD&FP source register to an integral \nfloating-point value of the same size using the Round towards Zero rounding \nmode, and writes the result to the SIMD&FP destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FRINTZ (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "rmode": {
                        "lo": 15, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "011"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FRINTZ  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FRINTZ  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FRINTZ  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100101110000xxxxxxxxxx", 
                "title": "FRINTZ (scalar)"
            }
        ], 
        "file": "frintz_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store SIMD&FP register (immediate offset). This instruction stores a single \nSIMD&FP register to memory. The address that is used for the store is \ncalculated from a base register value and an immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "STR (immediate, SIMD&FP)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx111100x00xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Bt>, [<Xn|SP>], #<simm>", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Ht>, [<Xn|SP>], #<simm>", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <St>, [<Xn|SP>], #<simm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Dt>, [<Xn|SP>], #<simm>", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 10)", 
                        "arch": null, 
                        "asm": "STR  <Qt>, [<Xn|SP>], #<simm>", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx111100x00xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Bt>, [<Xn|SP>, #<simm>]!", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Ht>, [<Xn|SP>, #<simm>]!", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <St>, [<Xn|SP>, #<simm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Dt>, [<Xn|SP>, #<simm>]!", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 10)", 
                        "arch": null, 
                        "asm": "STR  <Qt>, [<Xn|SP>, #<simm>]!", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx111101x0xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Bt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Ht>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <St>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Dt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 10)", 
                        "arch": null, 
                        "asm": "STR  <Qt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "str_imm_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies \neach vector element in the lower or upper half of the first source SIMD&FP \nregister by the specified vector element of the second source SIMD&FP register \nand accumulates the results with the vector elements of the destination \nSIMD&FP register. The destination vector elements are twice as long as the \nelements that are multiplied. \n\nThe UMLAL instruction extracts vector elements from the lower half of the \nfirst source register, while the UMLAL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMLAL, UMLAL2 (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx0010x0xxxxxxxxxx", 
                "title": "UMLAL, UMLAL2 (by element)"
            }
        ], 
        "file": "umlal_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire Register derives an address from a base register value, loads a \n32-bit word or 64-bit doubleword from memory, and writes it to a register. The \ninstruction also has memory ordering semantics as described in Load-Acquire, \nStore-Release. For information about memory accesses, see Load/Store \naddressing modes. \n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for \nsoftware to observe the presence of the acquire semantic other than its effect \non the arrival at endpoints.", 
        "title": "LDAR", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDAR  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDAR  <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000110xxxxx1xxxxxxxxxxxxxxx", 
                "title": "LDAR"
            }
        ], 
        "file": "ldar.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a \nregister value and an optionally-shifted register value, and writes the result \nto the destination register. It updates the condition flags based on the \nresult. \n\nThis instruction is used by the alias TST (shifted register).", 
        "title": "ANDS (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101010xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ANDS (shifted register)"
            }
        ], 
        "file": "ands_log_shift.html", 
        "type": "instruction", 
        "aliases": [
            "tst_ands_log_shift.html"
        ]
    }, 
    {
        "description": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero. \nThis instruction converts the double-precision floating-point value in the \nSIMD&FP source register to a 32-bit signed integer using the Round towards \nZero rounding mode, and writes the result to the general-purpose destination \nregister. If the result is too large to be accommodated as a signed 32-bit \ninteger, then the result is the integer modulo 232, as held in a 32-bit signed \ninteger. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FJCVTZS", 
        "classes": [
            {
                "title": "Double-precision to 32-bit", 
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0001111001111110000000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FJCVTZS  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "fjcvtzs.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Profiling Synchronization Barrier. This instruction is a barrier that ensures \nthat all existing profiling data for the current PE has been formatted, and \nprofiling buffer addresses have been translated such that all writes to the \nprofiling buffer have been initiated. A following DSB instruction completes \nwhen the writes to the profiling buffer have completed. \n\nIf the Statistical Profiling Extension is not implemented, this instruction \nexecutes as a NOP.", 
        "title": "PSB CSYNC", 
        "classes": [
            {
                "title": "System", 
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0010"
                    }
                }, 
                "unallocated": null, 
                "mask": "11010101000000110010001000111111", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PSB CSYNC", 
                        "title": "System"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "psb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Reciprocal Square Root Estimate. This instruction calculates an \napproximate square root for each vector element in the source SIMD&FP \nregister, places the result in a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FRSQRTE", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111011111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTE  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTE  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTE  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTE  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frsqrte_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire RCpc Register Byte derives an address from a base register value, \nloads a byte from the derived address in memory, zero-extends it and writes it \nto a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire, \nStore-Release, except that: \n\n* There is no ordering requirement, separate from the requirements of a \n  Load-Acquirepc or a Store-Release, created by having a Store-Release \n  followed by a Load-Acquirepc instruction. \n* The reading of a value written by a Store-Release by a Load-Acquirepc \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed. \nThis difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "LDAPRB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "(1)": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000101xxxxx110000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDAPRB  <Wt>, [<Xn|SP> {,#0}]", 
                        "title": "Integer"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "ldaprb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends \nit, and writes the result to a register. The address that is used for the load \nis calculated from a base register and an immediate offset. For information \nabout memory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "LDRH (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000010xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRH  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "Post-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000010xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRH  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "Pre-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111100101xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "Unsigned offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldrh_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding toward Plus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP \nsource register to a 32-bit or 64-bit signed integer using the Round towards \nPlus Infinity rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTPS (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTPS  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTPS  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTPS  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTPS  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTPS  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTPS  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx101000000000xxxxxxxxxx", 
                "title": "FCVTPS (scalar)"
            }
        ], 
        "file": "fcvtps_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load one single-element structure to one lane of one register. This \ninstruction loads a single-element structure from memory and writes the result \nto the specified lane of the SIMD&FP register without affecting the other bits \nof the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD1 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110101000000xx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 000)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101110xxxxxxx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.H }[<index>], [<Xn|SP>], #2", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.S }[<index>], [<Xn|SP>], #4", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.D }[<index>], [<Xn|SP>], #8", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld1_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitfield Insert copies any number of low-order bits from a source register \ninto the same number of adjacent bits at any position in the destination \nregister, leaving other bits unchanged. \n\nThis is an alias of BFM. This means: \n\n* The encodings in this description are named to match the encodings of BFM. \n* The description of BFM gives the operational pseudocode for this \n  instruction.", 
        "title": "BFI", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "!=", 
                        "value": "11111"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "BFI  <Wd>, <Wn>, #<lsb>, #<width>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "BFI  <Xd>, <Xn>, #<lsb>, #<width>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"
                ], 
                "mask": "x01100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "BFI"
            }
        ], 
        "file": "bfi_bfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Insert vector element from general-purpose register. This instruction copies \nthe contents of the source general-purpose register to the specified vector \nelement in the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP \nregister without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias MOV (from general).", 
        "title": "INS (general)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "INS  <Vd>.<Ts>[<index>], <R><n>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001110000xxxxx000111xxxxxxxxxx", 
                "title": "INS (general)"
            }
        ], 
        "file": "ins_advsimd_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Halfword (unscaled) calculates an address from a base register \nand an immediate offset, loads a halfword from memory, zero-extends it, and \nwrites it to a register. For information about memory accesses, see Load/Store \naddressing modes.", 
        "title": "LDURH", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDURH  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01111000010xxxxxxxxx00xxxxxxxxxx", 
                "title": "LDURH"
            }
        ], 
        "file": "ldurh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA512 Schedule Update 1 takes the values from the three source SIMD&FP \nregisters and produces a 128-bit output value that combines the gamma1 \nfunctions of two iterations of the SHA512 schedule update that are performed \nafter the first 16 iterations within a block. It returns this value to the \ndestination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "SHA512SU1", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110011xxxxx100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sha512su1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Extract Narrow. This instruction reads each vector element from the source \nSIMD&FP register, narrows each value to half the original width, places the \nresult into a vector, and writes the vector to the lower or upper half of the \ndestination SIMD&FP register. The destination vector elements are half as long \nas the source vector elements. \n\nThe XTN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the XTN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "XTN, XTN2", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx100001001010xxxxxxxxxx", 
                "title": "XTN, XTN2"
            }
        ], 
        "file": "xtn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Rounding Shift Left (register). This instruction takes each element \nin the vector of the first source SIMD&FP register, shifts the vector element \nby a value from the least significant byte of the corresponding element of the \nsecond source SIMD&FP register, places the results in a vector, and writes the \nvector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift \nvalue is negative, it is a rounding right shift. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "URSHL", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URSHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "urshl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction \nstores a pair of SIMD&FP registers to memory, issuing a hint to the memory \nsystem that the access is non-temporal. The address used for the store is \ncalculated from an address from a base register value and an immediate offset. \nFor information about non-temporal pair instructions, see Load/Store SIMD and \nFloating-point Non-temporal pair. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "STNP (SIMD&FP)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "STNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "xx10110000xxxxxxxxxxxxxxxxxxxxxx", 
                "title": "STNP (SIMD&FP)"
            }
        ], 
        "file": "stnp_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned \ninteger value from the vector in the source SIMD&FP register, right shifts \neach result by an immediate value, writes the final result to a vector, and \nwrites the vector to the lower or upper half of the destination SIMD&FP \nregister. The destination vector elements are half as long as the source \nvector elements. The results are rounded. For truncated results, see SHRN. \n\nThe RSHRN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the RSHRN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "RSHRN, RSHRN2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx100011xxxxxxxxxx", 
                "title": "RSHRN, RSHRN2"
            }
        ], 
        "file": "rshrn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Subtract. This instruction subtracts the element values of \nthe second source SIMD&FP register from the corresponding element values of \nthe first source SIMD&FP register, places the results into a vector, and \nwrites the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQSUB", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSUB  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqsub_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA1 hash update (choose).", 
        "title": "SHA1C", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA1C  <Qd>, <Sn>, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx000000xxxxxxxxxx", 
                "title": "SHA1C"
            }
        ], 
        "file": "sha1c_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory, \nperforms a bitwise AND with the complement of the value held in a register on \nit, and stores the result back to memory. The value initially loaded from \nmemory is returned in the destination register. \n\n* If the destination register is not WZR, LDCLRAB and LDCLRALB load from \n  memory with acquire semantics. \n* LDCLRLB and LDCLRALB store to memory with release semantics. \n* LDCLRB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STCLRB, STCLRLB.", 
        "title": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx000100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLRB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldclrb.html", 
        "type": "instruction", 
        "aliases": [
            "stclrb_ldclrb.html"
        ]
    }, 
    {
        "description": "Signed Multiply Long (vector, by element). This instruction multiplies each \nvector element in the lower or upper half of the first source SIMD&FP register \nby the specified vector element of the second source SIMD&FP register, places \nthe result in a vector, and writes the vector to the destination SIMD&FP \nregister. The destination vector elements are twice as long as the elements \nthat are multiplied. \n\nThe SMULL instruction extracts vector elements from the lower half of the \nfirst source register, while the SMULL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMULL, SMULL2 (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx1010x0xxxxxxxxxx", 
                "title": "SMULL, SMULL2 (by element)"
            }
        ], 
        "file": "smull_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from \nmemory, performs an exclusive OR with the value held in a register on it, and \nstores the result back to memory. The value initially loaded from memory is \nreturned in the destination register. \n\n* If the destination register is not WZR, LDEORAB and LDEORALB load from \n  memory with acquire semantics. \n* LDEORLB and LDEORALB store to memory with release semantics. \n* LDEORB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STEORB, STEORLB.", 
        "title": "LDEORB, LDEORAB, LDEORALB, LDEORLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx001000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEORAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEORB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldeorb.html", 
        "type": "instruction", 
        "aliases": [
            "steorb_ldeorb.html"
        ]
    }, 
    {
        "description": "Compare signed Greater than zero (vector). This instruction reads each vector \nelement in the source SIMD&FP register and if the signed integer value is \ngreater than zero sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to one, otherwise sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMGT (zero)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx100000100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGT  <V><d>, <V><n>, #0", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx100000100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGT  <Vd>.<T>, <Vn>.<T>, #0", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmgt_advsimd_zero.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Exception Return, with pointer authentication. This instruction authenticates \nthe address in ELR, using SP as the modifier and the specified key, the PE \nrestores PSTATE from the SPSR for the current Exception level, and branches to \nthe authenticated address. \n\nKey A is used for ERETAA, and key B is used for ERETAB. \n\nIf the authentication passes, the PE continues execution at the target of the \nbranch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to ELR. \n\nThe PE checks the SPSR for the current Exception level for an illegal return \nevent. See Illegal return events from AArch64 state. \n\nERETAA and ERETAB are undefined at EL0.", 
        "title": "ERETAA, ERETAB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "op4": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110101101001111100001x1111111111", 
                "encodings": [
                    {
                        "bitdiff": "(M == 0)", 
                        "arch": null, 
                        "asm": "ERETAA", 
                        "title": "ERETAA"
                    }, 
                    {
                        "bitdiff": "(M == 1)", 
                        "arch": null, 
                        "asm": "ERETAB", 
                        "title": "ERETAB"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "ereta.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register \nvalue and an immediate value, and writes the result to the destination \nregister.", 
        "title": "EOR (immediate)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "EOR  <Wd|WSP>, <Wn>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "EOR  <Xd|SP>, <Xn>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10100100xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "EOR (immediate)"
            }
        ], 
        "file": "eor_log_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND \nbetween the first source SIMD&FP register and the complement of the second \nsource SIMD&FP register, and writes the result to the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "BIC (vector, register)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110011xxxxx000111xxxxxxxxxx", 
                "title": "BIC (vector, register)"
            }
        ], 
        "file": "bic_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of \na register value and the complement of an optionally-shifted register value, \nand writes the result to the destination register. It updates the condition \nflags based on the result.", 
        "title": "BICS (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101010xx1xxxxxxxxxxxxxxxxxxxxx", 
                "title": "BICS (shifted register)"
            }
        ], 
        "file": "bics.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unzip vectors (secondary). This instruction reads corresponding odd-numbered \nvector elements from the two source SIMD&FP registers, places the result from \nthe first source register into consecutive elements in the lower half of a \nvector, and the result from the second source register into consecutive \nelements in the upper half of a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThis instruction can be used with UZP1 to de-interleave two vectors. \n\nThe following figure shows an example of the operation of UZP1 and UZP2 with \nthe arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UZP2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx0xxxxx010110xxxxxxxxxx", 
                "title": "UZP2"
            }
        ], 
        "file": "uzp2_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit \nhalfword from memory, compares it against the value held in a register, and \nstores the smaller value back to memory, treating the values as unsigned \nnumbers. The value initially loaded from memory is returned in the destination \nregister. \n\n* If the destination register is not WZR, LDUMINAH and LDUMINALH load from \n  memory with acquire semantics. \n* LDUMINLH and LDUMINALH store to memory with release semantics. \n* LDUMINH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMINH, STUMINLH.", 
        "title": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx011100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMINH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "lduminh.html", 
        "type": "instruction", 
        "aliases": [
            "stuminh_lduminh.html"
        ]
    }, 
    {
        "description": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector \nelement in the source SIMD&FP register, right shifts each result by an \nimmediate value, writes the final result to a vector, and writes the vector to \nthe destination SIMD&FP register. All the values in this instruction are \nunsigned integer values. The results are rounded. For truncated results, see \nUSHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "URSHR", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URSHR  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "urshr_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Negated fused Multiply-Add (scalar). This instruction \nmultiplies the values of the first two SIMD&FP source registers, negates the \nproduct, subtracts the value of the third SIMD&FP source register, and writes \nthe result to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FNMADD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "o1": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FNMADD  <Hd>, <Hn>, <Hm>, <Ha>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FNMADD  <Sd>, <Sn>, <Sm>, <Sa>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FNMADD  <Dd>, <Dn>, <Dm>, <Da>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011111xx1xxxxx0xxxxxxxxxxxxxxx", 
                "title": "FNMADD"
            }
        ], 
        "file": "fnmadd_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare Negative (extended register) adds a register value and a sign or \nzero-extended register value, followed by an optional left shift amount. The \nargument that is extended from the <Rm> register can be a byte, halfword, \nword, or doubleword. It updates the condition flags based on the result, and \ndiscards the result. \n\nThis is an alias of ADDS (extended register). This means: \n\n* The encodings in this description are named to match the encodings of ADDS \n  (extended register). \n* The description of ADDS (extended register) gives the operational pseudocode \n  for this instruction.", 
        "title": "CMN (extended register)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm3": {
                        "lo": 10, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CMN  <Xn|SP>, <R><m>{, <extend> {#<amount>}}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101011001xxxxxxxxxxxxxxxx11111", 
                "title": "CMN (extended register)"
            }
        ], 
        "file": "cmn_adds_addsub_ext.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load multiple 3-element structures to three registers. This instruction loads \nmultiple 3-element structures from memory and writes the result to the three \nSIMD&FP registers, with de-interleaving. \n\nThe following figure shows an example of the operation of de-interleaving of a \nLD3.16 (multiple 3-element structures) instruction:. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD3 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100010000000100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0100"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100110xxxxx0100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld3_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Absolute Compare Greater than or Equal (vector). This \ninstruction compares the absolute value of each floating-point value in the \nfirst source SIMD&FP register with the absolute value of the corresponding \nfloating-point value in the second source SIMD&FP register and if the first \nvalue is greater than or equal to the second value sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to one, \notherwise sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FACGE", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110010xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGE  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x1xxxxx111011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGE  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110010xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx111011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "facge_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Authenticate Data address, using key A. This instruction authenticates a data \naddress, using a modifier and key A. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTDA. \n* The value zero, for AUTDZA. \nIf the authentication passes, the upper bits of the address are restored to \nenable subsequent use of the address. If the authentication fails, the upper \nbits are corrupted and any subsequent use of the address results in a \nTranslation fault.", 
        "title": "AUTDA, AUTDZA", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "AUTDA  <Xd>, <Xn|SP>", 
                        "title": "AUTDA"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "AUTDZA  <Xd>", 
                        "title": "AUTDZA"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "autda.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and \ncompares it against the value held in a first register. If the comparison is \nequal, the value in a second register is written to memory. If the write is \nperformed, the read and write occur atomically such that no other modification \nof the memory location can take place between the read and write. \n\n* CASAH and CASALH load from memory with acquire semantics. \n* CASLH and CASALH store to memory with release semantics. \n* CAS has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors \nassociated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the register which is \ncompared and loaded, that is <Ws>, is restored to the values held in the \nregister before the instruction was executed.", 
        "title": "CASH, CASAH, CASALH, CASLH", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "010010001x1xxxxxx11111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(L == 1 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASAH"
                    }, 
                    {
                        "bitdiff": "(L == 1 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASALH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASALH"
                    }, 
                    {
                        "bitdiff": "(L == 0 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASH"
                    }, 
                    {
                        "bitdiff": "(L == 0 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "cash.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies \ncorresponding signed integer values in the lower or upper half of the vectors \nof the two source SIMD&FP registers, doubles the results, and subtracts the \nfinal results from the vector elements of the destination SIMD&FP register. \nThe destination vector elements are twice as long as the elements that are \nmultiplied. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLSL instruction extracts each source vector from the lower half of \neach source register, while the SQDMLSL2 instruction extracts each source \nvector from the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMLSL, SQDMLSL2 (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx101100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx101100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmlsl_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA512 Hash update part 2 takes the values from the three 128-bit source \nSIMD&FP registers and produces a 128-bit output value that combines the sigma0 \nand majority functions of two iterations of the SHA512 computation. It returns \nthis value to the destination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "SHA512H2", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110011xxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA512H2  <Qd>, <Qn>, <Vm>.2D", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sha512h2_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to \nmemory if the PE has exclusive access to the memory address, and returns a \nstatus value of 0 if the store was successful, or of 1 if no store was \nperformed. See Synchronization and semaphores. The memory access is atomic. \nThe instruction also has memory ordering semantics as described in \nLoad-Acquire, Store-Release. For information about memory accesses see \nLoad/Store addressing modes.", 
        "title": "STLXRB", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00001000000xxxxx1xxxxxxxxxxxxxxx", 
                "title": "STLXRB"
            }
        ], 
        "file": "stlxrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit set on word or doubleword in memory, without return, atomically \nloads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR \nwith the value held in a register on it, and stores the result back to memory. \n\n* STSET has no memory ordering semantics. \n* STSETL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSET, LDSETA, LDSETAL, LDSETL. This means: \n\n* The encodings in this description are named to match the encodings of LDSET, \n  LDSETA, LDSETAL, LDSETL. \n* The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational \n  pseudocode for this instruction.", 
        "title": "STSET, STSETL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx001100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STSET  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDSET alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STSETL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDSETL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STSET  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDSET alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STSETL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDSETL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stset_ldset.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating \nthe vector elements of the first source SIMD&FP register after the vector \nelements of the second source SIMD&FP register, reads each pair of adjacent \nvector elements in the two source SIMD&FP registers, writes the smallest of \neach pair of unsigned integer values into a vector, and writes the vector to \nthe destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMINP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx101011xxxxxxxxxx", 
                "title": "UMINP"
            }
        ], 
        "file": "uminp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register \nvalue and an optionally-shifted register value, and writes the result to the \ndestination register. \n\nThis instruction is used by the alias MOV (register).", 
        "title": "ORR (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101010xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ORR (shifted register)"
            }
        ], 
        "file": "orr_log_shift.html", 
        "type": "instruction", 
        "aliases": [
            "mov_orr_log_shift.html"
        ]
    }, 
    {
        "description": "Add with Carry adds two register values and the Carry flag value, and writes \nthe result to the destination register.", 
        "title": "ADC", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADC  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADC  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010000xxxxx000000xxxxxxxxxx", 
                "title": "ADC"
            }
        ], 
        "file": "adc.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Shift Right and Accumulate (immediate). This instruction reads each \nvector element in the source SIMD&FP register, right shifts each result by an \nimmediate value, and accumulates the final results with the vector elements of \nthe destination SIMD&FP register. All the values in this instruction are \nsigned integer values. The results are truncated. For rounded results, see \nSRSRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SSRA", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSRA  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ssra_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move System Register allows the PE to read an AArch64 System register into a \ngeneral-purpose register.", 
        "title": "MRS", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 19, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "110101010011xxxxxxxxxxxxxxxxxxxx", 
                "title": "MRS"
            }
        ], 
        "file": "mrs.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Rounding Shift Left (register). This instruction takes each \nvector element in the first source SIMD&FP register, shifts it by a value from \nthe least significant byte of the corresponding vector element of the second \nsource SIMD&FP register, places the results into a vector, and writes the \nvector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it \nis a right shift. The results are rounded. For truncated results, see SQSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRSHL", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx010111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRSHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx010111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqrshl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire Exclusive Register derives an address from a base register value, \nloads a 32-bit word or 64-bit doubleword from memory, and writes it to a \nregister. The memory access is atomic. The PE marks the physical address being \naccessed as an exclusive access. This exclusive access mark is checked by \nStore Exclusive instructions. See Synchronization and semaphores. The \ninstruction also has memory ordering semantics as described in Load-Acquire, \nStore-Release. For information about memory accesses see Load/Store addressing \nmodes.", 
        "title": "LDAXR", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDAXR  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDAXR  <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000010xxxxx1xxxxxxxxxxxxxxx", 
                "title": "LDAXR"
            }
        ], 
        "file": "ldaxr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Rotate Right (register) provides the value of the contents of a register \nrotated by a variable number of bits. The bits that are rotated off the right \nend are inserted into the vacated bit positions on the left. The remainder \nobtained by dividing the second source register by the data size defines the \nnumber of bits by which the first source register is right-shifted. \n\nThis is an alias of RORV. This means: \n\n* The encodings in this description are named to match the encodings of RORV. \n* The description of RORV gives the operational pseudocode for this \n  instruction.", 
        "title": "ROR (register)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ROR  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ROR  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001011xxxxxxxxxx", 
                "title": "ROR (register)"
            }
        ], 
        "file": "ror_rorv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Add Wide. This instruction adds vector elements of the first source \nSIMD&FP register to the corresponding vector elements in the lower or upper \nhalf of the second source SIMD&FP register, places the results in a vector, \nand writes the vector to the SIMD&FP destination register. \n\nThe SADDW instruction extracts the second source vector from the lower half of \nthe second source register, while the SADDW2 instruction extracts the second \nsource vector from the upper half of the second source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SADDW, SADDW2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx000100xxxxxxxxxx", 
                "title": "SADDW, SADDW2"
            }
        ], 
        "file": "saddw_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Increment returns, in the destination register, the value of the \nsource register incremented by 1 if the condition is TRUE, and otherwise \nreturns the value of the source register. \n\nThis is an alias of CSINC. This means: \n\n* The encodings in this description are named to match the encodings of CSINC. \n* The description of CSINC gives the operational pseudocode for this \n  instruction.", 
        "title": "CINC", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "!=", 
                        "value": "111x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "!=", 
                        "value": "11111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "!=", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CINC  <Wd>, <Wn>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CINC  <Xd>, <Xn>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxxxx11111xxxxxxxxxxxxxxxx", 
                    "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx", 
                    "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"
                ], 
                "mask": "x0011010100xxxxxxxxx01xxxxxxxxxx", 
                "title": "CINC"
            }
        ], 
        "file": "cinc_csinc.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Byte (register) calculates an address from a base register value \nand an offset register value, loads a byte from memory, zero-extends it, and \nwrites it to a register. For information about memory accesses, see Load/Store \naddressing modes.", 
        "title": "LDRB (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(option != 011)", 
                        "arch": null, 
                        "asm": "LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]", 
                        "title": "Extended register"
                    }, 
                    {
                        "bitdiff": "(option == 011)", 
                        "arch": null, 
                        "asm": "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", 
                        "title": "Shifted register"
                    }
                ], 
                "unallocated": null, 
                "mask": "00111000011xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDRB (register)"
            }
        ], 
        "file": "ldrb_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare and Branch on Zero compares the value in a register with zero, and \nconditionally branches to a label at a PC-relative offset if the comparison is \nequal. It provides a hint that this is not a subroutine call or return. This \ninstruction does not affect condition flags.", 
        "title": "CBZ", 
        "classes": [
            {
                "fields": {
                    "imm19": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CBZ  <Wt>, <label>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CBZ  <Xt>, <label>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0110100xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "CBZ"
            }
        ], 
        "file": "cbz.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract with Carry, setting flags, subtracts a register value and the value \nof NOT (Carry flag) from a register value, and writes the result to the \ndestination register. It updates the condition flags based on the result. \n\nThis instruction is used by the alias NGCS.", 
        "title": "SBCS", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SBCS  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SBCS  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1111010000xxxxx000000xxxxxxxxxx", 
                "title": "SBCS"
            }
        ], 
        "file": "sbcs.html", 
        "type": "instruction", 
        "aliases": [
            "ngcs_sbcs.html"
        ]
    }, 
    {
        "description": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a \nregister to memory if the PE has exclusive access to the memory address, and \nreturns a status value of 0 if the store was successful, or of 1 if no store \nwas performed. See Synchronization and semaphores. For information about \nmemory accesses see Load/Store addressing modes.", 
        "title": "STXR", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000000xxxxx0xxxxxxxxxxxxxxx", 
                "title": "STXR"
            }
        ], 
        "file": "stxr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Maximum across Vector. This instruction compares all the vector \nelements in the source SIMD&FP register, and writes the largest of the values \nas a scalar to the destination SIMD&FP register. All the values in this \ninstruction are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMAXV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMAXV  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx110000101010xxxxxxxxxx", 
                "title": "UMAXV"
            }
        ], 
        "file": "umaxv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned maximum on halfword in memory, without return, atomically \nloads a 16-bit halfword from memory, compares it against the value held in a \nregister, and stores the larger value back to memory, treating the values as \nunsigned numbers. \n\n* STUMAXH has no memory ordering semantics. \n* STUMAXLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH. \n* The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the \n  operational pseudocode for this instruction.", 
        "title": "STUMAXH, STUMAXLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx011000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STUMAXH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STUMAXLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stumaxh_ldumaxh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA1 schedule update 0.", 
        "title": "SHA1SU0", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx001100xxxxxxxxxx", 
                "title": "SHA1SU0"
            }
        ], 
        "file": "sha1su0_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Compare Negative (immediate) sets the value of the condition flags \nto the result of the comparison of a register value and a negated immediate \nvalue if the condition is TRUE, and an immediate value otherwise.", 
        "title": "CCMN (immediate)", 
        "classes": [
            {
                "fields": {
                    "nzcv": {
                        "lo": 0, 
                        "hi": 3, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CCMN  <Wn>, #<imm>, #<nzcv>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0111010010xxxxxxxxx10xxxxx0xxxx", 
                "title": "CCMN (immediate)"
            }
        ], 
        "file": "ccmn_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to \nAway (scalar). This instruction converts the floating-point value in the \nSIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round \nto Nearest with Ties to Away rounding mode, and writes the result to the \ngeneral-purpose destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTAU (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTAU  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTAU  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTAU  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTAU  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTAU  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTAU  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx100101000000xxxxxxxxxx", 
                "title": "FCVTAU (scalar)"
            }
        ], 
        "file": "fcvtau_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Subtract Long. This instruction subtracts each vector element in the \nlower or upper half of the second source SIMD&FP register from the \ncorresponding vector element of the first source SIMD&FP register, places the \nresult into a vector, and writes the vector to the destination SIMD&FP \nregister. All the values in this instruction are unsigned integer values. The \ndestination vector elements are twice as long as the source vector elements. \n\nThe USUBL instruction extracts each source vector from the lower half of each \nsource register, while the USUBL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "USUBL, USUBL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx001000xxxxxxxxxx", 
                "title": "USUBL, USUBL2"
            }
        ], 
        "file": "usubl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Branch with Link branches to a PC-relative offset, setting the register X30 to \nPC+4. It provides a hint that this is a subroutine call.", 
        "title": "BL", 
        "classes": [
            {
                "fields": {
                    "imm26": {
                        "lo": 0, 
                        "hi": 25, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxxxxxxxxx"
                    }, 
                    "op": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BL  <label>", 
                        "title": "26-bit signed PC-relative branch offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "100101xxxxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "BL"
            }
        ], 
        "file": "bl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, to nearest with ties to Away (scalar). This \ninstruction rounds a floating-point value in the SIMD&FP source register to an \nintegral floating-point value of the same size using the Round to Nearest with \nTies to Away rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FRINTA (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "rmode": {
                        "lo": 15, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "100"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FRINTA  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FRINTA  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FRINTA  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100110010000xxxxxxxxxx", 
                "title": "FRINTA (scalar)"
            }
        ], 
        "file": "frinta_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply-Subtract from accumulator (vector). This instruction multiplies \ncorresponding elements in the vectors of the two source SIMD&FP registers, and \nsubtracts the results from the vector elements of the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MLS (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx100101xxxxxxxxxx", 
                "title": "MLS (vector)"
            }
        ], 
        "file": "mls_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory \nlocation. The instruction also has memory ordering semantics as described in \nLoad LOAcquire, Store LORelease. For information about memory accesses, see \nLoad/Store addressing modes.", 
        "title": "STLLRB", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00001000100xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STLLRB  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stllrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Send Event is a hint instruction. It causes an event to be signaled to all PEs \nin the multiprocessor system. For more information, see Wait for Event \nmechanism and Send event.", 
        "title": "SEV", 
        "classes": [
            {
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SEV", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110010000010011111", 
                "title": "SEV"
            }
        ], 
        "file": "sev.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA256 hash update (part 1).", 
        "title": "SHA256H", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "P": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA256H  <Qd>, <Qn>, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx010000xxxxxxxxxx", 
                "title": "SHA256H"
            }
        ], 
        "file": "sha256h_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP \nregisters and produces a 128-bit output value that combines the gamma0 \nfunctions of two iterations of the SHA512 schedule update that are performed \nafter the first 16 iterations within a block. It returns this value to the \ndestination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "SHA512SU0", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "1100111011000000100000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA512SU0  <Vd>.2D, <Vn>.2D", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sha512su0_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire Exclusive Register Halfword derives an address from a base \nregister value, loads a halfword from memory, zero-extends it and writes it to \na register. The memory access is atomic. The PE marks the physical address \nbeing accessed as an exclusive access. This exclusive access mark is checked \nby Store Exclusive instructions. See Synchronization and semaphores. The \ninstruction also has memory ordering semantics as described in Load-Acquire, \nStore-Release. For information about memory accesses see Load/Store addressing \nmodes.", 
        "title": "LDAXRH", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDAXRH  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001000010xxxxx1xxxxxxxxxxxxxxx", 
                "title": "LDAXRH"
            }
        ], 
        "file": "ldaxrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Absolute difference and Accumulate Long. This instruction subtracts the \nvector elements in the lower or upper half of the second source SIMD&FP \nregister from the corresponding vector elements of the first source SIMD&FP \nregister, and accumulates the absolute values of the results into the vector \nelements of the destination SIMD&FP register. The destination vector elements \nare twice as long as the source vector elements. \n\nThe SABAL instruction extracts each source vector from the lower half of each \nsource register, while the SABAL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SABAL, SABAL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx010100xxxxxxxxxx", 
                "title": "SABAL, SABAL2"
            }
        ], 
        "file": "sabal_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a \n2-bit immediate index value, and returns a 128-bit result in the destination \nSIMD&FP register. It performs a 32-bit majority function between the three \n32-bit fields held in the upper three elements of the first source vector, and \nadds the resulting 32-bit value and the following three other 32-bit values: \n\n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the 32-bit majority function. \n* The 32-bit element held in the top 32 bits of the second source vector, Vn. \n* A 32-bit element indexed out of the third source vector, Vm. \nA three-way exclusive OR is performed of the result of this addition, the \nresult of the addition rotated left by 9, and the result of the addition \nrotated left by 17. The result of this exclusive OR is returned as the top \nelement of the returned result. The other elements of this result are taken \nfrom elements of the first source vector, with the element returned in \nbits<63:32> being rotated left by 19. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM3TT2B", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm2": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110010xxxxx10xx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM3TT2B  <Vd>.S, <Vn>.S, <Vm>.S[<imm2>]", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm3tt2b_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply Long multiplies two 32-bit register values, and writes the \nresult to the 64-bit destination register. \n\nThis is an alias of UMADDL. This means: \n\n* The encodings in this description are named to match the encodings of \n  UMADDL. \n* The description of UMADDL gives the operational pseudocode for this \n  instruction.", 
        "title": "UMULL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMULL  <Xd>, <Wn>, <Wm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011101xxxxx011111xxxxxxxxxx", 
                "title": "UMULL"
            }
        ], 
        "file": "umull_umaddl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed minimum on byte in memory, without return, atomically loads an \n8-bit byte from memory, compares it against the value held in a register, and \nstores the smaller value back to memory, treating the values as signed \nnumbers. \n\n* STSMINB has no memory ordering semantics. \n* STSMINLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB. \n* The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the \n  operational pseudocode for this instruction.", 
        "title": "STSMINB, STSMINLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx010100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STSMINB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STSMINLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stsminb_ldsminb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Divide (scalar). This instruction divides the floating-point \nvalue of the first source SIMD&FP register by the floating-point value of the \nsecond source SIMD&FP register, and writes the result to the destination \nSIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FDIV (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FDIV  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FDIV  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FDIV  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx000110xxxxxxxxxx", 
                "title": "FDIV (scalar)"
            }
        ], 
        "file": "fdiv_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned integer Convert to Floating-point (scalar). This instruction converts \nthe unsigned integer value in the general-purpose source register to a \nfloating-point value using the rounding mode that is specified by the FPCR, \nand writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UCVTF (scalar, integer)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "UCVTF  <Hd>, <Wn>", 
                        "title": "32-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "UCVTF  <Sd>, <Wn>", 
                        "title": "32-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "UCVTF  <Dd>, <Wn>", 
                        "title": "32-bit to double-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "UCVTF  <Hd>, <Xn>", 
                        "title": "64-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "UCVTF  <Sd>, <Xn>", 
                        "title": "64-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "UCVTF  <Dd>, <Xn>", 
                        "title": "64-bit to double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx100011000000xxxxxxxxxx", 
                "title": "UCVTF (scalar, integer)"
            }
        ], 
        "file": "ucvtf_float_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Arithmetic Shift Right Variable shifts a register value right by a variable \nnumber of bits, shifting in copies of its sign bit, and writes the result to \nthe destination register. The remainder obtained by dividing the second source \nregister by the data size defines the number of bits by which the first source \nregister is right-shifted. \n\nThis instruction is used by the alias ASR (register).", 
        "title": "ASRV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ASRV  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ASRV  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001010xxxxxxxxxx", 
                "title": "ASRV"
            }
        ], 
        "file": "asrv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Compare (register) sets the value of the condition flags to the \nresult of the comparison of two registers if the condition is TRUE, and an \nimmediate value otherwise.", 
        "title": "CCMP (register)", 
        "classes": [
            {
                "fields": {
                    "nzcv": {
                        "lo": 0, 
                        "hi": 3, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CCMP  <Wn>, <Wm>, #<nzcv>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1111010010xxxxxxxxx00xxxxx0xxxx", 
                "title": "CCMP (register)"
            }
        ], 
        "file": "ccmp_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Absolute value (scalar). This instruction calculates the \nabsolute value in the SIMD&FP source register and writes the result to the \nSIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FABS (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "opc": {
                        "lo": 15, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FABS  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FABS  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FABS  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100000110000xxxxxxxxxx", 
                "title": "FABS (scalar)"
            }
        ], 
        "file": "fabs_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply Long. This instruction multiplies \ncorresponding vector elements in the lower or upper half of the two source \nSIMD&FP registers, doubles the results, places the final results in a vector, \nand writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMULL instruction extracts each source vector from the lower half of \neach source register, while the SQDMULL2 instruction extracts each source \nvector from the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMULL, SQDMULL2 (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx110100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULL  <Va><d>, <Vb><n>, <Vb><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx110100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmull_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Count leading sign bits: Rd = CLS(Rn).", 
        "title": "CLS", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CLS  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CLS  <Xd>, <Xn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x101101011000000000101xxxxxxxxxx", 
                "title": "CLS"
            }
        ], 
        "file": "cls_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory, \nperforms a bitwise OR with the value held in a register on it, and stores the \nresult back to memory. The value initially loaded from memory is returned in \nthe destination register. \n\n* If the destination register is not WZR, LDSETAB and LDSETALB load from \n  memory with acquire semantics. \n* LDSETLB and LDSETALB store to memory with release semantics. \n* LDSETB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSETB, STSETLB.", 
        "title": "LDSETB, LDSETAB, LDSETALB, LDSETLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx001100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSETAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSETB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldsetb.html", 
        "type": "instruction", 
        "aliases": [
            "stsetb_ldsetb.html"
        ]
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding toward Zero (vector). This \ninstruction converts a scalar or each element in a vector from a \nfloating-point value to a signed integer value using the Round towards Zero \nrounding mode, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTZS (vector, integer)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111011111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZS  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZS  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtzs_advsimd_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move vector element to general-purpose register. This instruction reads the \nunsigned integer from the source SIMD&FP register, zero-extends it to form a \n32-bit or 64-bit value, and writes the result to the destination \ngeneral-purpose register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of UMOV. This means: \n\n* The encodings in this description are named to match the encodings of UMOV. \n* The description of UMOV gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (to general)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxx00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(Q == 0 && imm5 == xx100)", 
                        "arch": null, 
                        "asm": "MOV  <Wd>, <Vn>.S[<index>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(Q == 1 && imm5 == x1000)", 
                        "arch": null, 
                        "asm": "MOV  <Xd>, <Vn>.D[<index>]", 
                        "title": "64-reg,UMOV-64-reg"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110000xxx00001111xxxxxxxxxx", 
                "title": "MOV (to general)"
            }
        ], 
        "file": "mov_umov_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Bitfield Move copies any number of low-order bits from a source \nregister into the same number of adjacent bits at any position in the \ndestination register, shifting in copies of the sign bit in the upper bits and \nzeros in the lower bits. \n\nThis instruction is used by the aliases ASR (immediate), SBFIZ, SBFX, SXTB, \nSXTH, and SXTW.", 
        "title": "SBFM", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "SBFM  <Wd>, <Wn>, #<immr>, #<imms>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "SBFM  <Xd>, <Xn>, #<immr>, #<imms>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "SBFM"
            }
        ], 
        "file": "sbfm.html", 
        "type": "instruction", 
        "aliases": [
            "asr_sbfm.html", 
            "sbfiz_sbfm.html", 
            "sbfx_sbfm.html", 
            "sxtb_sbfm.html", 
            "sxth_sbfm.html", 
            "sxtw_sbfm.html"
        ]
    }, 
    {
        "description": "Signed Shift Left Long (immediate). This instruction reads each vector element \nfrom the source SIMD&FP register, left shifts each vector element by the \nspecified shift amount, places the result into a vector, and writes the vector \nto the destination SIMD&FP register. The destination vector elements are twice \nas long as the source vector elements. All the values in this instruction are \nsigned integer values. \n\nThe SSHLL instruction extracts vector elements from the lower half of the \nsource register, while the SSHLL2 instruction extracts vector elements from \nthe upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias SXTL, SXTL2.", 
        "title": "SSHLL, SSHLL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx101001xxxxxxxxxx", 
                "title": "SSHLL, SSHLL2"
            }
        ], 
        "file": "sshll_advsimd.html", 
        "type": "instruction", 
        "aliases": [
            "sxtl_sshll_advsimd.html"
        ]
    }, 
    {
        "description": "Floating-point Reciprocal exponent (scalar). This instruction finds an \napproximate reciprocal exponent for each vector element in the source SIMD&FP \nregister, places the result in a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRECPX", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111011111001111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPX  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x100001111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPX  <V><d>, <V><n>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frecpx_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and \nwrites it to a register. The instruction also has memory ordering semantics as \ndescribed in Load LOAcquire, Store LORelease. For information about memory \naccesses, see Load/Store addressing modes. \n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for \nsoftware to observe the presence of the acquire semantic other than its effect \non the arrival at endpoints.", 
        "title": "LDLARB", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00001000110xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDLARB  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldlarb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Pair of Registers calculates an address from a base register value and \nan immediate offset, and stores two 32-bit words or two 64-bit doublewords to \nthe calculated address, from two registers. For information about memory \naccesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", 
        "title": "STP", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "x010100010xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "x010100110xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Signed offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "x010100100xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "stp_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply High multiplies two 64-bit register values, and writes \nbits[127:64] of the 128-bit result to the 64-bit destination register.", 
        "title": "UMULH", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMULH  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011110xxxxx0xxxxxxxxxxxxxxx", 
                "title": "UMULH"
            }
        ], 
        "file": "umulh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Multiply (by element). This instruction multiplies the vector \nelements in the first source SIMD&FP register by the specified value in the \nsecond source SIMD&FP register, places the results in a vector, and writes the \nvector to the destination SIMD&FP register. All the values in this instruction \nare floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar, \nsingle-precision and double-precision , Vector, half-precision and Vector, \nsingle-precision and double-precision", 
        "title": "FMUL (by element)", 
        "classes": [
            {
                "title": "Scalar, half-precision", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111100xxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMUL  <Hd>, <Hn>, <Vm>.H[<index>]", 
                        "title": "Scalar, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111111xxxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector, half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111100xxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", 
                        "title": "Vector, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011111xxxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmul_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move between register and stack pointer: Rd = Rn. \n\nThis is an alias of ADD (immediate). This means: \n\n* The encodings in this description are named to match the encodings of ADD \n  (immediate). \n* The description of ADD (immediate) gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (to/from SP)", 
        "classes": [
            {
                "fields": {
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "000000000000"
                    }, 
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MOV  <Wd|WSP>, <Wn|WSP>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOV  <Xd|SP>, <Xn|SP>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x001000100000000000000xxxxxxxxxx", 
                "title": "MOV (to/from SP)"
            }
        ], 
        "file": "mov_add_addsub_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Halfword (unprivileged) loads a halfword from memory, \nsign-extends it to 32 bits or 64 bits, and writes the result to a register. \nThe address that is used for the load is calculated from a base register and \nan immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "LDTRSH", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "011110001x0xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDTRSH"
            }
        ], 
        "file": "ldtrsh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Greater than zero (vector). This instruction reads each \nfloating-point value in the source SIMD&FP register and if the value is \ngreater than zero sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to one, otherwise sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMGT (zero)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111011111000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <Hd>, <Hn>, #0.0", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x100000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <V><d>, <V><n>, #0.0", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmgt_advsimd_zero.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Shift Left Long (by element size). This instruction reads each vector element \nin the lower or upper half of the source SIMD&FP register, left shifts each \nresult by the element size, writes the final result to a vector, and writes \nthe vector to the destination SIMD&FP register. The destination vector \nelements are twice as long as the source vector elements. \n\nThe SHLL instruction extracts vector elements from the lower half of the \nsource register, while the SHLL2 instruction extracts vector elements from the \nupper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SHLL, SHLL2", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx100001001110xxxxxxxxxx", 
                "title": "SHLL, SHLL2"
            }
        ], 
        "file": "shll_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Add (vector). This instruction adds corresponding vector \nelements in the two source SIMD&FP registers, writes the result into a vector, \nand writes the vector to the destination SIMD&FP register. All the values in \nthis instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FADD (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110010xxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx110101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply: Rd = Rn * Rm. \n\nThis is an alias of MADD. This means: \n\n* The encodings in this description are named to match the encodings of MADD. \n* The description of MADD gives the operational pseudocode for this \n  instruction.", 
        "title": "MUL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MUL  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MUL  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011011000xxxxx011111xxxxxxxxxx", 
                "title": "MUL"
            }
        ], 
        "file": "mul_madd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Negate (scalar). This instruction negates the value in the \nSIMD&FP source register and writes the result to the SIMD&FP destination \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FNEG (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "opc": {
                        "lo": 15, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FNEG  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FNEG  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FNEG  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100001010000xxxxxxxxxx", 
                "title": "FNEG (scalar)"
            }
        ], 
        "file": "fneg_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Halfword (register) calculates an address from a base register \nvalue and an offset register value, loads a halfword from memory, zero-extends \nit, and writes it to a register. For information about memory accesses, see \nLoad/Store addressing modes.", 
        "title": "LDRH (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "32-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "01111000011xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDRH (register)"
            }
        ], 
        "file": "ldrh_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit \nhalfword of a register.", 
        "title": "REV16", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "REV16  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "REV16  <Xd>, <Xn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x101101011000000000001xxxxxxxxxx", 
                "title": "REV16"
            }
        ], 
        "file": "rev16_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Negate (vector). This instruction reads each vector element from the source \nSIMD&FP register, negates each value, puts the result into a vector, and \nwrites the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "NEG (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx100000101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "NEG  <V><d>, <V><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx100000101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "NEG  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "neg_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends \nit to the size of the register, and writes the result to the destination \nregister. \n\nThis is an alias of UBFM. This means: \n\n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "UXTH", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "001111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "000000"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UXTH  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "0101001100000000001111xxxxxxxxxx", 
                "title": "UXTH"
            }
        ], 
        "file": "uxth_ubfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum Number of Pair of elements (scalar). This instruction \ncompares two vector elements in the source SIMD&FP register and writes the \nlargest of the floating-point values as a scalar to the destination SIMD&FP \nregister. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAXNMP (scalar)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111000110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNMP  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNMP  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmaxnmp_advsimd_pair.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it \nto the size of the register, and writes the result to the destination \nregister. \n\nThis is an alias of UBFM. This means: \n\n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "UXTB", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "000111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "000000"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UXTB  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "0101001100000000000111xxxxxxxxxx", 
                "title": "UXTB"
            }
        ], 
        "file": "uxtb_ubfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Word (register) calculates an address from a base \nregister value and an offset register value, loads a word from memory, \nsign-extends it to form a 64-bit value, and writes it to a register. The \noffset register value can be shifted left by 0 or 2 bits. For information \nabout memory accesses, see Load/Store addressing modes.", 
        "title": "LDRSW (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10111000101xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDRSW (register)"
            }
        ], 
        "file": "ldrsw_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Shift Left (register). This instruction takes each element \nin the vector of the first source SIMD&FP register, shifts each element by a \nvalue from the least significant byte of the corresponding element of the \nsecond source SIMD&FP register, places the results in a vector, and writes the \nvector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it \nis a right shift. The results are truncated. For rounded results, see SQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQSHL (register)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx010011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx010011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqshl_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Polynomial Multiply. This instruction multiplies corresponding elements in the \nvectors of the two source SIMD&FP registers, places the results in a vector, \nand writes the vector to the destination SIMD&FP register. \n\nFor information about multiplying polynomials see Polynomial arithmetic over \n{0, 1}. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "PMUL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx100111xxxxxxxxxx", 
                "title": "PMUL"
            }
        ], 
        "file": "pmul_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned fixed-point Convert to Floating-point (vector). This instruction \nconverts each element in a vector from fixed-point to floating-point using the \nrounding mode that is specified by the FPCR, and writes the result to the \nSIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UCVTF (vector, fixed-point)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UCVTF  <V><d>, <V><n>, #<fbits>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ucvtf_advsimd_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply-Add multiplies two register values, adds a third register value, and \nwrites the result to the destination register. \n\nThis instruction is used by the alias MUL.", 
        "title": "MADD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MADD  <Wd>, <Wn>, <Wm>, <Wa>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MADD  <Xd>, <Xn>, <Xm>, <Xa>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011011000xxxxx0xxxxxxxxxxxxxxx", 
                "title": "MADD"
            }
        ], 
        "file": "madd.html", 
        "type": "instruction", 
        "aliases": [
            "mul_madd.html"
        ]
    }, 
    {
        "description": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword \nfrom memory, compares it against the value held in a register, and stores the \nsmaller value back to memory, treating the values as signed numbers. The value \ninitially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDSMINAH and LDSMINALH load from \n  memory with acquire semantics. \n* LDSMINLH and LDSMINALH store to memory with release semantics. \n* LDSMINH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMINH, STSMINLH.", 
        "title": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx010100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMINH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMINLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldsminh.html", 
        "type": "instruction", 
        "aliases": [
            "stsminh_ldsminh.html"
        ]
    }, 
    {
        "description": "Signed Multiply Long multiplies two 32-bit register values, and writes the \nresult to the 64-bit destination register. \n\nThis is an alias of SMADDL. This means: \n\n* The encodings in this description are named to match the encodings of \n  SMADDL. \n* The description of SMADDL gives the operational pseudocode for this \n  instruction.", 
        "title": "SMULL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMULL  <Xd>, <Wn>, <Wm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011001xxxxx011111xxxxxxxxxx", 
                "title": "SMULL"
            }
        ], 
        "file": "smull_smaddl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Select returns, in the destination register, the value of the \nfirst source register if the condition is TRUE, and otherwise returns the \nvalue of the second source register.", 
        "title": "CSEL", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CSEL  <Wd>, <Wn>, <Wm>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CSEL  <Xd>, <Xn>, <Xm>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010100xxxxxxxxx00xxxxxxxxxx", 
                "title": "CSEL"
            }
        ], 
        "file": "csel.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Dot Product unsigned arithmetic (vector, by element). This instruction \nperforms the dot product of the four 8-bit elements in each 32-bit element of \nthe first source register with the four 8-bit elements of an indexed 32-bit \nelement in the second source register, accumulating the result into the \ncorresponding 32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", 
        "title": "UDOT (by element)", 
        "classes": [
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx1110x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "udot_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Exclusive Register Halfword stores a halfword from a register to memory \nif the PE has exclusive access to the memory address, and returns a status \nvalue of 0 if the store was successful, or of 1 if no store was performed. See \nSynchronization and semaphores. The memory access is atomic. \n\nFor information about memory accesses see Load/Store addressing modes.", 
        "title": "STXRH", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001000000xxxxx0xxxxxxxxxxxxxxx", 
                "title": "STXRH"
            }
        ], 
        "file": "stxrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Word (unscaled) calculates an address from a base \nregister and an immediate offset, loads a signed word from memory, \nsign-extends it, and writes it to a register. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "LDURSW", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "10111000100xxxxxxxxx00xxxxxxxxxx", 
                "title": "LDURSW"
            }
        ], 
        "file": "ldursw.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar). \nThis instruction converts the floating-point value in the SIMD&FP source \nregister to a 32-bit or 64-bit fixed-point signed integer using the Round \ntowards Zero rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped.", 
        "title": "FCVTZS (scalar, fixed-point)", 
        "classes": [
            {
                "fields": {
                    "scale": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZS  <Wd>, <Hn>, #<fbits>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZS  <Xd>, <Hn>, #<fbits>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Wd>, <Sn>, #<fbits>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Xd>, <Sn>, #<fbits>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Wd>, <Dn>, #<fbits>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Xd>, <Dn>, #<fbits>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx011000xxxxxxxxxxxxxxxx", 
                "title": "FCVTZS (scalar, fixed-point)"
            }
        ], 
        "file": "fcvtzs_float_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned saturating extract Narrow. This instruction reads each vector element \nfrom the source SIMD&FP register, saturates each value to half the original \nwidth, places the result into a vector, and writes the vector to the \ndestination SIMD&FP register. All the values in this instruction are unsigned \ninteger values. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe UQXTN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the UQXTN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQXTN, UQXTN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx100001010010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQXTN  <Vb><d>, <Va><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx100001010010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqxtn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads \neach vector element in the source SIMD&FP register, right shifts each result \nby an immediate value, and accumulates the final results with the vector \nelements of the destination SIMD&FP register. All the values in this \ninstruction are signed integer values. The results are rounded. For truncated \nresults, see SSRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SRSRA", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRSRA  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "srsra_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add (immediate) adds a register value and an optionally-shifted immediate \nvalue, and writes the result to the destination register. \n\nThis instruction is used by the alias MOV (to/from SP).", 
        "title": "ADD (immediate)", 
        "classes": [
            {
                "fields": {
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADD  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0010001xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADD (immediate)"
            }
        ], 
        "file": "add_addsub_imm.html", 
        "type": "instruction", 
        "aliases": [
            "mov_add_addsub_imm.html"
        ]
    }, 
    {
        "description": "Wait For Interrupt is a hint instruction that indicates that the PE can enter \na low-power state and remain there until a wakeup event occurs. For more \ninformation, see Wait For Interrupt. \n\nAs described in Wait For Interrupt, the execution of a WFI instruction that \nwould otherwise cause entry to a low-power state can be trapped to a higher \nException level. See: \n\n* Traps to EL1 of EL0 execution of WFE and WFI instructions. \n* Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI \n  instructions. \n* Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.", 
        "title": "WFI", 
        "classes": [
            {
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "WFI", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110010000001111111", 
                "title": "WFI"
            }
        ], 
        "file": "wfi.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit \nregister to memory. The address that is used for the store is calculated from \na base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "STTRH", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STTRH  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01111000000xxxxxxxxx10xxxxxxxxxx", 
                "title": "STTRH"
            }
        ], 
        "file": "sttrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed integer Convert to Floating-point (scalar). This instruction converts \nthe signed integer value in the general-purpose source register to a \nfloating-point value using the rounding mode that is specified by the FPCR, \nand writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SCVTF (scalar, integer)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "SCVTF  <Hd>, <Wn>", 
                        "title": "32-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "SCVTF  <Sd>, <Wn>", 
                        "title": "32-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "SCVTF  <Dd>, <Wn>", 
                        "title": "32-bit to double-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "SCVTF  <Hd>, <Xn>", 
                        "title": "64-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "SCVTF  <Sd>, <Xn>", 
                        "title": "64-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "SCVTF  <Dd>, <Xn>", 
                        "title": "64-bit to double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx100010000000xxxxxxxxxx", 
                "title": "SCVTF (scalar, integer)"
            }
        ], 
        "file": "scvtf_float_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Return from subroutine, with pointer authentication. This instruction \nauthenticates the address that is held in LR, using SP as the modifier and the \nspecified key, branches to the authenticated address, with a hint that this \ninstruction is a subroutine return. \n\nKey A is used for RETAA, and key B is used for RETAB. \n\nIf the authentication passes, the PE continues execution at the target of the \nbranch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to LR.", 
        "title": "RETAA, RETAB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Z": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "unallocated": null, 
                "mask": "110101100101111100001x1111111111", 
                "encodings": [
                    {
                        "bitdiff": "(M == 0)", 
                        "arch": null, 
                        "asm": "RETAA", 
                        "title": "RETAA"
                    }, 
                    {
                        "bitdiff": "(M == 1)", 
                        "arch": null, 
                        "asm": "RETAB", 
                        "title": "RETAB"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "reta.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Halving Add. This instruction adds corresponding signed integer values \nfrom the two source SIMD&FP registers, shifts each result right one bit, \nplaces the results into a vector, and writes the vector to the destination \nSIMD&FP register. \n\nThe results are truncated. For rounded results, see SRHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SHADD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx000001xxxxxxxxxx", 
                "title": "SHADD"
            }
        ], 
        "file": "shadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Hypervisor Call causes an exception to EL2. Non-secure software executing at \nEL1 can use this instruction to call the hypervisor to request a service. \n\nThe HVC instruction is undefined: \n\n* At EL0, and Secure EL1. \n* When SCR_EL3.HCE is set to 0. \nOn executing an HVC instruction, the PE records the exception as a Hypervisor \nCall exception in ESR_ELx, using the EC value 0x16, and the value of the \nimmediate argument.", 
        "title": "HVC", 
        "classes": [
            {
                "fields": {
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "HVC  #<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100000xxxxxxxxxxxxxxxx00010", 
                "title": "HVC"
            }
        ], 
        "file": "hvc.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Send Event Local is a hint instruction that causes an event to be signaled \nlocally without requiring the event to be signaled to other PEs in the \nmultiprocessor system. It can prime a wait-loop which starts with a WFE \ninstruction.", 
        "title": "SEVL", 
        "classes": [
            {
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SEVL", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110010000010111111", 
                "title": "SEVL"
            }
        ], 
        "file": "sevl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add Pair of elements (scalar). This instruction adds two vector elements in \nthe source SIMD&FP register and writes the scalar result into the destination \nSIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ADDP (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADDP  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110xx110001101110xxxxxxxxxx", 
                "title": "ADDP (scalar)"
            }
        ], 
        "file": "addp_advsimd_pair.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store-Release Register Halfword stores a halfword from a 32-bit register to a \nmemory location. The instruction also has memory ordering semantics as \ndescribed in Load-Acquire, Store-Release. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "STLRH", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STLRH  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001000100xxxxx1xxxxxxxxxxxxxxx", 
                "title": "STLRH"
            }
        ], 
        "file": "stlrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add (shifted register), setting flags, adds a register value and an \noptionally-shifted register value, and writes the result to the destination \nregister. It updates the condition flags based on the result. \n\nThis instruction is used by the alias CMN (shifted register).", 
        "title": "ADDS (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101011xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADDS (shifted register)"
            }
        ], 
        "file": "adds_addsub_shift.html", 
        "type": "instruction", 
        "aliases": [
            "cmn_adds_addsub_shift.html"
        ]
    }, 
    {
        "description": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends \nit to either 32 bits or 64 bits, and writes the result to a register. The \naddress that is used for the load is calculated from a base register and an \nimmediate offset. For information about memory accesses, see Load/Store \naddressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "LDRSB (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110001x0xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDRSB  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDRSB  <Xt>, [<Xn|SP>], #<simm>", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110001x0xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDRSB  <Xt>, [<Xn|SP>, #<simm>]!", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110011xxxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldrsb_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point signaling Compare (scalar). This instruction compares the two \nSIMD&FP source register values, or the first SIMD&FP source register value and \nzero. It writes the result to the PSTATE.{N, Z, C, V} flags. \n\nIf either operand is any type of NaN, or if either operand is a signaling NaN, \nthe instruction raises an Invalid Operation exception. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCMPE", 
        "classes": [
            {
                "fields": {
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "opc": {
                        "lo": 3, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11 && opc == 10)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCMPE  <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 11 && Rm == (00000) && opc == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCMPE  <Hn>, #0.0", 
                        "title": "Half-precision, zero"
                    }, 
                    {
                        "bitdiff": "(type == 00 && opc == 10)", 
                        "arch": null, 
                        "asm": "FCMPE  <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00 && Rm == (00000) && opc == 11)", 
                        "arch": null, 
                        "asm": "FCMPE  <Sn>, #0.0", 
                        "title": "Single-precision, zero"
                    }, 
                    {
                        "bitdiff": "(type == 01 && opc == 10)", 
                        "arch": null, 
                        "asm": "FCMPE  <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01 && Rm == (00000) && opc == 11)", 
                        "arch": null, 
                        "asm": "FCMPE  <Dn>, #0.0", 
                        "title": "Double-precision, zero"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx001000xxxxx1x000", 
                "title": "FCMPE"
            }
        ], 
        "file": "fcmpe_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte \nfrom memory, adds the value held in a register to it, and stores the result \nback to memory. \n\n* STADDB has no memory ordering semantics. \n* STADDLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDADDB, LDADDAB, LDADDALB, LDADDLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDADDB, LDADDAB, LDADDALB, LDADDLB. \n* The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational \n  pseudocode for this instruction.", 
        "title": "STADDB, STADDLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx000000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STADDB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STADDLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "staddb_ldaddb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "System instruction with result. For more information, see Op0 equals 0b01, \ncache maintenance, TLB maintenance, and address translation instructions for \nthe encodings of System instructions.", 
        "title": "SYSL", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101010100101xxxxxxxxxxxxxxxxxxx", 
                "title": "SYSL"
            }
        ], 
        "file": "sysl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Negate (shifted register) negates an optionally-shifted register value, and \nwrites the result to the destination register. \n\nThis is an alias of SUB (shifted register). This means: \n\n* The encodings in this description are named to match the encodings of SUB \n  (shifted register). \n* The description of SUB (shifted register) gives the operational pseudocode \n  for this instruction.", 
        "title": "NEG (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "NEG  <Wd>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "NEG  <Xd>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1001011xx0xxxxxxxxxxx11111xxxxx", 
                "title": "NEG (shifted register)"
            }
        ], 
        "file": "neg_sub_addsub_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitfield Move copies any number of low-order bits from a source register into \nthe same number of adjacent bits at any position in the destination register, \nleaving other bits unchanged. \n\nThis instruction is used by the aliases BFC, BFI, and BFXIL.", 
        "title": "BFM", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "BFM  <Wd>, <Wn>, #<immr>, #<imms>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "BFM  <Xd>, <Xn>, #<immr>, #<imms>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x01100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "BFM"
            }
        ], 
        "file": "bfm.html", 
        "type": "instruction", 
        "aliases": [
            "bfc_bfm.html", 
            "bfi_bfm.html", 
            "bfxil_bfm.html"
        ]
    }, 
    {
        "description": "Floating-point Round to Integral, using current rounding mode (vector). This \ninstruction rounds a vector of floating-point values in the SIMD&FP source \nregister to integral floating-point values of the same size using the rounding \nmode that is determined by the FPCR, and writes the result to the SIMD&FP \ndestination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRINTI (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTI  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTI  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frinti_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitfield extract and insert at low end copies any number of low-order bits \nfrom a source register into the same number of adjacent bits at the low end in \nthe destination register, leaving other bits unchanged. \n\nThis is an alias of BFM. This means: \n\n* The encodings in this description are named to match the encodings of BFM. \n* The description of BFM gives the operational pseudocode for this \n  instruction.", 
        "title": "BFXIL", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "BFXIL  <Wd>, <Wn>, #<lsb>, #<width>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "BFXIL  <Xd>, <Xn>, #<lsb>, #<width>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x01100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "BFXIL"
            }
        ], 
        "file": "bfxil_bfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers \nand returns a 128-bit result in the destination SIMD&FP register. The result \nis obtained by a three-way exclusive OR of the elements within the input \nvectors with some fixed rotations, see the Operation pseudocode for more \ninformation. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM3PARTW1", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110011xxxxx110000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm3partw1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA1 fixed rotate.", 
        "title": "SHA1H", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA1H  <Sd>, <Sn>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0101111000101000000010xxxxxxxxxx", 
                "title": "SHA1H"
            }
        ], 
        "file": "sha1h_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP \nregister from memory. The address that is used for the load is calculated from \na base register value and an optional immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "LDUR (SIMD&FP)", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDUR  <Bt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDUR  <Ht>, [<Xn|SP>{, #<simm>}]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDUR  <St>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDUR  <Dt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 11)", 
                        "arch": null, 
                        "asm": "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "xx111100x10xxxxxxxxx00xxxxxxxxxx", 
                "title": "LDUR (SIMD&FP)"
            }
        ], 
        "file": "ldur_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load one single-element structure and Replicate to all lanes (of one \nregister). This instruction loads a single-element structure from memory and \nreplicates the structure to all the lanes of the SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD1R", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101010000001100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LD1R  { <Vt>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101110xxxxx1100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "LD1R  { <Vt>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld1r_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise inclusive OR (vector, register). This instruction performs a bitwise \nOR between the two source SIMD&FP registers, and writes the result to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias MOV (vector).", 
        "title": "ORR (vector, register)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110101xxxxx000111xxxxxxxxxx", 
                "title": "ORR (vector, register)"
            }
        ], 
        "file": "orr_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": [
            "mov_orr_advsimd_reg.html"
        ]
    }, 
    {
        "description": "Floating-point Round to Integral, to nearest with ties to even (vector). This \ninstruction rounds a vector of floating-point values in the SIMD&FP source \nregister to integral floating-point values of the same size using the Round to \nNearest rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRINTN (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111001111001100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTN  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x100001100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTN  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frintn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding toward Minus infinity \n(vector). This instruction converts a scalar or each element in a vector from \na floating-point value to a signed integer value using the Round towards Minus \nInfinity rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTMS (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111001111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMS  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111100x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMS  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111001111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtms_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Add to accumulator (vector). This instruction \nmultiplies corresponding floating-point values in the vectors in the two \nsource SIMD&FP registers, adds the product to the corresponding vector element \nof the destination SIMD&FP register, and writes the result to the destination \nSIMD&FP register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMLA (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "a": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110010xxxxx000011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx110011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmla_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies \nthe values of the first two SIMD&FP source registers, negates the product, \nadds that to the value of the third SIMD&FP source register, and writes the \nresult to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMSUB", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "o1": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMSUB  <Hd>, <Hn>, <Hm>, <Ha>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMSUB  <Sd>, <Sn>, <Sm>, <Sa>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMSUB  <Dd>, <Dn>, <Dm>, <Da>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011111xx0xxxxx1xxxxxxxxxxxxxxx", 
                "title": "FMSUB"
            }
        ], 
        "file": "fmsub_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare unsigned Higher (vector). This instruction compares each vector \nelement in the first source SIMD&FP register with the corresponding vector \nelement in the second source SIMD&FP register and if the first unsigned \ninteger value is greater than the second unsigned integer value sets every bit \nof the corresponding vector element in the destination SIMD&FP register to \none, otherwise sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMHI (register)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMHI  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmhi_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Pointer Authentication Code for Data address, using key A. This instruction \ncomputes and inserts a pointer authentication code for a data address, using a \nmodifier and key A. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACDA. \n* The value zero, for PACDZA.", 
        "title": "PACDA, PACDZA", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "PACDA  <Xd>, <Xn|SP>", 
                        "title": "PACDA"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "PACDZA  <Xd>", 
                        "title": "PACDZA"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "pacda.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Byte (unscaled) calculates an address from a base \nregister and an immediate offset, loads a signed byte from memory, \nsign-extends it, and writes it to a register. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "LDURSB", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "001110001x0xxxxxxxxx00xxxxxxxxxx", 
                "title": "LDURSB"
            }
        ], 
        "file": "ldursb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Debug Change PE State to EL1, when executed in Debug state: \n\n* If executed at EL0 changes the current Exception level and SP to EL1 using \n  SP_EL1. \n* Otherwise, if executed at ELx, selects SP_ELx. \nThe target exception level of a DCPS1 instruction is: \n\n* EL1 if the instruction is executed at EL0. \n* Otherwise, the Exception level at which the instruction is executed. \nWhen the target Exception level of a DCPS1 instruction is ELx, on executing \nthis instruction: \n\n* ELR_ELx becomes unknown. \n* SPSR_ELx becomes unknown. \n* ESR_ELx becomes unknown. \n* DLR_EL0 and DSPSR_EL0 become unknown. \n* The endianness is set according to SCTLR_ELx.EE. \nThis instruction is undefined at EL0 in Non-secure state if EL2 is implemented \nand HCR_EL2.TGE == 1. \n\nThis instruction is always undefined in Non-debug state. \n\nFor more information on the operation of the DCPSn instructions, see DCPS.", 
        "title": "DCPS1", 
        "classes": [
            {
                "fields": {
                    "LL": {
                        "lo": 0, 
                        "hi": 1, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DCPS1  {#<imm>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100101xxxxxxxxxxxxxxxx00001", 
                "title": "DCPS1"
            }
        ], 
        "file": "dcps1.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Insert vector element from another vector element. This instruction copies the \nvector element of the source SIMD&FP register to the specified vector element \nof the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP \nregister without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias MOV (element).", 
        "title": "INS (element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm4": {
                        "lo": 11, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01101110000xxxxx0xxxx1xxxxxxxxxx", 
                "title": "INS (element)"
            }
        ], 
        "file": "ins_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare bitwise Equal (vector). This instruction compares each vector element \nfrom the first source SIMD&FP register with the corresponding vector element \nfrom the second source SIMD&FP register, and if the comparison is equal sets \nevery bit of the corresponding vector element in the destination SIMD&FP \nregister to one, otherwise sets every bit of the corresponding vector element \nin the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMEQ (register)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMEQ  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmeq_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire Register Byte derives an address from a base register value, \nloads a byte from memory, zero-extends it and writes it to a register. The \ninstruction also has memory ordering semantics as described in Load-Acquire, \nStore-Release. For information about memory accesses, see Load/Store \naddressing modes. \n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for \nsoftware to observe the presence of the acquire semantic other than its effect \non the arrival at endpoints.", 
        "title": "LDARB", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDARB  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00001000110xxxxx1xxxxxxxxxxxxxxx", 
                "title": "LDARB"
            }
        ], 
        "file": "ldarb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum (scalar). This instruction compares the first and \nsecond source SIMD&FP register values, and writes the smaller of the two \nfloating-point values to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMIN (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMIN  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMIN  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMIN  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx010110xxxxxxxxxx", 
                "title": "FMIN (scalar)"
            }
        ], 
        "file": "fmin_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Bitfield Extract extracts any number of adjacent bits at any position \nfrom a register, zero-extends them to the size of the register, and writes the \nresult to the destination register. \n\nThis is an alias of UBFM. This means: \n\n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "UBFX", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "UBFX  <Wd>, <Wn>, #<lsb>, #<width>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "UBFX  <Xd>, <Xn>, #<lsb>, #<width>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "UBFX"
            }
        ], 
        "file": "ubfx_ubfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum (vector). This instruction compares corresponding \nvector elements in the two source SIMD&FP registers, places the larger of each \nof the two floating-point values into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAX (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110010xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx111101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmax_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed maximum on word or doubleword in memory atomically loads a \n32-bit word or 64-bit doubleword from memory, compares it against the value \nheld in a register, and stores the larger value back to memory, treating the \nvalues as signed numbers. The value initially loaded from memory is returned \nin the destination register. \n\n* If the destination register is not one of WZR or XZR, LDSMAXA and LDSMAXAL \n  load from memory with acquire semantics. \n* LDSMAXL and LDSMAXAL store to memory with release semantics. \n* LDSMAX has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMAX, STSMAXL.", 
        "title": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx010000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAX  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMAX"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAXA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMAXA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMAXAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMAXL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAX  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMAX"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAXA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMAXA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMAXAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMAXL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldsmax.html", 
        "type": "instruction", 
        "aliases": [
            "stsmax_ldsmax.html"
        ]
    }, 
    {
        "description": "Subtract with Carry subtracts a register value and the value of NOT (Carry \nflag) from a register value, and writes the result to the destination \nregister. \n\nThis instruction is used by the alias NGC.", 
        "title": "SBC", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SBC  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SBC  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1011010000xxxxx000000xxxxxxxxxx", 
                "title": "SBC"
            }
        ], 
        "file": "sbc.html", 
        "type": "instruction", 
        "aliases": [
            "ngc_sbc.html"
        ]
    }, 
    {
        "description": "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads \na pair of SIMD&FP registers from memory, issuing a hint to the memory system \nthat the access is non-temporal. The address that is used for the load is \ncalculated from a base register value and an optional immediate offset. \n\nFor information about non-temporal pair instructions, see Load/Store SIMD and \nFloating-point Non-temporal pair. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "LDNP (SIMD&FP)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "LDNP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "xx10110001xxxxxxxxxxxxxxxxxxxxxx", 
                "title": "LDNP (SIMD&FP)"
            }
        ], 
        "file": "ldnp_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed extend Long. This instruction duplicates each vector element in the \nlower or upper half of the source SIMD&FP register into a vector, and writes \nthe vector to the destination SIMD&FP register. The destination vector \nelements are twice as long as the source vector elements. All the values in \nthis instruction are signed integer values. \n\nThe SXTL instruction extracts the source vector from the lower half of the \nsource register, while the SXTL2 instruction extracts the source vector from \nthe upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of SSHLL, SSHLL2. This means: \n\n* The encodings in this description are named to match the encodings of SSHLL, \n  SSHLL2. \n* The description of SSHLL, SSHLL2 gives the operational pseudocode for this \n  instruction.", 
        "title": "SXTL, SXTL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxx000101001xxxxxxxxxx", 
                "title": "SXTL, SXTL2"
            }
        ], 
        "file": "sxtl_sshll_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit set on halfword in memory, without return, atomically loads a \n16-bit halfword from memory, performs a bitwise OR with the value held in a \nregister on it, and stores the result back to memory. \n\n* STSETH has no memory ordering semantics. \n* STSETLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSETH, LDSETAH, LDSETALH, LDSETLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSETH, LDSETAH, LDSETALH, LDSETLH. \n* The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational \n  pseudocode for this instruction.", 
        "title": "STSETH, STSETLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx001100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STSETH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STSETLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stseth_ldseth.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to \neven (vector). This instruction converts a scalar or each element in a vector \nfrom a floating-point value to an unsigned integer value using the Round to \nNearest rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTNU (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111001111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNU  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNU  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111001111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtnu_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Exception Return using the ELR and SPSR for the current Exception level. When \nexecuted, the PE restores PSTATE from the SPSR, and branches to the address \nheld in the ELR. \n\nThe PE checks the SPSR for the current Exception level for an illegal return \nevent. See Illegal return events from AArch64 state. \n\nERET is undefined at EL0.", 
        "title": "ERET", 
        "classes": [
            {
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op4": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "00000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ERET", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010110100111110000001111100000", 
                "title": "ERET"
            }
        ], 
        "file": "eret.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Set Mask sets all bits of the destination register to 1 if the \ncondition is TRUE, and otherwise sets all bits to 0. \n\nThis is an alias of CSINV. This means: \n\n* The encodings in this description are named to match the encodings of CSINV. \n* The description of CSINV gives the operational pseudocode for this \n  instruction.", 
        "title": "CSETM", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "!=", 
                        "value": "111x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CSETM  <Wd>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CSETM  <Xd>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"
                ], 
                "mask": "x101101010011111xxxx0011111xxxxx", 
                "title": "CSETM"
            }
        ], 
        "file": "csetm_csinv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point minimum (vector). This instruction compares corresponding \nelements in the vectors in the two source SIMD&FP registers, places the \nsmaller of each of the two floating-point values into a vector, and writes the \nvector to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMIN (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110110xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x1xxxxx111101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmin_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned saturating Rounding Shift Left (register). This instruction takes \neach vector element of the first source SIMD&FP register, shifts the vector \nelement by a value from the least significant byte of the corresponding vector \nelement of the second source SIMD&FP register, places the results into a \nvector, and writes the vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it \nis a right shift. The results are rounded. For truncated results, see UQSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQRSHL", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx010111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQRSHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx010111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqrshl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Subtract Wide. This instruction subtracts each vector element in the \nlower or upper half of the second source SIMD&FP register from the \ncorresponding vector element in the first source SIMD&FP register, places the \nresult in a vector, and writes the vector to the SIMD&FP destination register. \nAll the values in this instruction are signed integer values. \n\nThe SSUBW instruction extracts the second source vector from the lower half of \nthe second source register, while the SSUBW2 instruction extracts the second \nsource vector from the upper half of the second source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SSUBW, SSUBW2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx001100xxxxxxxxxx", 
                "title": "SSUBW, SSUBW2"
            }
        ], 
        "file": "ssubw_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Wait For Event is a hint instruction that indicates that the PE can enter a \nlow-power state and remain there until a wakeup event occurs. Wakeup events \ninclude the event signaled as a result of executing the SEV instruction on any \nPE in the multiprocessor system. For more information, see Wait For Event \nmechanism and Send event. \n\nAs described in Wait For Event mechanism and Send event, the execution of a \nWFE instruction that would otherwise cause entry to a low-power state can be \ntrapped to a higher Exception level. See: \n\n* Traps to EL1 of EL0 execution of WFE and WFI instructions. \n* Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI \n  instructions. \n* Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.", 
        "title": "WFE", 
        "classes": [
            {
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "WFE", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110010000001011111", 
                "title": "WFE"
            }
        ], 
        "file": "wfe.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a \nregister value and an optionally-shifted register value, and writes the result \nto the destination register.", 
        "title": "EOR (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1001010xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "EOR (shifted register)"
            }
        ], 
        "file": "eor_log_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Shift Right Narrow (immediate). This instruction reads each unsigned integer \nvalue from the source SIMD&FP register, right shifts each result by an \nimmediate value, puts the final result into a vector, and writes the vector to \nthe lower or upper half of the destination SIMD&FP register. The destination \nvector elements are half as long as the source vector elements. The results \nare truncated. For rounded results, see RSHRN. \n\nThe RSHRN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the RSHRN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SHRN, SHRN2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx100001xxxxxxxxxx", 
                "title": "SHRN, SHRN2"
            }
        ], 
        "file": "shrn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply-Add Long (by element). This instruction \nmultiplies each vector element in the lower or upper half of the first source \nSIMD&FP register by the specified vector element of the second source SIMD&FP \nregister, doubles the results, and accumulates the final results with the \nvector elements of the destination SIMD&FP register. The destination vector \nelements are twice as long as the elements that are multiplied. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLAL instruction extracts vector elements from the lower half of the \nfirst source register, while the SQDMLAL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMLAL, SQDMLAL2 (by element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011111xxxxxxxx0011x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx0011x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmlal_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed minimum on word or doubleword in memory, without return, \natomically loads a 32-bit word or 64-bit doubleword from memory, compares it \nagainst the value held in a register, and stores the smaller value back to \nmemory, treating the values as signed numbers. \n\n* STSMIN has no memory ordering semantics. \n* STSMINL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMIN, LDSMINA, LDSMINAL, LDSMINL. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSMIN, LDSMINA, LDSMINAL, LDSMINL. \n* The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational \n  pseudocode for this instruction.", 
        "title": "STSMIN, STSMINL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx010100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STSMIN  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDSMIN alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STSMINL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDSMINL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STSMIN  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDSMIN alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STSMINL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDSMINL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stsmin_ldsmin.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Less than or Equal to zero (vector). This instruction \nreads each floating-point value in the source SIMD&FP register and if the \nvalue is less than or equal to zero sets every bit of the corresponding vector \nelement in the destination SIMD&FP register to one, otherwise sets every bit \nof the corresponding vector element in the destination SIMD&FP register to \nzero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMLE (zero)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111011111000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLE  <Hd>, <Hn>, #0.0", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x100000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLE  <V><d>, <V><n>, #0.0", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmle_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Accumulate of Unsigned value. This instruction adds the \nunsigned integer values of the vector elements in the source SIMD&FP register \nto corresponding signed integer values of the vector elements in the \ndestination SIMD&FP register, and writes the resulting signed integer values \nto the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SUQADD", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx100000001110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SUQADD  <V><d>, <V><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx100000001110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SUQADD  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "suqadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load single 3-element structure to one lane of three registers). This \ninstruction loads a 3-element structure from memory and writes the result to \nthe corresponding elements of the three SIMD&FP registers without affecting \nthe other bits of the registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD3 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110101000000xx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 001)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101110xxxxxxx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld3_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Rotate right (immediate) provides the value of the contents of a register \nrotated by a variable number of bits. The bits that are rotated off the right \nend are inserted into the vacated bit positions on the left. \n\nThis is an alias of EXTR. This means: \n\n* The encodings in this description are named to match the encodings of EXTR. \n* The description of EXTR gives the operational pseudocode for this \n  instruction.", 
        "title": "ROR (immediate)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0 && imms == 0xxxxx)", 
                        "arch": null, 
                        "asm": "ROR  <Wd>, <Ws>, #<shift>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "ROR  <Xd>, <Xs>, #<shift>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100111x0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ROR (immediate)"
            }
        ], 
        "file": "ror_extr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to higher precision Long (vector). This instruction \nreads each element in a vector in the SIMD&FP source register, converts each \nvalue to double the precision of the source element using the rounding mode \nthat is determined by the FPCR, and writes each result to the equivalent \nelement of the vector in the SIMD&FP destination register. \n\nWhere the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2 \nvariant operates on the elements in the top 64 bits of the source register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTL, FCVTL2", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x0011100x100001011110xxxxxxxxxx", 
                "title": "FCVTL, FCVTL2"
            }
        ], 
        "file": "fcvtl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply High multiplies two 64-bit register values, and writes \nbits[127:64] of the 128-bit result to the 64-bit destination register.", 
        "title": "SMULH", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMULH  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011010xxxxx0xxxxxxxxxxxxxxx", 
                "title": "SMULH"
            }
        ], 
        "file": "smulh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned saturating Add. This instruction adds the values of corresponding \nelements of the two source SIMD&FP registers, places the results into a \nvector, and writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQADD", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx000011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQADD  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx000011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA1 hash update (parity).", 
        "title": "SHA1P", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA1P  <Qd>, <Sn>, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx000100xxxxxxxxxx", 
                "title": "SHA1P"
            }
        ], 
        "file": "sha1p_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Add Long (vector). This instruction adds each vector element in the \nlower or upper half of the first source SIMD&FP register to the corresponding \nvector element of the second source SIMD&FP register, places the result into a \nvector, and writes the vector to the destination SIMD&FP register. The \ndestination vector elements are twice as long as the source vector elements. \nAll the values in this instruction are unsigned integer values. \n\nThe UADDL instruction extracts each source vector from the lower half of each \nsource register, while the UADDL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UADDL, UADDL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx000000xxxxxxxxxx", 
                "title": "UADDL, UADDL2"
            }
        ], 
        "file": "uaddl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire RCpc Register Halfword derives an address from a base register \nvalue, loads a halfword from the derived address in memory, zero-extends it \nand writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire, \nStore-Release, except that: \n\n* There is no ordering requirement, separate from the requirements of a \n  Load-Acquirepc or a Store-Release, created by having a Store-Release \n  followed by a Load-Acquirepc instruction. \n* The reading of a value written by a Store-Release by a Load-Acquirepc \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed. \nThis difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "LDAPRH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "(1)": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000101xxxxx110000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDAPRH  <Wt>, [<Xn|SP> {,#0}]", 
                        "title": "Integer"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "ldaprh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Byte (unscaled) calculates an address from a base register and \nan immediate offset, loads a byte from memory, zero-extends it, and writes it \nto a register. For information about memory accesses, see Load/Store \naddressing modes.", 
        "title": "LDURB", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDURB  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00111000010xxxxxxxxx00xxxxxxxxxx", 
                "title": "LDURB"
            }
        ], 
        "file": "ldurb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Count Leading Sign bits (vector). This instruction counts the number of \nconsecutive bits following the most significant bit that are the same as the \nmost significant bit in each vector element in the source SIMD&FP register, \nplaces the result into a vector, and writes the vector to the destination \nSIMD&FP register. The count does not include the most significant bit itself. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "CLS (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CLS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx100000010010xxxxxxxxxx", 
                "title": "CLS (vector)"
            }
        ], 
        "file": "cls_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector). \nThis instruction converts a scalar or each element in a vector from \nfloating-point to fixed-point unsigned integer using the Round towards Zero \nrounding mode, and writes the result to the general-purpose destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "FCVTZU (vector, fixed-point)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZU  <V><d>, <V><n>, #<fbits>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtzu_advsimd_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Absolute difference and Accumulate. This instruction subtracts the \nelements of the vector of the second source SIMD&FP register from the \ncorresponding elements of the first source SIMD&FP register, and accumulates \nthe absolute values of the results into the elements of the vector of the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UABA", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx011111xxxxxxxxxx", 
                "title": "UABA"
            }
        ], 
        "file": "uaba_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Minimum (vector). This instruction compares corresponding elements in \nthe vectors in the two source SIMD&FP registers, places the smaller of each of \nthe two signed integer values into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMIN", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx011011xxxxxxxxxx", 
                "title": "SMIN"
            }
        ], 
        "file": "smin_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA512 Hash update part 1 takes the values from the three 128-bit source \nSIMD&FP registers and produces a 128-bit output value that combines the sigma1 \nand chi functions of two iterations of the SHA512 computation. It returns this \nvalue to the destination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "SHA512H", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110011xxxxx100000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA512H  <Qd>, <Qn>, <Vm>.2D", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sha512h_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Maximum (vector). This instruction compares corresponding elements in \nthe vectors in the two source SIMD&FP registers, places the larger of each \npair of signed integer values into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMAX", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx011001xxxxxxxxxx", 
                "title": "SMAX"
            }
        ], 
        "file": "smax_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from \nmemory, performs a bitwise AND with the complement of the value held in a \nregister on it, and stores the result back to memory. The value initially \nloaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDCLRAH and LDCLRALH load from \n  memory with acquire semantics. \n* LDCLRLH and LDCLRALH store to memory with release semantics. \n* LDCLRH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STCLRH, STCLRLH.", 
        "title": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx000100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLRH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDCLRLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldclrh.html", 
        "type": "instruction", 
        "aliases": [
            "stclrh_ldclrh.html"
        ]
    }, 
    {
        "description": "Store Register (immediate) stores a word or a doubleword from a register to \nmemory. The address that is used for the store is calculated from a base \nregister and an immediate offset. For information about memory accesses, see \nLoad/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "STR (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000000xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STR  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STR  <Xt>, [<Xn|SP>], #<simm>", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000000xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STR  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STR  <Xt>, [<Xn|SP>, #<simm>]!", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x11100100xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STR  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STR  <Xt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "str_imm_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Absolute value (vector). This instruction calculates the absolute value of \neach vector element in the source SIMD&FP register, puts the result into a \nvector, and writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "ABS", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx100000101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ABS  <V><d>, <V><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx100000101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ABS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "abs_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral exact, using current rounding mode (scalar). \nThis instruction rounds a floating-point value in the SIMD&FP source register \nto an integral floating-point value of the same size using the rounding mode \nthat is determined by the FPCR, and writes the result to the SIMD&FP \ndestination register. \n\nAn Inexact exception is raised when the result value is not numerically equal \nto the input value. A zero input gives a zero result with the same sign, an \ninfinite input gives an infinite result with the same sign, and a NaN is \npropagated as for normal arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FRINTX (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "rmode": {
                        "lo": 15, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "110"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FRINTX  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FRINTX  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FRINTX  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100111010000xxxxxxxxxx", 
                "title": "FRINTX (scalar)"
            }
        ], 
        "file": "frintx_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "No Operation does nothing, other than advance the value of the program counter \nby 4. This instruction can be used for instruction alignment purposes. \n\nThe timing effects of including a NOP instruction in a program are not \nguaranteed. It can increase execution time, leave it unchanged, or even reduce \nit. Therefore, NOP instructions are not suitable for timing loops.", 
        "title": "NOP", 
        "classes": [
            {
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "NOP", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110010000000011111", 
                "title": "NOP"
            }
        ], 
        "file": "nop.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Branch to Register branches unconditionally to an address in a register, with \na hint that this is not a subroutine return.", 
        "title": "BR", 
        "classes": [
            {
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "00000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BR  <Xn>", 
                        "title": "Integer"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101011000011111000000xxxxx00000", 
                "title": "BR"
            }
        ], 
        "file": "br.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword \nfrom memory, performs an exclusive OR with the value held in a register on it, \nand stores the result back to memory. The value initially loaded from memory \nis returned in the destination register. \n\n* If the destination register is not WZR, LDEORAH and LDEORALH load from \n  memory with acquire semantics. \n* LDEORLH and LDEORALH store to memory with release semantics. \n* LDEORH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STEORH, STEORLH.", 
        "title": "LDEORH, LDEORAH, LDEORALH, LDEORLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx001000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEORAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEORH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDEORLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldeorh.html", 
        "type": "instruction", 
        "aliases": [
            "steorh_ldeorh.html"
        ]
    }, 
    {
        "description": "Load Register Signed Halfword (immediate) loads a halfword from memory, \nsign-extends it to 32 bits or 64 bits, and writes the result to a register. \nThe address that is used for the load is calculated from a base register and \nan immediate offset. For information about memory accesses, see Load/Store \naddressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "LDRSH (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110001x0xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDRSH  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDRSH  <Xt>, [<Xn|SP>], #<simm>", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110001x0xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDRSH  <Xt>, [<Xn|SP>, #<simm>]!", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110011xxxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldrsh_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply (vector). This instruction multiplies corresponding elements in the \nvectors of the two source SIMD&FP registers, places the results in a vector, \nand writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MUL (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx100111xxxxxxxxxx", 
                "title": "MUL (vector)"
            }
        ], 
        "file": "mul_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Multiply extended (by element). This instruction multiplies the \nfloating-point values in the vector elements in the first source SIMD&FP \nregister by the specified floating-point value in the second source SIMD&FP \nregister, places the results in a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nIf one value is zero and the other value is infinite, the result is 2.0. In \nthis case, the result is negative if only one of the values is negative, \notherwise the result is positive. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar, \nsingle-precision and double-precision , Vector, half-precision and Vector, \nsingle-precision and double-precision", 
        "title": "FMULX (by element)", 
        "classes": [
            {
                "title": "Scalar, half-precision", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111100xxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <Hd>, <Hn>, <Vm>.H[<index>]", 
                        "title": "Scalar, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111111xxxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector, half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111100xxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", 
                        "title": "Vector, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011111xxxxxxx1001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmulx_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Absolute value (vector). This instruction calculates the \nabsolute value of each vector element in the source SIMD&FP register, writes \nthe result to a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FABS (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FABS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FABS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fabs_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from \nmemory, compares it against the value held in a register, and stores the \nsmaller value back to memory, treating the values as unsigned numbers. The \nvalue initially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDUMINAB and LDUMINALB load from \n  memory with acquire semantics. \n* LDUMINLB and LDUMINALB store to memory with release semantics. \n* LDUMINB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMINB, STUMINLB.", 
        "title": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx011100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMINB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMINLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "lduminb.html", 
        "type": "instruction", 
        "aliases": [
            "stuminb_lduminb.html"
        ]
    }, 
    {
        "description": "Floating-point Complex Multiply Accumulate (by element). \n\nThis instruction operates on complex numbers that are represented in SIMD&FP \nregisters as pairs of elements, with the more significant element holding the \nimaginary part of the number and the less significant element holding the real \npart of the number. Each element holds a floating-point value. It performs the \nfollowing computation on complex numbers from the first source register and \nthe destination register with the specified complex number from the second \nsource register: \n\n* Considering the complex number from the second source register on an Argand \n  diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 \n  degrees. \n* The two elements of the transformed complex number are multiplied by:The \n  real element of the complex number from the first source register, if the \n  transformation was a rotation by 0 or 180 degrees.The imaginary element of \n  the complex number from the first source register, if the transformation was \n  a rotation by 90 or 270 degrees. \n* The complex number resulting from that multiplication is added to the \n  complex number from the destination register. \nThe multiplication and addition operations are performed as a fused \nmultiply-add, without any intermediate rounding. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCMLA (by element)", 
        "classes": [
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "rot": {
                        "lo": 13, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx0xx1x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 01)", 
                        "arch": null, 
                        "asm": "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>", 
                        "title": null
                    }, 
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>", 
                        "title": null
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "fcmla_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum of Pair of elements (scalar). This instruction compares \ntwo vector elements in the source SIMD&FP register and writes the smallest of \nthe floating-point values as a scalar to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMINP (scalar)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111010110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINP  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINP  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fminp_advsimd_pair.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the \nproduct, and writes the result to the 64-bit destination register. \n\nThis is an alias of SMSUBL. This means: \n\n* The encodings in this description are named to match the encodings of \n  SMSUBL. \n* The description of SMSUBL gives the operational pseudocode for this \n  instruction.", 
        "title": "SMNEGL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMNEGL  <Xd>, <Wn>, <Wm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011001xxxxx111111xxxxxxxxxx", 
                "title": "SMNEGL"
            }
        ], 
        "file": "smnegl_smsubl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract (extended register), setting flags, subtracts a sign or zero-extended \nregister value, followed by an optional left shift amount, from a register \nvalue, and writes the result to the destination register. The argument that is \nextended from the <Rm> register can be a byte, halfword, word, or doubleword. \nIt updates the condition flags based on the result. \n\nThis instruction is used by the alias CMP (extended register).", 
        "title": "SUBS (extended register)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm3": {
                        "lo": 10, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101011001xxxxxxxxxxxxxxxxxxxxx", 
                "title": "SUBS (extended register)"
            }
        ], 
        "file": "subs_addsub_ext.html", 
        "type": "instruction", 
        "aliases": [
            "cmp_subs_addsub_ext.html"
        ]
    }, 
    {
        "description": "Load multiple single-element structures to one, two, three, or four registers. \nThis instruction loads multiple single-element structures from memory and \nwrites the result to one, two, three, or four SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD1 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110001000000xx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 0111)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T> }, [<Xn|SP>]", 
                        "title": "One register"
                    }, 
                    {
                        "bitdiff": "(opcode == 1010)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", 
                        "title": "Two registers"
                    }, 
                    {
                        "bitdiff": "(opcode == 0110)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", 
                        "title": "Three registers"
                    }, 
                    {
                        "bitdiff": "(opcode == 0010)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", 
                        "title": "Four registers"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100110xxxxxxx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 0111)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "One register, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 0111)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "One register, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 1010)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Two registers, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 1010)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Two registers, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 0110)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Three registers, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 0110)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Three registers, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 0010)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Four registers, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 0010)", 
                        "arch": null, 
                        "asm": "LD1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Four registers, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld1_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Add Pair of elements (scalar). This instruction adds two \nfloating-point vector elements in the source SIMD&FP register and writes the \nscalar result into the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FADDP (scalar)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111000110000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FADDP  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x110000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FADDP  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "faddp_advsimd_pair.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply-Subtract Long (vector). This instruction multiplies \ncorresponding vector elements in the lower or upper half of the two source \nSIMD&FP registers, and subtracts the results from the vector elements of the \ndestination SIMD&FP register. The destination vector elements are twice as \nlong as the elements that are multiplied. All the values in this instruction \nare unsigned integer values. \n\nThe UMLSL instruction extracts each source vector from the lower half of each \nsource register, while the UMLSL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMLSL, UMLSL2 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx101000xxxxxxxxxx", 
                "title": "UMLSL, UMLSL2 (vector)"
            }
        ], 
        "file": "umlsl_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point quiet Compare (scalar). This instruction compares the two \nSIMD&FP source register values, or the first SIMD&FP source register value and \nzero. It writes the result to the PSTATE.{N, Z, C, V} flags. \n\nIt raises an Invalid Operation exception only if either operand is a signaling \nNaN. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCMP", 
        "classes": [
            {
                "fields": {
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "opc": {
                        "lo": 3, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "0x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11 && opc == 00)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCMP  <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 11 && Rm == (00000) && opc == 01)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCMP  <Hn>, #0.0", 
                        "title": "Half-precision, zero"
                    }, 
                    {
                        "bitdiff": "(type == 00 && opc == 00)", 
                        "arch": null, 
                        "asm": "FCMP  <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00 && Rm == (00000) && opc == 01)", 
                        "arch": null, 
                        "asm": "FCMP  <Sn>, #0.0", 
                        "title": "Single-precision, zero"
                    }, 
                    {
                        "bitdiff": "(type == 01 && opc == 00)", 
                        "arch": null, 
                        "asm": "FCMP  <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01 && Rm == (00000) && opc == 01)", 
                        "arch": null, 
                        "asm": "FCMP  <Dn>, #0.0", 
                        "title": "Double-precision, zero"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx001000xxxxx0x000", 
                "title": "FCMP"
            }
        ], 
        "file": "fcmp_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare signed Greater than (vector). This instruction compares each vector \nelement in the first source SIMD&FP register with the corresponding vector \nelement in the second source SIMD&FP register and if the first signed integer \nvalue is greater than the second signed integer value sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to one, \notherwise sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMGT (register)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGT  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmgt_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register (unscaled) calculates an address from a base register value and \nan immediate offset, and stores a 32-bit word or a 64-bit doubleword to the \ncalculated address, from a register. For information about memory accesses, \nsee Load/Store addressing modes.", 
        "title": "STUR", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STUR  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STUR  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x111000000xxxxxxxxx00xxxxxxxxxx", 
                "title": "STUR"
            }
        ], 
        "file": "stur_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a \nregister.", 
        "title": "REV32", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "REV32  <Xd>, <Xn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101101011000000000010xxxxxxxxxx", 
                "title": "REV32"
            }
        ], 
        "file": "rev32_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares \nit against the value held in a first register. If the comparison is equal, the \nvalue in a second register is written to memory. If the write is performed, \nthe read and write occur atomically such that no other modification of the \nmemory location can take place between the read and write. \n\n* CASAB and CASALB load from memory with acquire semantics. \n* CASLB and CASALB store to memory with release semantics. \n* CASB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors \nassociated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the register which is \ncompared and loaded, that is <Ws>, is restored to the values held in the \nregister before the instruction was executed.", 
        "title": "CASB, CASAB, CASALB, CASLB", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "000010001x1xxxxxx11111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(L == 1 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASAB"
                    }, 
                    {
                        "bitdiff": "(L == 1 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASALB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASALB"
                    }, 
                    {
                        "bitdiff": "(L == 0 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASB"
                    }, 
                    {
                        "bitdiff": "(L == 0 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "CASLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "casb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit \nregister to memory if the PE has exclusive access to the memory address, and \nreturns a status value of 0 if the store was successful, or of 1 if no store \nwas performed. See Synchronization and semaphores. The memory access is \natomic. The instruction also has memory ordering semantics as described in \nLoad-Acquire, Store-Release. For information about memory accesses see \nLoad/Store addressing modes.", 
        "title": "STLXRH", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001000000xxxxx1xxxxxxxxxxxxxxx", 
                "title": "STLXRH"
            }
        ], 
        "file": "stlxrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic add on halfword in memory, without return, atomically loads a 16-bit \nhalfword from memory, adds the value held in a register to it, and stores the \nresult back to memory. \n\n* STADDH has no memory ordering semantics. \n* STADDLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDADDH, LDADDAH, LDADDALH, LDADDLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDADDH, LDADDAH, LDADDALH, LDADDLH. \n* The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational \n  pseudocode for this instruction.", 
        "title": "STADDH, STADDLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx000000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STADDH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STADDLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "staddh_ldaddh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Word (immediate) loads a word from memory, sign-extends \nit to 64 bits, and writes the result to a register. The address that is used \nfor the load is calculated from a base register and an immediate offset. For \ninformation about memory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "LDRSW (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "unallocated": null, 
                "mask": "10111000100xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRSW  <Xt>, [<Xn|SP>], #<simm>", 
                        "title": "Post-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "unallocated": null, 
                "mask": "10111000100xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!", 
                        "title": "Pre-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "unallocated": null, 
                "mask": "1011100110xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "Unsigned offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldrsw_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Shift Left (immediate). This instruction reads each vector \nelement in the source SIMD&FP register, shifts each result by an immediate \nvalue, places the final result in a vector, and writes the vector to the \ndestination SIMD&FP register. The results are truncated. For rounded results, \nsee UQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQSHL (immediate)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx011101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHL  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx011101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqshl_advsimd_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity \n(vector). This instruction converts a scalar or each element in a vector from \na floating-point value to an unsigned integer value using the Round towards \nMinus Infinity rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTMU (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111001111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMU  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMU  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111001111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTMU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtmu_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Bitfield Insert in Zero zeroes the destination register and copies any \nnumber of contiguous bits from a source register into any position in the \ndestination register, sign-extending the most significant bit of the \ntransferred value. \n\nThis is an alias of SBFM. This means: \n\n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "SBFIZ", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "SBFIZ  <Xd>, <Xn>, #<lsb>, #<width>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "SBFIZ"
            }
        ], 
        "file": "sbfiz_sbfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed minimum on word or doubleword in memory atomically loads a \n32-bit word or 64-bit doubleword from memory, compares it against the value \nheld in a register, and stores the smaller value back to memory, treating the \nvalues as signed numbers. The value initially loaded from memory is returned \nin the destination register. \n\n* If the destination register is not one of WZR or XZR, LDSMINA and LDSMINAL \n  load from memory with acquire semantics. \n* LDSMINL and LDSMINAL store to memory with release semantics. \n* LDSMIN has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMIN, STSMINL.", 
        "title": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "101"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx010100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMIN  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMIN"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMINA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMINA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMINAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDSMINL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMIN  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMIN"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMINA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMINA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMINAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDSMINL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldsmin.html", 
        "type": "instruction", 
        "aliases": [
            "stsmin_ldsmin.html"
        ]
    }, 
    {
        "description": "Floating-point Reciprocal Step. This instruction multiplies the corresponding \nfloating-point values in the vectors of the two source SIMD&FP registers, \nsubtracts each of the products from 2.0, places the resulting floating-point \nvalues in a vector, and writes the vector to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FRECPS", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110010xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPS  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111100x1xxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPS  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110010xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frecps_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Clear Exclusive clears the local monitor of the executing PE.", 
        "title": "CLREX", 
        "classes": [
            {
                "fields": {
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CLREX  {#<imm>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110011xxxx01011111", 
                "title": "CLREX"
            }
        ], 
        "file": "clrex.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive \nOR operation between the two source SIMD&FP registers, and places the result \nin the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "EOR (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc2": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110001xxxxx000111xxxxxxxxxx", 
                "title": "EOR (vector)"
            }
        ], 
        "file": "eor_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Rounding Doubling Multiply returning High half (by element). \nThis instruction multiplies each vector element in the first source SIMD&FP \nregister by the specified vector element of the second source SIMD&FP \nregister, doubles the results, places the most significant half of the final \nresults into a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nThe results are rounded. For truncated results, see SQDMULH. \n\nIf any of the results overflows, they are saturated. If saturation occurs, the \ncumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRDMULH (by element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011111xxxxxxxx1101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx1101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqrdmulh_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector \nelement from the destination SIMD&FP register, performs a bitwise OR between \neach result and an immediate constant, places the result into a vector, and \nwrites the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ORR (vector, immediate)", 
        "classes": [
            {
                "fields": {
                    "a": {
                        "lo": 18, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "c": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "b": {
                        "lo": 17, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "e": {
                        "lo": 8, 
                        "hi": 8, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "d": {
                        "lo": 9, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "g": {
                        "lo": 6, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "f": {
                        "lo": 7, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "h": {
                        "lo": 5, 
                        "hi": 5, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "cmode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(cmode == 10x1)", 
                        "arch": null, 
                        "asm": "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(cmode == 0xx1)", 
                        "arch": null, 
                        "asm": "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "32-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x00111100000xxxxxx101xxxxxxxxxx", 
                "title": "ORR (vector, immediate)"
            }
        ], 
        "file": "orr_advsimd_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP \nregisters to memory. The address used for the store is calculated from a base \nregister value and an immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", 
        "title": "STP (SIMD&FP)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx10110010xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STP  <St1>, <St2>, [<Xn|SP>], #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "STP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx10110110xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "STP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Signed offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx10110100xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "STP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "stp_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Branch with Link to Register, with pointer authentication. This instruction \nauthenticates the address in the general-purpose register that is specified by \n<Xn>, using a modifier and the specified key, and calls a subroutine at the \nauthenticated address, setting register X30 to PC+4. \n\nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xm|SP> for BLRAA and BLRAB. \n* The value zero, for BLRAAZ and BLRABZ. \nKey A is used for BLRAA and BLRAAZ, and key B is used for BLRAB and BLRABZ. \n\nIf the authentication passes, the PE continues execution at the target of the \nbranch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to the general-purpose register.", 
        "title": "BLRAA, BLRAAZ, BLRAB, BLRABZ", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "1101011x0011111100001xxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0 && M == 0 && Rm == 11111)", 
                        "arch": null, 
                        "asm": "BLRAAZ  <Xn>", 
                        "title": "Key A, zero modifier"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && M == 0)", 
                        "arch": null, 
                        "asm": "BLRAA  <Xn>, <Xm|SP>", 
                        "title": "Key A, register modifier"
                    }, 
                    {
                        "bitdiff": "(Z == 0 && M == 1 && Rm == 11111)", 
                        "arch": null, 
                        "asm": "BLRABZ  <Xn>", 
                        "title": "Key B, zero modifier"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && M == 1)", 
                        "arch": null, 
                        "asm": "BLRAB  <Xn>, <Xm|SP>", 
                        "title": "Key B, register modifier"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "blra.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar). \nThis instruction converts the floating-point value in the SIMD&FP source \nregister to a 32-bit or 64-bit fixed-point unsigned integer using the Round \ntowards Zero rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped.", 
        "title": "FCVTZU (scalar, fixed-point)", 
        "classes": [
            {
                "fields": {
                    "scale": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZU  <Wd>, <Hn>, #<fbits>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZU  <Xd>, <Hn>, #<fbits>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Wd>, <Sn>, #<fbits>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Xd>, <Sn>, #<fbits>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Wd>, <Dn>, #<fbits>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Xd>, <Dn>, #<fbits>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx011001xxxxxxxxxxxxxxxx", 
                "title": "FCVTZU (scalar, fixed-point)"
            }
        ], 
        "file": "fcvtzu_float_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned maximum on word or doubleword in memory, without return, \natomically loads a 32-bit word or 64-bit doubleword from memory, compares it \nagainst the value held in a register, and stores the larger value back to \nmemory, treating the values as unsigned numbers. \n\n* STUMAX has no memory ordering semantics. \n* STUMAXL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL. \n* The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational \n  pseudocode for this instruction.", 
        "title": "STUMAX, STUMAXL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx011000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STUMAX  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDUMAX alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STUMAXL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDUMAXL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STUMAX  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDUMAX alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STUMAXL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDUMAXL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stumax_ldumax.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP \nregister from memory. The address that is used for the load is calculated from \nthe PC value and an immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "LDR (literal, SIMD&FP)", 
        "classes": [
            {
                "fields": {
                    "imm19": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDR  <St>, <label>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Dt>, <label>", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDR  <Qt>, <label>", 
                        "title": "128-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "xx011100xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "LDR (literal, SIMD&FP)"
            }
        ], 
        "file": "ldr_lit_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Multiply (scalar). This instruction multiplies the \nfloating-point values of the two source SIMD&FP registers, and writes the \nresult to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMUL (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMUL  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMUL  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMUL  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx000010xxxxxxxxxx", 
                "title": "FMUL (scalar)"
            }
        ], 
        "file": "fmul_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Byte (register) calculates an address from a base \nregister value and an offset register value, loads a byte from memory, \nsign-extends it, and writes it to a register. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "LDRSB (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11 && option != 011)", 
                        "arch": null, 
                        "asm": "LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]", 
                        "title": "32-bit with extended register offset"
                    }, 
                    {
                        "bitdiff": "(opc == 11 && option == 011)", 
                        "arch": null, 
                        "asm": "LDRSB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", 
                        "title": "32-bit with shifted register offset"
                    }, 
                    {
                        "bitdiff": "(opc == 10 && option != 011)", 
                        "arch": null, 
                        "asm": "LDRSB  <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]", 
                        "title": "64-bit with extended register offset"
                    }, 
                    {
                        "bitdiff": "(opc == 10 && option == 011)", 
                        "arch": null, 
                        "asm": "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", 
                        "title": "64-bit with shifted register offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "001110001x1xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDRSB (register)"
            }
        ], 
        "file": "ldrsb_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store LORelease Register Halfword stores a halfword from a 32-bit register to \na memory location. The instruction also has memory ordering semantics as \ndescribed in Load LOAcquire, Store LORelease. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "STLLRH", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01001000100xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STLLRH  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stllrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert precision (scalar). This instruction converts the \nfloating-point value in the SIMD&FP source register to the precision for the \ndestination register data type using the rounding mode that is determined by \nthe FPCR and writes the result to the SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVT", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "opc": {
                        "lo": 15, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11 && opc == 00)", 
                        "arch": null, 
                        "asm": "FCVT  <Sd>, <Hn>", 
                        "title": "Half-precision to single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 11 && opc == 01)", 
                        "arch": null, 
                        "asm": "FCVT  <Dd>, <Hn>", 
                        "title": "Half-precision to double-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00 && opc == 11)", 
                        "arch": null, 
                        "asm": "FCVT  <Hd>, <Sn>", 
                        "title": "Single-precision to half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00 && opc == 01)", 
                        "arch": null, 
                        "asm": "FCVT  <Dd>, <Sn>", 
                        "title": "Single-precision to double-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01 && opc == 11)", 
                        "arch": null, 
                        "asm": "FCVT  <Hd>, <Dn>", 
                        "title": "Double-precision to half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01 && opc == 00)", 
                        "arch": null, 
                        "asm": "FCVT  <Sd>, <Dn>", 
                        "title": "Double-precision to single-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx10001xx10000xxxxxxxxxx", 
                "title": "FCVT"
            }
        ], 
        "file": "fcvt_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Word (unprivileged) loads a word from memory, \nsign-extends it to 64 bits, and writes the result to a register. The address \nthat is used for the load is calculated from a base register and an immediate \noffset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "LDTRSW", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "10111000100xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDTRSW"
            }
        ], 
        "file": "ldtrsw.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise NOT writes the bitwise inverse of a register value to the destination \nregister. \n\nThis is an alias of ORN (shifted register). This means: \n\n* The encodings in this description are named to match the encodings of ORN \n  (shifted register). \n* The description of ORN (shifted register) gives the operational pseudocode \n  for this instruction.", 
        "title": "MVN", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MVN  <Wd>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MVN  <Xd>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101010xx1xxxxxxxxxxx11111xxxxx", 
                "title": "MVN"
            }
        ], 
        "file": "mvn_orn_log_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load multiple 4-element structures to four registers. This instruction loads \nmultiple 4-element structures from memory and writes the result to the four \nSIMD&FP registers, with de-interleaving. \n\nFor an example of de-interleaving, see LD3 (multiple structures). \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD4 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100010000000000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0000"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100110xxxxx0000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld4_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Absolute Difference Long. This instruction subtracts the vector \nelements in the lower or upper half of the second source SIMD&FP register from \nthe corresponding vector elements of the first source SIMD&FP register, places \nthe absolute value of the result into a vector, and writes the vector to the \ndestination SIMD&FP register. The destination vector elements are twice as \nlong as the source vector elements. All the values in this instruction are \nunsigned integer values. \n\nThe UABDL instruction extracts each source vector from the lower half of each \nsource register, while the UABDL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UABDL, UABDL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx011100xxxxxxxxxx", 
                "title": "UABDL, UABDL2"
            }
        ], 
        "file": "uabdl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, to nearest with ties to even (scalar). This \ninstruction rounds a floating-point value in the SIMD&FP source register to an \nintegral floating-point value of the same size using the Round to Nearest \nrounding mode, and writes the result to the SIMD&FP destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FRINTN (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "rmode": {
                        "lo": 15, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FRINTN  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FRINTN  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FRINTN  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100100010000xxxxxxxxxx", 
                "title": "FRINTN (scalar)"
            }
        ], 
        "file": "frintn_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Square Root (vector). This instruction calculates the square \nroot for each vector element in the source SIMD&FP register, places the result \nin a vector, and writes the vector to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FSQRT (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111001111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FSQRT  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100001111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FSQRT  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fsqrt_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Test bits (immediate), setting the condition flags and discarding the result: \nRn AND imm. \n\nThis is an alias of ANDS (immediate). This means: \n\n* The encodings in this description are named to match the encodings of ANDS \n  (immediate). \n* The description of ANDS (immediate) gives the operational pseudocode for \n  this instruction.", 
        "title": "TST (immediate)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "TST  <Wn>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "TST  <Xn>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x11100100xxxxxxxxxxxxxxxxxx11111", 
                "title": "TST (immediate)"
            }
        ], 
        "file": "tst_ands_log_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to \neven (scalar). This instruction converts the floating-point value in the \nSIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round \nto Nearest rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTNU (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTNU  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTNU  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTNU  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTNU  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTNU  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTNU  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx100001000000xxxxxxxxxx", 
                "title": "FCVTNU (scalar)"
            }
        ], 
        "file": "fcvtnu_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire Exclusive Register Byte derives an address from a base register \nvalue, loads a byte from memory, zero-extends it and writes it to a register. \nThe memory access is atomic. The PE marks the physical address being accessed \nas an exclusive access. This exclusive access mark is checked by Store \nExclusive instructions. See Synchronization and semaphores. The instruction \nalso has memory ordering semantics as described in Load-Acquire, \nStore-Release. For information about memory accesses see Load/Store addressing \nmodes.", 
        "title": "LDAXRB", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDAXRB  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00001000010xxxxx1xxxxxxxxxxxxxxx", 
                "title": "LDAXRB"
            }
        ], 
        "file": "ldaxrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register \nvalue and the complement of an optionally-shifted register value, and writes \nthe result to the destination register.", 
        "title": "BIC (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0001010xx1xxxxxxxxxxxxxxxxxxxxx", 
                "title": "BIC (shifted register)"
            }
        ], 
        "file": "bic_log_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, toward Plus infinity (vector). This \ninstruction rounds a vector of floating-point values in the SIMD&FP source \nregister to integral floating-point values of the same size using the Round \ntowards Plus Infinity rounding mode, and writes the result to the SIMD&FP \ndestination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRINTP (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111001100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTP  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100001100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTP  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frintp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Subtract from accumulator (by element). This \ninstruction multiplies the vector elements in the first source SIMD&FP \nregister by the specified value in the second source SIMD&FP register, and \nsubtracts the results from the vector elements of the destination SIMD&FP \nregister. All the values in this instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar, \nsingle-precision and double-precision , Vector, half-precision and Vector, \nsingle-precision and double-precision", 
        "title": "FMLS (by element)", 
        "classes": [
            {
                "title": "Scalar, half-precision", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111100xxxxxx0101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLS  <Hd>, <Hn>, <Vm>.H[<index>]", 
                        "title": "Scalar, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111111xxxxxxx0101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector, half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111100xxxxxx0101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", 
                        "title": "Vector, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011111xxxxxxx0101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmls_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Divide (vector). This instruction divides the floating-point \nvalues in the elements in the first source SIMD&FP register, by the \nfloating-point values in the corresponding elements in the second source \nSIMD&FP register, places the results in a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FDIV (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110010xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fdiv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from \nmemory, performs a bitwise OR with the value held in a register on it, and \nstores the result back to memory. The value initially loaded from memory is \nreturned in the destination register. \n\n* If the destination register is not WZR, LDSETAH and LDSETALH load from \n  memory with acquire semantics. \n* LDSETLH and LDSETALH store to memory with release semantics. \n* LDSETH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSETH, STSETLH.", 
        "title": "LDSETH, LDSETAH, LDSETALH, LDSETLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx001100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSETAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSETH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSETLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldseth.html", 
        "type": "instruction", 
        "aliases": [
            "stseth_ldseth.html"
        ]
    }, 
    {
        "description": "Unsigned Multiply long (vector). This instruction multiplies corresponding \nvector elements in the lower or upper half of the two source SIMD&FP \nregisters, places the result in a vector, and writes the vector to the \ndestination SIMD&FP register. The destination vector elements are twice as \nlong as the elements that are multiplied. All the values in this instruction \nare unsigned integer values. \n\nThe UMULL instruction extracts each source vector from the lower half of each \nsource register, while the UMULL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMULL, UMULL2 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx110000xxxxxxxxxx", 
                "title": "UMULL, UMULL2 (vector)"
            }
        ], 
        "file": "umull_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Subtract Long from accumulator (by element). \nThis instruction multiplies the negated vector elements in the first source \nSIMD&FP register by the specified value in the second source SIMD&FP register, \nand accumulates the product to the corresponding vector element of the \ndestination SIMD&FP register. The instruction does not round the result of the \nmultiply before the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLSL and FMLSL2", 
        "title": "FMLSL, FMLSL2 (by element)", 
        "classes": [
            {
                "title": "FMLSL", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011111xxxxxxx0100x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", 
                        "title": "FMLSL"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "FMLSL2", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011111xxxxxxx1100x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", 
                        "title": "FMLSL2"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "fmlsl_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT \nbetween the two source SIMD&FP registers, and writes the result to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ORN (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110111xxxxx000111xxxxxxxxxx", 
                "title": "ORN (vector)"
            }
        ], 
        "file": "orn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by \nelement). This instruction multiplies the vector elements of the first source \nSIMD&FP register with the value of a vector element of the second source \nSIMD&FP register without saturating the multiply results, doubles the results, \nand subtracts the most significant half of the final results from the vector \nelements of the destination SIMD&FP register. The results are rounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation \nbit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRDMLSH (by element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111111xxxxxxxx1111x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": "ARMv8.1"
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx1111x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "sqrdmlsh_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Dot Product signed arithmetic (vector, by element). This instruction performs \nthe dot product of the four 8-bit elements in each 32-bit element of the first \nsource register with the four 8-bit elements of an indexed 32-bit element in \nthe second source register, accumulating the result into the corresponding \n32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", 
        "title": "SDOT (by element)", 
        "classes": [
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx1110x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sdot_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed integer Convert to Floating-point (vector). This instruction converts \neach element in a vector from signed integer to floating-point using the \nrounding mode that is specified by the FPCR, and writes the result to the \nSIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "SCVTF (vector, integer)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111001111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SCVTF  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111100x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SCVTF  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111001111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SCVTF  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SCVTF  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "scvtf_advsimd_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load single 2-element structure to one lane of two registers. This instruction \nloads a 2-element structure from memory and writes the result to the \ncorresponding elements of the two SIMD&FP registers without affecting the \nother bits of the registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD2 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110101100000xx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 000)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101111xxxxxxx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "LD2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld2_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Halfword (register) calculates an address from a base \nregister value and an offset register value, loads a halfword from memory, \nsign-extends it, and writes it to a register. For information about memory \naccesses see Load/Store addressing modes.", 
        "title": "LDRSH (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "011110001x1xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDRSH (register)"
            }
        ], 
        "file": "ldrsh_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Authenticate Instruction address, using key B. This instruction authenticates \nan instruction address, using a modifier and key B. \n\nThe address is: \n\n* In the general-purpose register that is specified by <Xd> for AUTIB and \n  AUTIZB. \n* In X17, for AUTIB1716. \n* In X30, for AUTIBSP and AUTIBZ. \nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTIB. \n* The value zero, for AUTIZB and AUTIBZ. \n* In X16, for AUTIB1716. \n* In SP, for AUTIBSP. \nIf the authentication passes, the upper bits of the address are restored to \nenable subsequent use of the address. If the authentication fails, the upper \nbits are corrupted and any subsequent use of the address results in a \nTranslation fault. \n\nIt has encodings from 2 classes: Integer and System", 
        "title": "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "AUTIB  <Xd>, <Xn|SP>", 
                        "title": "AUTIB"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "AUTIZB  <Xd>", 
                        "title": "AUTIZB"
                    }
                ], 
                "arch": "ARMv8.3"
            }, 
            {
                "title": "System", 
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "11x"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "00x1"
                    }
                }, 
                "unallocated": null, 
                "mask": "1101010100000011001000x111x11111", 
                "encodings": [
                    {
                        "bitdiff": "(CRm == 0001 && op2 == 110)", 
                        "arch": null, 
                        "asm": "AUTIB1716", 
                        "title": "AUTIB1716"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 111)", 
                        "arch": null, 
                        "asm": "AUTIBSP", 
                        "title": "AUTIBSP"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 110)", 
                        "arch": null, 
                        "asm": "AUTIBZ", 
                        "title": "AUTIBZ"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "autib.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move vector element to scalar. This instruction duplicates the specified \nvector element in the SIMD&FP source register into a scalar, and writes the \nresult to the SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of DUP (element). This means: \n\n* The encodings in this description are named to match the encodings of DUP \n  (element). \n* The description of DUP (element) gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MOV  <V><d>, <Vn>.<T>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx000001xxxxxxxxxx", 
                "title": "MOV (scalar)"
            }
        ], 
        "file": "mov_dup_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise AND (vector). This instruction performs a bitwise AND between the two \nsource SIMD&FP registers, and writes the result to the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "AND (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110001xxxxx000111xxxxxxxxxx", 
                "title": "AND (vector)"
            }
        ], 
        "file": "and_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse Bits reverses the bit order in a register.", 
        "title": "RBIT", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "RBIT  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "RBIT  <Xd>, <Xn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x101101011000000000000xxxxxxxxxx", 
                "title": "RBIT"
            }
        ], 
        "file": "rbit_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction \nreads each vector element in the source SIMD&FP register, right shifts each \nresult by an immediate value, saturates each shifted result to a value that is \nhalf the original width, puts the final result into a vector, and writes the \nvector to the lower or upper half of the destination SIMD&FP register. All the \nvalues in this instruction are signed integer values. The destination vector \nelements are half as long as the source vector elements. The results are \nrounded. For truncated results, see SQSHRN. \n\nThe SQRSHRN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the SQRSHRN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRSHRN, SQRSHRN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx100111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRSHRN  <Vb><d>, <Va><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx100111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqrshrn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends \nit, and writes it to a register. The instruction also has memory ordering \nsemantics as described in Load LOAcquire, Store LORelease. For information \nabout memory accesses, see Load/Store addressing modes. \n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for \nsoftware to observe the presence of the acquire semantic other than its effect \non the arrival at endpoints.", 
        "title": "LDLARH", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01001000110xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDLARH  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldlarh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit \nbyte from memory, performs a bitwise OR with the value held in a register on \nit, and stores the result back to memory. \n\n* STSETB has no memory ordering semantics. \n* STSETLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSETB, LDSETAB, LDSETALB, LDSETLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSETB, LDSETAB, LDSETALB, LDSETLB. \n* The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational \n  pseudocode for this instruction.", 
        "title": "STSETB, STSETLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx001100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STSETB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STSETLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stsetb_ldsetb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Return from subroutine branches unconditionally to an address in a register, \nwith a hint that this is a subroutine return.", 
        "title": "RET", 
        "classes": [
            {
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "00000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "RET  {<Xn>}", 
                        "title": "Integer"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101011001011111000000xxxxx00000", 
                "title": "RET"
            }
        ], 
        "file": "ret.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned \ninteger values from the two source SIMD&FP registers, shifts each result right \none bit, places the results into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThe results are rounded. For truncated results, see UHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "URHADD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx000101xxxxxxxxxx", 
                "title": "URHADD"
            }
        ], 
        "file": "urhadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction \nmultiplies the values of the first two SIMD&FP source registers, subtracts the \nvalue of the third SIMD&FP source register, and writes the result to the \ndestination SIMD&FP register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FNMSUB", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "o1": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FNMSUB  <Sd>, <Sn>, <Sm>, <Sa>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011111xx1xxxxx1xxxxxxxxxxxxxxx", 
                "title": "FNMSUB"
            }
        ], 
        "file": "fnmsub_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply-Add Long (vector). This instruction multiplies corresponding \nsigned integer values in the lower or upper half of the vectors of the two \nsource SIMD&FP registers, and accumulates the results with the vector elements \nof the destination SIMD&FP register. The destination vector elements are twice \nas long as the elements that are multiplied. \n\nThe SMLAL instruction extracts each source vector from the lower half of each \nsource register, while the SMLAL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMLAL, SMLAL2 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx100000xxxxxxxxxx", 
                "title": "SMLAL, SMLAL2 (vector)"
            }
        ], 
        "file": "smlal_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare (extended register) subtracts a sign or zero-extended register value, \nfollowed by an optional left shift amount, from a register value. The argument \nthat is extended from the <Rm> register can be a byte, halfword, word, or \ndoubleword. It updates the condition flags based on the result, and discards \nthe result. \n\nThis is an alias of SUBS (extended register). This means: \n\n* The encodings in this description are named to match the encodings of SUBS \n  (extended register). \n* The description of SUBS (extended register) gives the operational pseudocode \n  for this instruction.", 
        "title": "CMP (extended register)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm3": {
                        "lo": 10, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CMP  <Xn|SP>, <R><m>{, <extend> {#<amount>}}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101011001xxxxxxxxxxxxxxxx11111", 
                "title": "CMP (extended register)"
            }
        ], 
        "file": "cmp_subs_addsub_ext.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract (extended register) subtracts a sign or zero-extended register value, \nfollowed by an optional left shift amount, from a register value, and writes \nthe result to the destination register. The argument that is extended from the \n<Rm> register can be a byte, halfword, word, or doubleword.", 
        "title": "SUB (extended register)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm3": {
                        "lo": 10, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1001011001xxxxxxxxxxxxxxxxxxxxx", 
                "title": "SUB (extended register)"
            }
        ], 
        "file": "sub_addsub_ext.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Data Memory Barrier is a memory barrier that ensures the ordering of \nobservations of memory accesses, see Data Memory Barrier.", 
        "title": "DMB", 
        "classes": [
            {
                "fields": {
                    "opc": {
                        "lo": 5, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DMB  <option>|#<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110011xxxx10111111", 
                "title": "DMB"
            }
        ], 
        "file": "dmb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Signed Byte (unprivileged) loads a byte from memory, \nsign-extends it to 32 bits or 64 bits, and writes the result to a register. \nThe address that is used for the load is calculated from a base register and \nan immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "LDTRSB", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 11)", 
                        "arch": null, 
                        "asm": "LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "001110001x0xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDTRSB"
            }
        ], 
        "file": "ldtrsb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the \norder of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in \nthe source SIMD&FP register, places the results into a vector, and writes the \nvector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "REV64", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "REV64  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx100000000010xxxxxxxxxx", 
                "title": "REV64"
            }
        ], 
        "file": "rev64_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, toward Plus infinity (scalar). This \ninstruction rounds a floating-point value in the SIMD&FP source register to an \nintegral floating-point value of the same size using the Round towards Plus \nInfinity rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FRINTP (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "rmode": {
                        "lo": 15, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "001"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FRINTP  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FRINTP  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FRINTP  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100100110000xxxxxxxxxx", 
                "title": "FRINTP (scalar)"
            }
        ], 
        "file": "frintp_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to \neven (vector). This instruction converts a scalar or each element in a vector \nfrom a floating-point value to a signed integer value using the Round to \nNearest rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTNS (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111001111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNS  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111100x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNS  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111001111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTNS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtns_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each \nvector element in the source SIMD&FP register, right shifts each result by an \nimmediate value, and accumulates the final results with the vector elements of \nthe destination SIMD&FP register. All the values in this instruction are \nunsigned integer values. The results are truncated. For rounded results, see \nURSRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "USRA", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USRA  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "usra_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load single 2-element structure and Replicate to all lanes of two registers. \nThis instruction loads a 2-element structure from memory and replicates the \nstructure to all the lanes of the two SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD2R", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101011000001100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101111xxxxx1100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld2r_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Pair of Registers calculates an address from a base register value and an \nimmediate offset, loads two 32-bit words or two 64-bit doublewords from \nmemory, and writes them to two registers. For information about memory \naccesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", 
        "title": "LDP", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "x010100011xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "x010100111xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Signed offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "x010100101xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldp_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add Pairwise (vector). This instruction creates a vector by concatenating the \nvector elements of the first source SIMD&FP register after the vector elements \nof the second source SIMD&FP register, reads each pair of adjacent vector \nelements from the concatenated vector, adds each pair of values together, \nplaces the result into a vector, and writes the vector to the destination \nSIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ADDP (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx101111xxxxxxxxxx", 
                "title": "ADDP (vector)"
            }
        ], 
        "file": "addp_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword \nto memory if the PE has exclusive access to the memory address, from two \nregisters, and returns a status value of 0 if the store was successful, or of \n1 if no store was performed. See Synchronization and semaphores. The memory \naccess is atomic. The instruction also has memory ordering semantics as \ndescribed in Load-Acquire, Store-Release. For information about memory \naccesses see Load/Store addressing modes.", 
        "title": "STLXR", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000000xxxxx1xxxxxxxxxxxxxxx", 
                "title": "STLXR"
            }
        ], 
        "file": "stlxr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating extract Unsigned Narrow. This instruction reads each signed \ninteger value in the vector of the source SIMD&FP register, saturates the \nvalue to an unsigned integer value that is half the original width, places the \nresult into a vector, and writes the vector to the lower or upper half of the \ndestination SIMD&FP register. The destination vector elements are half as long \nas the source vector elements. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQXTUN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the SQXTUN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQXTUN, SQXTUN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx100001001010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQXTUN  <Vb><d>, <Va><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx100001001010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqxtun_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Debug Change PE State to EL3, when executed in Debug state: \n\n* If executed at EL3 selects SP_EL3. \n* Otherwise, changes the current Exception level and SP to EL3 using SP_EL3. \nThe target exception level of a DCPS3 instruction is EL3. \n\nOn executing a DCPS3 instruction: \n\n* ELR_EL3 becomes unknown. \n* SPSR_EL3 becomes unknown. \n* ESR_EL3 becomes unknown. \n* DLR_EL0 and DSPSR_EL0 become unknown. \n* The endianness is set according to SCTLR_EL3.EE. \nThis instruction is undefined at all exception levels if either: \n\n* EDSCR.SDD == 1. \n* EL3 is not implemented. \nThis instruction is always undefined in Non-debug state. \n\nFor more information on the operation of the DCPSn instructions, see DCPS.", 
        "title": "DCPS3", 
        "classes": [
            {
                "fields": {
                    "LL": {
                        "lo": 0, 
                        "hi": 1, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DCPS3  {#<imm>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100101xxxxxxxxxxxxxxxx00011", 
                "title": "DCPS3"
            }
        ], 
        "file": "dcps3.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Halfword (unprivileged) loads a halfword from memory, \nzero-extends it, and writes the result to a register. The address that is used \nfor the load is calculated from a base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "LDTRH", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01111000010xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDTRH"
            }
        ], 
        "file": "ldtrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Shift Left (register). This instruction takes each element in the \nvector of the first source SIMD&FP register, shifts each element by a value \nfrom the least significant byte of the corresponding element of the second \nsource SIMD&FP register, places the results in a vector, and writes the vector \nto the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift \nvalue is negative, it is a truncating right shift. For a rounding shift, see \nURSHL. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "USHL", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx010001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx010001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ushl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and \nreturns a 128-bit result in the destination SIMD&FP register. The result is \nobtained by a three-way exclusive OR of the elements within the input vectors \nwith some fixed rotations, see the Operation pseudocode for more information. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM3PARTW2", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110011xxxxx110001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm3partw2_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Absolute Compare Greater than (vector). This instruction \ncompares the absolute value of each vector element in the first source SIMD&FP \nregister with the absolute value of the corresponding vector element in the \nsecond source SIMD&FP register and if the first value is greater than the \nsecond value sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to one, otherwise sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FACGT", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110110xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGT  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x1xxxxx111011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGT  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110110xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x1xxxxx111011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "facgt_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword \nfrom memory, compares it against the value held in a register, and stores the \nlarger value back to memory, treating the values as signed numbers. The value \ninitially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDSMAXAH and LDSMAXALH load from \n  memory with acquire semantics. \n* LDSMAXLH and LDSMAXALH store to memory with release semantics. \n* LDSMAXH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMAXH, STSMAXLH.", 
        "title": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx010000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAXH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldsmaxh.html", 
        "type": "instruction", 
        "aliases": [
            "stsmaxh_ldsmaxh.html"
        ]
    }, 
    {
        "description": "Unsigned Add Wide. This instruction adds the vector elements of the first \nsource SIMD&FP register to the corresponding vector elements in the lower or \nupper half of the second source SIMD&FP register, places the result in a \nvector, and writes the vector to the SIMD&FP destination register. The vector \nelements of the destination register and the first source register are twice \nas long as the vector elements of the second source register. All the values \nin this instruction are unsigned integer values. \n\nThe UADDW instruction extracts vector elements from the lower half of the \nsecond source register, while the UADDW2 instruction extracts vector elements \nfrom the upper half of the second source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UADDW, UADDW2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx000100xxxxxxxxxx", 
                "title": "UADDW, UADDW2"
            }
        ], 
        "file": "uaddw_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Table vector Lookup. This instruction reads each value from the vector \nelements in the index source SIMD&FP register, uses each result as an index to \nperform a lookup in a table of bytes that is described by one to four source \ntable SIMD&FP registers, places the lookup result in a vector, and writes the \nvector to the destination SIMD&FP register. If an index is out of range for \nthe table, the result for that lookup is 0. If more than one source register \nis used to describe the table, the first source register describes the lowest \nbytes of the table. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "TBL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "len": {
                        "lo": 13, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(len == 01)", 
                        "arch": null, 
                        "asm": "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>", 
                        "title": "Two register table"
                    }, 
                    {
                        "bitdiff": "(len == 10)", 
                        "arch": null, 
                        "asm": "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>", 
                        "title": "Three register table"
                    }, 
                    {
                        "bitdiff": "(len == 11)", 
                        "arch": null, 
                        "asm": "TBL  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>", 
                        "title": "Four register table"
                    }, 
                    {
                        "bitdiff": "(len == 00)", 
                        "arch": null, 
                        "asm": "TBL  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>", 
                        "title": "Single register table"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110000xxxxx0xx000xxxxxxxxxx", 
                "title": "TBL"
            }
        ], 
        "file": "tbl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Extract register extracts a register from a pair of registers. \n\nThis instruction is used by the alias ROR (immediate).", 
        "title": "EXTR", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0 && imms == 0xxxxx)", 
                        "arch": null, 
                        "asm": "EXTR  <Wd>, <Wn>, <Wm>, #<lsb>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100111x0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "EXTR"
            }
        ], 
        "file": "extr.html", 
        "type": "instruction", 
        "aliases": [
            "ror_extr.html"
        ]
    }, 
    {
        "description": "Floating-point Round to Integral, toward Minus infinity (vector). This \ninstruction rounds a vector of floating-point values in the SIMD&FP source \nregister to integral floating-point values of the same size using the Round \ntowards Minus Infinity rounding mode, and writes the result to the SIMD&FP \ndestination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRINTM (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111001111001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTM  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x100001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTM  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frintm_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Minimum Pairwise. This instruction creates a vector by concatenating \nthe vector elements of the first source SIMD&FP register after the vector \nelements of the second source SIMD&FP register, reads each pair of adjacent \nvector elements in the two source SIMD&FP registers, writes the smallest of \neach pair of signed integer values into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMINP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx101011xxxxxxxxxx", 
                "title": "SMINP"
            }
        ], 
        "file": "sminp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Logical Shift Left Variable shifts a register value left by a variable number \nof bits, shifting in zeros, and writes the result to the destination register. \nThe remainder obtained by dividing the second source register by the data size \ndefines the number of bits by which the first source register is left-shifted. \n\nThis instruction is used by the alias LSL (register).", 
        "title": "LSLV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "LSLV  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "LSLV  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001000xxxxxxxxxx", 
                "title": "LSLV"
            }
        ], 
        "file": "lslv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register (register) calculates an address from a base register value and \nan offset register value, and stores a 32-bit word or a 64-bit doubleword to \nthe calculated address, from a register. For information about memory \naccesses, see Load/Store addressing modes. \n\nThe instruction uses an offset addressing mode, that calculates the address \nused for the memory access from a base register value and an offset register \nvalue. The offset can be optionally shifted and extended.", 
        "title": "STR (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x111000001xxxxxxxxx10xxxxxxxxxx", 
                "title": "STR (register)"
            }
        ], 
        "file": "str_reg_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply Long (vector). This instruction multiplies corresponding \nsigned integer values in the lower or upper half of the vectors of the two \nsource SIMD&FP registers, places the results in a vector, and writes the \nvector to the destination SIMD&FP register. \n\nThe destination vector elements are twice as long as the elements that are \nmultiplied. \n\nThe SMULL instruction extracts each source vector from the lower half of each \nsource register, while the SMULL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMULL, SMULL2 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx110000xxxxxxxxxx", 
                "title": "SMULL, SMULL2 (vector)"
            }
        ], 
        "file": "smull_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract (immediate) subtracts an optionally-shifted immediate value from a \nregister value, and writes the result to the destination register.", 
        "title": "SUB (immediate)", 
        "classes": [
            {
                "fields": {
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1010001xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "SUB (immediate)"
            }
        ], 
        "file": "sub_addsub_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare (immediate) subtracts an optionally-shifted immediate value from a \nregister value. It updates the condition flags based on the result, and \ndiscards the result. \n\nThis is an alias of SUBS (immediate). This means: \n\n* The encodings in this description are named to match the encodings of SUBS \n  (immediate). \n* The description of SUBS (immediate) gives the operational pseudocode for \n  this instruction.", 
        "title": "CMP (immediate)", 
        "classes": [
            {
                "fields": {
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CMP  <Wn|WSP>, #<imm>{, <shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CMP  <Xn|SP>, #<imm>{, <shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1110001xxxxxxxxxxxxxxxxxxx11111", 
                "title": "CMP (immediate)"
            }
        ], 
        "file": "cmp_subs_addsub_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Arithmetic Shift Right (register) shifts a register value right by a variable \nnumber of bits, shifting in copies of its sign bit, and writes the result to \nthe destination register. The remainder obtained by dividing the second source \nregister by the data size defines the number of bits by which the first source \nregister is right-shifted. \n\nThis is an alias of ASRV. This means: \n\n* The encodings in this description are named to match the encodings of ASRV. \n* The description of ASRV gives the operational pseudocode for this \n  instruction.", 
        "title": "ASR (register)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ASR  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ASR  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001010xxxxxxxxxx", 
                "title": "ASR (register)"
            }
        ], 
        "file": "asr_asrv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic exclusive OR on word or doubleword in memory, without return, \natomically loads a 32-bit word or 64-bit doubleword from memory, performs an \nexclusive OR with the value held in a register on it, and stores the result \nback to memory. \n\n* STEOR has no memory ordering semantics. \n* STEORL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDEOR, LDEORA, LDEORAL, LDEORL. This means: \n\n* The encodings in this description are named to match the encodings of LDEOR, \n  LDEORA, LDEORAL, LDEORL. \n* The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational \n  pseudocode for this instruction.", 
        "title": "STEOR, STEORL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx001000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STEOR  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDEOR alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STEORL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDEORL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STEOR  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDEOR alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STEORL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDEORL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "steor_ldeor.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Population Count per byte. This instruction counts the number of bits that \nhave a value of one in each vector element in the source SIMD&FP register, \nplaces the result into a vector, and writes the vector to the destination \nSIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "CNT", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CNT  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx100000010110xxxxxxxxxx", 
                "title": "CNT"
            }
        ], 
        "file": "cnt_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Greater than or Equal (vector). This instruction reads \neach floating-point value in the first source SIMD&FP register and if the \nvalue is greater than or equal to the corresponding floating-point value in \nthe second source SIMD&FP register sets every bit of the corresponding vector \nelement in the destination SIMD&FP register to one, otherwise sets every bit \nof the corresponding vector element in the destination SIMD&FP register to \nzero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMGE (register)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110010xxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x1xxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110010xxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmge_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic exclusive OR on byte in memory, without return, atomically loads an \n8-bit byte from memory, performs an exclusive OR with the value held in a \nregister on it, and stores the result back to memory. \n\n* STEORB has no memory ordering semantics. \n* STEORLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDEORB, LDEORAB, LDEORALB, LDEORLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDEORB, LDEORAB, LDEORALB, LDEORLB. \n* The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational \n  pseudocode for this instruction.", 
        "title": "STEORB, STEORLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx001000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STEORB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STEORLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "steorb_ldeorb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Insert if True. This instruction inserts each bit from the first \nsource SIMD&FP register into the SIMD&FP destination register if the \ncorresponding bit of the second source SIMD&FP register is 1, otherwise leaves \nthe bit in the destination register unchanged. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "BIT", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc2": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110101xxxxx000111xxxxxxxxxx", 
                "title": "BIT"
            }
        ], 
        "file": "bit_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store multiple 4-element structures from four registers. This instruction \nstores multiple 4-element structures to memory from four SIMD&FP registers, \nwith interleaving. Every element of each register is stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST4 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100000000000000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0000"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100100xxxxx0000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st4_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Exclusive Register Halfword derives an address from a base register \nvalue, loads a halfword from memory, zero-extends it and writes it to a \nregister. The memory access is atomic. The PE marks the physical address being \naccessed as an exclusive access. This exclusive access mark is checked by \nStore Exclusive instructions. See Synchronization and semaphores. For \ninformation about memory accesses see Load/Store addressing modes.", 
        "title": "LDXRH", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDXRH  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001000010xxxxx0xxxxxxxxxxxxxxx", 
                "title": "LDXRH"
            }
        ], 
        "file": "ldxrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP \nregisters from memory. The address that is used for the load is calculated \nfrom a base register value and an optional immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", 
        "title": "LDP (SIMD&FP)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx10110011xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDP  <St1>, <St2>, [<Xn|SP>], #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "LDP  <Dt1>, <Dt2>, [<Xn|SP>], #<imm>", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDP  <Qt1>, <Qt2>, [<Xn|SP>], #<imm>", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx10110111xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "LDP  <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDP  <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Signed offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "xx10110101xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "LDP  <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "128-bit"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldp_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Extract vector from pair of vectors. This instruction extracts the lowest \nvector elements from the second source SIMD&FP register and the highest vector \nelements from the first source SIMD&FP register, concatenates the results into \na vector, and writes the vector to the destination SIMD&FP register vector. \nThe index value specifies the lowest vector element to extract from the first \nsource register, and consecutive elements are extracted from the first, then \nsecond, source registers until the destination vector is filled. \n\nThe following figure shows an example of the operation of EXT doubleword \noperation for Q = 0 and imm4<2:0> = 3. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "EXT", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm4": {
                        "lo": 11, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "EXT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110000xxxxx0xxxx0xxxxxxxxxx", 
                "title": "EXT"
            }
        ], 
        "file": "ext_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Logical Shift Left (immediate) shifts a register value left by an immediate \nnumber of bits, shifting in zeros, and writes the result to the destination \nregister. \n\nThis is an alias of UBFM. This means: \n\n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "LSL (immediate)", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "!=", 
                        "value": "x11111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0 && imms != 011111)", 
                        "arch": null, 
                        "asm": "LSL  <Wd>, <Wn>, #<shift>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1 && imms != 111111)", 
                        "arch": null, 
                        "asm": "LSL  <Xd>, <Xn>, #<shift>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxxxxxxxxxx11111xxxxxxxxxx"
                ], 
                "mask": "x10100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "LSL (immediate)"
            }
        ], 
        "file": "lsl_ubfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Arithmetic Shift Right (immediate) shifts a register value right by an \nimmediate number of bits, shifting in copies of the sign bit in the upper bits \nand zeros in the lower bits, and writes the result to the destination \nregister. \n\nThis is an alias of SBFM. This means: \n\n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "ASR (immediate)", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "x11111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0 && imms == 011111)", 
                        "arch": null, 
                        "asm": "ASR  <Wd>, <Wn>, #<shift>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1 && imms == 111111)", 
                        "arch": null, 
                        "asm": "ASR  <Xd>, <Xn>, #<shift>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100110xxxxxxxx11111xxxxxxxxxx", 
                "title": "ASR (immediate)"
            }
        ], 
        "file": "asr_sbfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Rounding Shift Right (immediate). This instruction reads each vector \nelement in the source SIMD&FP register, right shifts each result by an \nimmediate value, places the final result into a vector, and writes the vector \nto the destination SIMD&FP register. All the values in this instruction are \nsigned integer values. The results are rounded. For truncated results, see \nSSHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SRSHR", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRSHR  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "srshr_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned extend Long. This instruction copies each vector element from the \nlower or upper half of the source SIMD&FP register into a vector, and writes \nthe vector to the destination SIMD&FP register. The destination vector \nelements are twice as long as the source vector elements. \n\nThe UXTL instruction extracts vector elements from the lower half of the \nsource register, while the UXTL2 instruction extracts vector elements from the \nupper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of USHLL, USHLL2. This means: \n\n* The encodings in this description are named to match the encodings of USHLL, \n  USHLL2. \n* The description of USHLL, USHLL2 gives the operational pseudocode for this \n  instruction.", 
        "title": "UXTL, UXTL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxx000101001xxxxxxxxxx", 
                "title": "UXTL, UXTL2"
            }
        ], 
        "file": "uxtl_ushll_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Error Synchronization Barrier is an error synchronization event that might \nalso update DISR_EL1 and VDISR_EL2. \n\nThis instruction can be used at all Exception levels and in Debug state. \n\nIn Debug state, this instruction behaves as if SError interrupts are masked at \nall Exception levels. See Error Synchronization Barrier in the ARM(R) \nReliability, Availability, and Serviceability (RAS) Specification, ARMv8, for \nARMv8-A architecture profile. \n\nIf the RAS Extension is not implemented, this instruction executes as a NOP.", 
        "title": "ESB", 
        "classes": [
            {
                "title": "System", 
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0010"
                    }
                }, 
                "unallocated": null, 
                "mask": "11010101000000110010001000011111", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ESB", 
                        "title": "System"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "esb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Authenticate Instruction address, using key A. This instruction authenticates \nan instruction address, using a modifier and key A. \n\nThe address is: \n\n* In the general-purpose register that is specified by <Xd> for AUTIA and \n  AUTIZA. \n* In X17, for AUTIA1716. \n* In X30, for AUTIASP and AUTIAZ. \nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTIA. \n* The value zero, for AUTIZA and AUTIAZ. \n* In X16, for AUTIA1716. \n* In SP, for AUTIASP. \nIf the authentication passes, the upper bits of the address are restored to \nenable subsequent use of the address. If the authentication fails, the upper \nbits are corrupted and any subsequent use of the address results in a \nTranslation fault. \n\nIt has encodings from 2 classes: Integer and System", 
        "title": "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "AUTIA  <Xd>, <Xn|SP>", 
                        "title": "AUTIA"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "AUTIZA  <Xd>", 
                        "title": "AUTIZA"
                    }
                ], 
                "arch": "ARMv8.3"
            }, 
            {
                "title": "System", 
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "10x"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "00x1"
                    }
                }, 
                "unallocated": null, 
                "mask": "1101010100000011001000x110x11111", 
                "encodings": [
                    {
                        "bitdiff": "(CRm == 0001 && op2 == 100)", 
                        "arch": null, 
                        "asm": "AUTIA1716", 
                        "title": "AUTIA1716"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 101)", 
                        "arch": null, 
                        "asm": "AUTIASP", 
                        "title": "AUTIASP"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 100)", 
                        "arch": null, 
                        "asm": "AUTIAZ", 
                        "title": "AUTIAZ"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "autia.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned integer Convert to Floating-point (vector). This instruction converts \neach element in a vector from an unsigned integer value to a floating-point \nvalue using the rounding mode that is specified by the FPCR, and writes the \nresult to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "UCVTF (vector, integer)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111001111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UCVTF  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UCVTF  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111001111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UCVTF  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UCVTF  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ucvtf_advsimd_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Set sets the destination register to 1 if the condition is TRUE, \nand otherwise sets it to 0. \n\nThis is an alias of CSINC. This means: \n\n* The encodings in this description are named to match the encodings of CSINC. \n* The description of CSINC gives the operational pseudocode for this \n  instruction.", 
        "title": "CSET", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "!=", 
                        "value": "111x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CSET  <Wd>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CSET  <Xd>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"
                ], 
                "mask": "x001101010011111xxxx0111111xxxxx", 
                "title": "CSET"
            }
        ], 
        "file": "cset_csinc.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Shift Right and Insert (immediate). This instruction reads each vector element \nin the source SIMD&FP register, right shifts each vector element by an \nimmediate value, and inserts the result into the corresponding vector element \nin the destination SIMD&FP register such that the new zero bits created by the \nshift are not inserted but retain their existing value. Bits shifted out of \nthe right of each vector element of the source register are lost. \n\nThe following figure shows an example of the operation of shift right by 3 for \nan 8-bit vector element. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SRI", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx010001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRI  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx010001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sri_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply-Add to accumulator (vector). This instruction multiplies \ncorresponding elements in the vectors of the two source SIMD&FP registers, and \naccumulates the results with the vector elements of the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MLA (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx100101xxxxxxxxxx", 
                "title": "MLA (vector)"
            }
        ], 
        "file": "mla_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed fixed-point Convert to Floating-point (scalar). This instruction \nconverts the signed value in the 32-bit or 64-bit general-purpose source \nregister to a floating-point value using the rounding mode that is specified \nby the FPCR, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped.", 
        "title": "SCVTF (scalar, fixed-point)", 
        "classes": [
            {
                "fields": {
                    "scale": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "SCVTF  <Hd>, <Wn>, #<fbits>", 
                        "title": "32-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "SCVTF  <Sd>, <Wn>, #<fbits>", 
                        "title": "32-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "SCVTF  <Dd>, <Wn>, #<fbits>", 
                        "title": "32-bit to double-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "SCVTF  <Hd>, <Xn>, #<fbits>", 
                        "title": "64-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "SCVTF  <Sd>, <Xn>, #<fbits>", 
                        "title": "64-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "SCVTF  <Dd>, <Xn>, #<fbits>", 
                        "title": "64-bit to double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx000010xxxxxxxxxxxxxxxx", 
                "title": "SCVTF (scalar, fixed-point)"
            }
        ], 
        "file": "scvtf_float_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise AND (shifted register) performs a bitwise AND of a register value and \nan optionally-shifted register value, and writes the result to the destination \nregister.", 
        "title": "AND (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0001010xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "AND (shifted register)"
            }
        ], 
        "file": "and_log_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned sum Long across Vector. This instruction adds every vector element in \nthe source SIMD&FP register together, and writes the scalar result to the \ndestination SIMD&FP register. The destination scalar is twice as long as the \nsource vector elements. All the values in this instruction are unsigned \ninteger values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UADDLV", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UADDLV  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx110000001110xxxxxxxxxx", 
                "title": "UADDLV"
            }
        ], 
        "file": "uaddlv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Subtract Long. This instruction subtracts each vector element in the \nlower or upper half of the second source SIMD&FP register from the \ncorresponding vector element of the first source SIMD&FP register, places the \nresults into a vector, and writes the vector to the destination SIMD&FP \nregister. All the values in this instruction are signed integer values. The \ndestination vector elements are twice as long as the source vector elements. \n\nThe SSUBL instruction extracts each source vector from the lower half of each \nsource register, while the SSUBL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SSUBL, SSUBL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx001000xxxxxxxxxx", 
                "title": "SSUBL, SSUBL2"
            }
        ], 
        "file": "ssubl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned saturating Accumulate of Signed value. This instruction adds the \nsigned integer values of the vector elements in the source SIMD&FP register to \ncorresponding unsigned integer values of the vector elements in the \ndestination SIMD&FP register, and accumulates the resulting unsigned integer \nvalues with the vector elements of the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "USQADD", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx100000001110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USQADD  <V><d>, <V><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx100000001110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USQADD  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "usqadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store SIMD&FP register (register offset). This instruction stores a single \nSIMD&FP register to memory. The address that is used for the store is \ncalculated from a base register value and an offset register value. The offset \ncan be optionally shifted and extended. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "STR (register, SIMD&FP)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 00 && option != 011)", 
                        "arch": null, 
                        "asm": "STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]", 
                        "title": "8-fsreg,STR-8-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 00 && option == 011)", 
                        "arch": null, 
                        "asm": "STR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", 
                        "title": "8-fsreg,STR-8-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "16-fsreg,STR-16-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "32-fsreg,STR-32-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 00)", 
                        "arch": null, 
                        "asm": "STR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "64-fsreg,STR-64-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 10)", 
                        "arch": null, 
                        "asm": "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "128-fsreg,STR-128-fsreg"
                    }
                ], 
                "unallocated": null, 
                "mask": "xx111100x01xxxxxxxxx10xxxxxxxxxx", 
                "title": "STR (register, SIMD&FP)"
            }
        ], 
        "file": "str_reg_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum Number Pairwise (vector). This instruction creates a \nvector by concatenating the vector elements of the first source SIMD&FP \nregister after the vector elements of the second source SIMD&FP register, \nreads each pair of adjacent vector elements in the two source SIMD&FP \nregisters, writes the smallest of each pair of floating-point values into a \nvector, and writes the vector to the destination SIMD&FP register. All the \nvalues in this instruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result is the numerical \nvalue, otherwise the result is identical to FMIN (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMINNMP (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "a": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110110xxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x1xxxxx110001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fminnmp_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a \ncontext synchronization event. For more information, see Instruction \nSynchronization Barrier (ISB).", 
        "title": "ISB", 
        "classes": [
            {
                "fields": {
                    "opc": {
                        "lo": 5, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ISB  {<option>|#<imm>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110011xxxx11011111", 
                "title": "ISB"
            }
        ], 
        "file": "isb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Test bit and Branch if Zero compares the value of a test bit with zero, and \nconditionally branches to a label at a PC-relative offset if the comparison is \nequal. It provides a hint that this is not a subroutine call or return. This \ninstruction does not affect condition flags.", 
        "title": "TBZ", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "b5": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "b40": {
                        "lo": 19, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm14": {
                        "lo": 5, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "TBZ  <R><t>, #<imm>, <label>", 
                        "title": "14-bit signed PC-relative branch offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0110110xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "TBZ"
            }
        ], 
        "file": "tbz.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This \ninstruction converts the floating-point value in the SIMD&FP source register \nto a 32-bit or 64-bit signed integer using the Round towards Zero rounding \nmode, and writes the result to the general-purpose destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTZS (scalar, integer)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZS  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZS  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZS  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx111000000000xxxxxxxxxx", 
                "title": "FCVTZS (scalar, integer)"
            }
        ], 
        "file": "fcvtzs_float_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector \nelements in the lower or upper half of the first source SIMD&FP register by \nthe corresponding vector elements of the second source SIMD&FP register, and \naccumulates the results with the vector elements of the destination SIMD&FP \nregister. The destination vector elements are twice as long as the elements \nthat are multiplied. \n\nThe UMLAL instruction extracts vector elements from the lower half of the \nfirst source register, while the UMLAL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMLAL, UMLAL2 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx100000xxxxxxxxxx", 
                "title": "UMLAL, UMLAL2 (vector)"
            }
        ], 
        "file": "umlal_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register, with pointer authentication. This instruction authenticates an \naddress from a base register using a modifier of zero and the specified key, \nadds an immediate offset to the authenticated address, and loads a 64-bit \ndoubleword from memory at this resulting address into a register. \n\nKey A is used for LDRAA, and key B is used for LDRAB. \n\nIf the authentication passes, the PE behaves the same as for an LDR \ninstruction. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to the base register, unless the \npre-indexed variant of the instruction is used. In this case, the address that \nis written back to the base register does not include the pointer \nauthentication code. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "LDRAA, LDRAB", 
        "classes": [
            {
                "title": "Unscaled offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "M": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "S": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "W": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "unallocated": null, 
                "mask": "11111000xx1xxxxxxxxxx1xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(M == 0 && W == 0)", 
                        "arch": null, 
                        "asm": "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Key A, offset"
                    }, 
                    {
                        "bitdiff": "(M == 0 && W == 1)", 
                        "arch": null, 
                        "asm": "LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]!", 
                        "title": "Key A, pre-indexed"
                    }, 
                    {
                        "bitdiff": "(M == 1 && W == 0)", 
                        "arch": null, 
                        "asm": "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Key B, offset"
                    }, 
                    {
                        "bitdiff": "(M == 1 && W == 1)", 
                        "arch": null, 
                        "asm": "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]!", 
                        "title": "Key B, pre-indexed"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "ldra.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store single 2-element structure from one lane of two registers. This \ninstruction stores a 2-element structure to memory from corresponding elements \nof two SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST2 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110100100000xx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 000)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101101xxxxxxx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st2_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Maximum across Vector. This instruction compares all the vector \nelements in the source SIMD&FP register, and writes the largest of the values \nas a scalar to the destination SIMD&FP register. All the values in this \ninstruction are signed integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMAXV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMAXV  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx110000101010xxxxxxxxxx", 
                "title": "SMAXV"
            }
        ], 
        "file": "smaxv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load single 3-element structure and Replicate to all lanes of three registers. \nThis instruction loads a 3-element structure from memory and replicates the \nstructure to all the lanes of the three SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD3R", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101010000001110xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101110xxxxx1110xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld3r_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Count leading zero bits: Rd = CLZ(Rn).", 
        "title": "CLZ", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CLZ  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CLZ  <Xd>, <Xn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x101101011000000000100xxxxxxxxxx", 
                "title": "CLZ"
            }
        ], 
        "file": "clz_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector). \nThis instruction converts a scalar or each element in a vector from a \nfloating-point value to an unsigned integer value using the Round towards Zero \nrounding mode, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTZU (vector, integer)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111011111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZU  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZU  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100001101110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtzu_advsimd_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half \n(by element). This instruction multiplies the vector elements of the first \nsource SIMD&FP register with the value of a vector element of the second \nsource SIMD&FP register without saturating the multiply results, doubles the \nresults, and accumulates the most significant half of the final results with \nthe vector elements of the destination SIMD&FP register. The results are \nrounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation \nbit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRDMLAH (by element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111111xxxxxxxx1101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": "ARMv8.1"
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx1101x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "sqrdmlah_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a \nregister. \n\nThis instruction is used by the alias MOV (wide immediate).", 
        "title": "MOVZ", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "hw": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MOVZ  <Wd>, #<imm>{, LSL #<shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOVZ  <Xd>, #<imm>{, LSL #<shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10100101xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "MOVZ"
            }
        ], 
        "file": "movz.html", 
        "type": "instruction", 
        "aliases": [
            "mov_movz.html"
        ]
    }, 
    {
        "description": "Unsigned saturating Shift Left (immediate). This instruction takes each vector \nelement in the source SIMD&FP register, shifts it by an immediate value, \nplaces the results in a vector, and writes the vector to the destination \nSIMD&FP register. The results are truncated. For rounded results, see UQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQSHL (immediate)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx011101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSHL  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx011101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqshl_advsimd_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts \nthe vector elements in the lower or upper half of the second source SIMD&FP \nregister from the corresponding vector elements of the first source SIMD&FP \nregister, and accumulates the absolute values of the results into the vector \nelements of the destination SIMD&FP register. The destination vector elements \nare twice as long as the source vector elements. All the values in this \ninstruction are unsigned integer values. \n\nThe UABAL instruction extracts each source vector from the lower half of each \nsource register, while the UABAL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UABAL, UABAL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx010100xxxxxxxxxx", 
                "title": "UABAL, UABAL2"
            }
        ], 
        "file": "uabal_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply returning High half (by element). This \ninstruction multiplies each vector element in the first source SIMD&FP \nregister by the specified vector element of the second source SIMD&FP \nregister, doubles the results, places the most significant half of the final \nresults into a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nThe results are truncated. For rounded results, see SQRDMULH. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMULH (by element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011111xxxxxxxx1100x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx1100x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmulh_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store multiple single-element structures from one, two, three, or four \nregisters. This instruction stores elements to memory from one, two, three, or \nfour SIMD&FP registers, without interleaving. Every element of each register \nis stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST1 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110000000000xx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 0111)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T> }, [<Xn|SP>]", 
                        "title": "One register"
                    }, 
                    {
                        "bitdiff": "(opcode == 1010)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", 
                        "title": "Two registers"
                    }, 
                    {
                        "bitdiff": "(opcode == 0110)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", 
                        "title": "Three registers"
                    }, 
                    {
                        "bitdiff": "(opcode == 0010)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", 
                        "title": "Four registers"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100100xxxxxxx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 0111)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "One register, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 0111)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "One register, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 1010)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Two registers, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 1010)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Two registers, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 0110)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Three registers, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 0110)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Three registers, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 0010)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Four registers, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 0010)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Four registers, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st1_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare signed Greater than or Equal to zero (vector). This instruction reads \neach vector element in the source SIMD&FP register and if the signed integer \nvalue is greater than or equal to zero sets every bit of the corresponding \nvector element in the destination SIMD&FP register to one, otherwise sets \nevery bit of the corresponding vector element in the destination SIMD&FP \nregister to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMGE (zero)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx100000100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGE  <V><d>, <V><n>, #0", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx100000100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMGE  <Vd>.<T>, <Vn>.<T>, #0", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmge_advsimd_zero.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Conditional Select (scalar). This instruction allows the \nSIMD&FP destination register to take the value from either one or the other of \ntwo SIMD&FP source registers. If the condition passes, the first SIMD&FP \nsource register value is taken, otherwise the second SIMD&FP source register \nvalue is taken. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCSEL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCSEL  <Hd>, <Hn>, <Hm>, <cond>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FCSEL  <Sd>, <Sn>, <Sm>, <cond>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FCSEL  <Dd>, <Dn>, <Dm>, <cond>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxxxxxx11xxxxxxxxxx", 
                "title": "FCSEL"
            }
        ], 
        "file": "fcsel_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply-Subtract Long (vector). This instruction multiplies \ncorresponding signed integer values in the lower or upper half of the vectors \nof the two source SIMD&FP registers, and subtracts the results from the vector \nelements of the destination SIMD&FP register. The destination vector elements \nare twice as long as the elements that are multiplied. \n\nThe SMLSL instruction extracts each source vector from the lower half of each \nsource register, while the SMLSL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMLSL, SMLSL2 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx101000xxxxxxxxxx", 
                "title": "SMLSL, SMLSL2 (vector)"
            }
        ], 
        "file": "smlsl_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point move immediate (vector). This instruction copies an immediate \nfloating-point constant into every element of the SIMD&FP destination \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMOV (vector, immediate)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "a": {
                        "lo": 18, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "c": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "b": {
                        "lo": 17, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "e": {
                        "lo": 8, 
                        "hi": 8, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "d": {
                        "lo": 9, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "g": {
                        "lo": 6, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "f": {
                        "lo": 7, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "h": {
                        "lo": 5, 
                        "hi": 5, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111100000xxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMOV  <Vd>.<T>, #<imm>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "a": {
                        "lo": 18, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "c": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "b": {
                        "lo": 17, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "e": {
                        "lo": 8, 
                        "hi": 8, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "d": {
                        "lo": 9, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "g": {
                        "lo": 6, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "f": {
                        "lo": 7, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "h": {
                        "lo": 5, 
                        "hi": 5, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "cmode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1111"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "0xx0111100000xxx111101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(op == 0)", 
                        "arch": null, 
                        "asm": "FMOV  <Vd>.<T>, #<imm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(Q == 1 && op == 1)", 
                        "arch": null, 
                        "asm": "FMOV  <Vd>.2D, #<imm>", 
                        "title": "Double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmov_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a \nsource SIMD&FP register left by 1, performs a bitwise exclusive OR of the \nresulting 128-bit vector and the vector in another source SIMD&FP register, \nand writes the result to the destination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "RAX1", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110011xxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "rax1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "AES single round decryption.", 
        "title": "AESD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "D": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "AESD  <Vd>.16B, <Vn>.16B", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0100111000101000010110xxxxxxxxxx", 
                "title": "AESD"
            }
        ], 
        "file": "aesd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Move vector element to general-purpose register. This instruction reads \nthe signed integer from the source SIMD&FP register, sign-extends it to form a \n32-bit or 64-bit value, and writes the result to destination general-purpose \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMOV", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(Q == 0)", 
                        "arch": null, 
                        "asm": "SMOV  <Wd>, <Vn>.<Ts>[<index>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(Q == 1)", 
                        "arch": null, 
                        "asm": "SMOV  <Xd>, <Vn>.<Ts>[<index>]", 
                        "title": "64-reg,SMOV-64-reg"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110000xxxxx001011xxxxxxxxxx", 
                "title": "SMOV"
            }
        ], 
        "file": "smov_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Bitfield Move copies any number of low-order bits from a source \nregister into the same number of adjacent bits at any position in the \ndestination register, with zeros in the upper and lower bits. \n\nThis instruction is used by the aliases LSL (immediate), LSR (immediate), \nUBFIZ, UBFX, UXTB, and UXTH.", 
        "title": "UBFM", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "UBFM  <Wd>, <Wn>, #<immr>, #<imms>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "UBFM  <Xd>, <Xn>, #<immr>, #<imms>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "UBFM"
            }
        ], 
        "file": "ubfm.html", 
        "type": "instruction", 
        "aliases": [
            "lsl_ubfm.html", 
            "lsr_ubfm.html", 
            "ubfiz_ubfm.html", 
            "ubfx_ubfm.html", 
            "uxtb_ubfm.html", 
            "uxth_ubfm.html"
        ]
    }, 
    {
        "description": "Floating-point Maximum Pairwise (vector). This instruction creates a vector by \nconcatenating the vector elements of the first source SIMD&FP register after \nthe vector elements of the second source SIMD&FP register, reads each pair of \nadjacent vector elements from the concatenated vector, writes the larger of \neach pair of values into a vector, and writes the vector to the destination \nSIMD&FP register. All the values in this instruction are floating-point \nvalues. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAXP (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110010xxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx111101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmaxp_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Logical Shift Left (register) shifts a register value left by a variable \nnumber of bits, shifting in zeros, and writes the result to the destination \nregister. The remainder obtained by dividing the second source register by the \ndata size defines the number of bits by which the first source register is \nleft-shifted. \n\nThis is an alias of LSLV. This means: \n\n* The encodings in this description are named to match the encodings of LSLV. \n* The description of LSLV gives the operational pseudocode for this \n  instruction.", 
        "title": "LSL (register)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "LSL  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "LSL  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001000xxxxxxxxxx", 
                "title": "LSL (register)"
            }
        ], 
        "file": "lsl_lslv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register (unscaled) calculates an address from a base register and an \nimmediate offset, loads a 32-bit word or 64-bit doubleword from memory, \nzero-extends it, and writes it to a register. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "LDUR", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDUR  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x111000010xxxxxxxxx00xxxxxxxxxx", 
                "title": "LDUR"
            }
        ], 
        "file": "ldur_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply-Subtract multiplies two register values, subtracts the product from a \nthird register value, and writes the result to the destination register. \n\nThis instruction is used by the alias MNEG.", 
        "title": "MSUB", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MSUB  <Wd>, <Wn>, <Wm>, <Wa>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MSUB  <Xd>, <Xn>, <Xm>, <Xa>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011011000xxxxx1xxxxxxxxxxxxxxx", 
                "title": "MSUB"
            }
        ], 
        "file": "msub.html", 
        "type": "instruction", 
        "aliases": [
            "mneg_msub.html"
        ]
    }, 
    {
        "description": "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate \nvalue from a register value, and writes the result to the destination \nregister. It updates the condition flags based on the result. \n\nThis instruction is used by the alias CMP (immediate).", 
        "title": "SUBS (immediate)", 
        "classes": [
            {
                "fields": {
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1110001xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "SUBS (immediate)"
            }
        ], 
        "file": "subs_addsub_imm.html", 
        "type": "instruction", 
        "aliases": [
            "cmp_subs_addsub_imm.html"
        ]
    }, 
    {
        "description": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each \nsigned integer value in the vector of the source SIMD&FP register, shifts each \nvalue by an immediate value, saturates the shifted result to an unsigned \ninteger value, places the result in a vector, and writes the vector to the \ndestination SIMD&FP register. The results are truncated. For rounded results, \nsee UQRSHL. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQSHLU", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx011001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHLU  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx011001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqshlu_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Add Long to accumulator (by element). This \ninstruction multiplies the vector elements in the first source SIMD&FP \nregister by the specified value in the second source SIMD&FP register, and \naccumulates the product to the corresponding vector element of the destination \nSIMD&FP register. The instruction does not round the result of the multiply \nbefore the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLAL and FMLAL2", 
        "title": "FMLAL, FMLAL2 (by element)", 
        "classes": [
            {
                "title": "FMLAL", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011111xxxxxxx0000x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", 
                        "title": "FMLAL"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "FMLAL2", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011111xxxxxxx1000x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", 
                        "title": "FMLAL2"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "fmlal_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, toward Minus infinity (scalar). This \ninstruction rounds a floating-point value in the SIMD&FP source register to an \nintegral floating-point value of the same size using the Round towards Minus \nInfinity rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FRINTM (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "rmode": {
                        "lo": 15, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "010"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FRINTM  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FRINTM  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FRINTM  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100101010000xxxxxxxxxx", 
                "title": "FRINTM (scalar)"
            }
        ], 
        "file": "frintm_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a \n64-bit register value, and writes the result to the 64-bit destination \nregister. \n\nThis instruction is used by the alias UMULL.", 
        "title": "UMADDL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMADDL  <Xd>, <Wn>, <Wm>, <Xa>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011101xxxxx0xxxxxxxxxxxxxxx", 
                "title": "UMADDL"
            }
        ], 
        "file": "umaddl.html", 
        "type": "instruction", 
        "aliases": [
            "umull_umaddl.html"
        ]
    }, 
    {
        "description": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value \nheld in a general-purpose register. It takes an input CRC value in the first \nsource operand, performs a CRC on the input value in the second source \noperand, and returns the output CRC value. The second source operand can be 8, \n16, 32, or 64 bits. To align with common usage, the bit order of the values is \nreversed as part of the operation, and the polynomial 0x1EDC6F41 is used for \nthe CRC calculation. \n\nIn ARMv8-A, this is an optional instruction, and in ARMv8.1 it is mandatory \nfor all implementations to implement it. \n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.", 
        "title": "CRC32CB, CRC32CH, CRC32CW, CRC32CX", 
        "classes": [
            {
                "fields": {
                    "sz": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "C": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && sz == 00)", 
                        "arch": null, 
                        "asm": "CRC32CB  <Wd>, <Wn>, <Wm>", 
                        "title": "CRC32CB"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && sz == 01)", 
                        "arch": null, 
                        "asm": "CRC32CH  <Wd>, <Wn>, <Wm>", 
                        "title": "CRC32CH"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && sz == 10)", 
                        "arch": null, 
                        "asm": "CRC32CW  <Wd>, <Wn>, <Wm>", 
                        "title": "CRC32CW"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && sz == 11)", 
                        "arch": null, 
                        "asm": "CRC32CX  <Wd>, <Wn>, <Xm>", 
                        "title": "CRC32CX"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx0101xxxxxxxxxxxx", 
                "title": "CRC32CB, CRC32CH, CRC32CW, CRC32CX"
            }
        ], 
        "file": "crc32c.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory \nlocation, from a register. The instruction also has memory ordering semantics \nas described in Load-Acquire, Store-Release. For information about memory \naccesses, see Load/Store addressing modes.", 
        "title": "STLR", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STLR  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STLR  <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000100xxxxx1xxxxxxxxxxxxxxx", 
                "title": "STLR"
            }
        ], 
        "file": "stlr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit \nbyte from memory, performs a bitwise AND with the complement of the value held \nin a register on it, and stores the result back to memory. \n\n* STCLRB has no memory ordering semantics. \n* STCLRLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB. \n* The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational \n  pseudocode for this instruction.", 
        "title": "STCLRB, STCLRLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx000100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STCLRB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STCLRLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stclrb_ldclrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Shift Left Long (immediate). This instruction reads each vector \nelement in the lower or upper half of the source SIMD&FP register, shifts the \nunsigned integer value left by the specified number of bits, places the result \ninto a vector, and writes the vector to the destination SIMD&FP register. The \ndestination vector elements are twice as long as the source vector elements. \n\nThe USHLL instruction extracts vector elements from the lower half of the \nsource register, while the USHLL2 instruction extracts vector elements from \nthe upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias UXTL, UXTL2.", 
        "title": "USHLL, USHLL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx101001xxxxxxxxxx", 
                "title": "USHLL, USHLL2"
            }
        ], 
        "file": "ushll_advsimd.html", 
        "type": "instruction", 
        "aliases": [
            "uxtl_ushll_advsimd.html"
        ]
    }, 
    {
        "description": "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP \nregister from memory. The address that is used for the load is calculated from \na base register value and an offset register value. The offset can be \noptionally shifted and extended. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "LDR (register, SIMD&FP)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 00 && opc == 01 && option != 011)", 
                        "arch": null, 
                        "asm": "LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]", 
                        "title": "8-fsreg,LDR-8-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 01 && option == 011)", 
                        "arch": null, 
                        "asm": "LDR  <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", 
                        "title": "8-fsreg,LDR-8-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 01 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "16-fsreg,LDR-16-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 10 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "32-fsreg,LDR-32-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 11 && opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "64-fsreg,LDR-64-fsreg"
                    }, 
                    {
                        "bitdiff": "(size == 00 && opc == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "128-fsreg,LDR-128-fsreg"
                    }
                ], 
                "unallocated": null, 
                "mask": "xx111100x11xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDR (register, SIMD&FP)"
            }
        ], 
        "file": "ldr_reg_fpsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Duplicate vector element to vector or scalar. This instruction duplicates the \nvector element at the specified element index in the source SIMD&FP register \ninto a scalar or each element in a vector, and writes the result to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias MOV (scalar). \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "DUP (element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110000xxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DUP  <V><d>, <Vn>.<T>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110000xxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "dup_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register Byte (unscaled) calculates an address from a base register \nvalue and an immediate offset, and stores a byte to the calculated address, \nfrom a 32-bit register. For information about memory accesses, see Load/Store \naddressing modes.", 
        "title": "STURB", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STURB  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00111000000xxxxxxxxx00xxxxxxxxxx", 
                "title": "STURB"
            }
        ], 
        "file": "sturb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate \nvalue to a register. \n\nThis instruction is used by the alias MOV (inverted wide immediate).", 
        "title": "MOVN", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "hw": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MOVN  <Wd>, #<imm>{, LSL #<shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOVN  <Xd>, #<imm>{, LSL #<shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100101xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "MOVN"
            }
        ], 
        "file": "movn.html", 
        "type": "instruction", 
        "aliases": [
            "mov_movn.html"
        ]
    }, 
    {
        "description": "Instruction Cache operation. For more information, see . \n\nThis is an alias of SYS. This means: \n\n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", 
        "title": "IC", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0111"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "IC  <ic_op>{, <Xt>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101010100001xxx0111xxxxxxxxxxxx", 
                "title": "IC"
            }
        ], 
        "file": "ic_sys.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the \norder of 8-bit elements in each halfword of the vector in the source SIMD&FP \nregister, places the results into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "REV16 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "REV16  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx100000000110xxxxxxxxxx", 
                "title": "REV16 (vector)"
            }
        ], 
        "file": "rev16_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Multiply (vector). This instruction multiplies corresponding \nfloating-point values in the vectors in the two source SIMD&FP registers, \nplaces the result in a vector, and writes the vector to the destination \nSIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMUL (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110010xxxxx000111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx110111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmul_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Absolute value. This instruction reads each vector element \nfrom the source SIMD&FP register, puts the absolute value of the result into a \nvector, and writes the vector to the destination SIMD&FP register. All the \nvalues in this instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQABS", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx100000011110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQABS  <V><d>, <V><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx100000011110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQABS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqabs_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add (shifted register) adds a register value and an optionally-shifted \nregister value, and writes the result to the destination register.", 
        "title": "ADD (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0001011xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADD (shifted register)"
            }
        ], 
        "file": "add_addsub_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from \nmemory, compares it against the value held in a register, and stores the \nlarger value back to memory, treating the values as unsigned numbers. The \nvalue initially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDUMAXAB and LDUMAXALB load from \n  memory with acquire semantics. \n* LDUMAXLB and LDUMAXALB store to memory with release semantics. \n* LDUMAXB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMAXB, STUMAXLB.", 
        "title": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx011000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAXB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldumaxb.html", 
        "type": "instruction", 
        "aliases": [
            "stumaxb_ldumaxb.html"
        ]
    }, 
    {
        "description": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned \ninteger values from the vector in the source SIMD&FP register, places the \nresult into a vector, and writes the vector to the destination SIMD&FP \nregister. The destination vector elements are twice as long as the source \nvector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UADDLP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UADDLP  <Vd>.<Ta>, <Vn>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx100000001010xxxxxxxxxx", 
                "title": "UADDLP"
            }
        ], 
        "file": "uaddlp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory, \nand writes it to a register. The instruction also has memory ordering \nsemantics as described in Load LOAcquire, Store LORelease. For information \nabout memory accesses, see Load/Store addressing modes. \n\nFor this instruction, if the destination is WZR/ZXR, it is impossible for \nsoftware to observe the presence of the acquire semantic other than its effect \non the arrival at endpoints.", 
        "title": "LDLAR", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x001000110xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDLAR  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDLAR  <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldlar.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit \nword or 64-bit doubleword from memory, performs a bitwise AND with the \ncomplement of the value held in a register on it, and stores the result back \nto memory. The value initially loaded from memory is returned in the \ndestination register. \n\n* If the destination register is not one of WZR or XZR, LDCLRA and LDCLRAL \n  load from memory with acquire semantics. \n* LDCLRL and LDCLRAL store to memory with release semantics. \n* LDCLR has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STCLR, STCLRL.", 
        "title": "LDCLR, LDCLRA, LDCLRAL, LDCLRL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx000100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLR  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDCLR"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLRA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDCLRA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDCLRAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDCLRL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLR  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDCLR"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDCLRA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDCLRA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDCLRAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDCLRL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldclr.html", 
        "type": "instruction", 
        "aliases": [
            "stclr_ldclr.html"
        ]
    }, 
    {
        "description": "Move (bitmask immediate) writes a bitmask immediate value to a register. \n\nThis is an alias of ORR (immediate). This means: \n\n* The encodings in this description are named to match the encodings of ORR \n  (immediate). \n* The description of ORR (immediate) gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (bitmask immediate)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "MOV  <Wd|WSP>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOV  <Xd|SP>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x01100100xxxxxxxxxxxxx11111xxxxx", 
                "title": "MOV (bitmask immediate)"
            }
        ], 
        "file": "mov_orr_log_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Halving Subtract. This instruction subtracts the elements in the vector \nin the second source SIMD&FP register from the corresponding elements in the \nvector in the first source SIMD&FP register, shifts each result right one bit, \nplaces each result into elements of a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SHSUB", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx001001xxxxxxxxxx", 
                "title": "SHSUB"
            }
        ], 
        "file": "shsub_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "AES mix columns.", 
        "title": "AESMC", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "D": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "AESMC  <Vd>.16B, <Vn>.16B", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0100111000101000011010xxxxxxxxxx", 
                "title": "AESMC"
            }
        ], 
        "file": "aesmc_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Maximum Pairwise. This instruction creates a vector by concatenating \nthe vector elements of the first source SIMD&FP register after the vector \nelements of the second source SIMD&FP register, reads each pair of adjacent \nvector elements in the two source SIMD&FP registers, writes the largest of \neach pair of signed integer values into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMAXP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx101001xxxxxxxxxx", 
                "title": "SMAXP"
            }
        ], 
        "file": "smaxp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar). \nThis instruction converts the floating-point value in the SIMD&FP source \nregister to a 32-bit or 64-bit unsigned integer using the Round towards Zero \nrounding mode, and writes the result to the general-purpose destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTZU (scalar, integer)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZU  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTZU  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTZU  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx111001000000xxxxxxxxxx", 
                "title": "FCVTZU (scalar, integer)"
            }
        ], 
        "file": "fcvtzu_float_int.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to lower precision Narrow, rounding to odd (vector). \nThis instruction reads each vector element in the source SIMD&FP register, \nnarrows each value to half the precision of the source element using the Round \nto Odd rounding mode, writes the result to a vector, and writes the vector to \nthe destination SIMD&FP register. \n\nThis instruction uses the Round to Odd rounding mode which is not defined by \nthe IEEE 754-2008 standard. This rounding mode ensures that if the result of \nthe conversion is inexact the least significant bit of the mantissa is forced \nto 1. This rounding mode enables a floating-point value to be converted to a \nlower precision format via an intermediate precision format while avoiding \ndouble rounding errors. For example, a 64-bit floating-point value can be \nconverted to a correctly rounded 16-bit floating-point value by first using \nthis instruction to produce a 32-bit value and then using another instruction \nwith the wanted rounding mode to convert the 32-bit value to the final 16-bit \nfloating-point value. \n\nThe FCVTXN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the FCVTXN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "FCVTXN, FCVTXN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x100001011010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTXN  <Vb><d>, <Va><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x100001011010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtxn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Hint instruction is for the instruction set space that is reserved for \narchitectural hint instructions. \n\nSome encodings described here are not allocated in this revision of the \narchitecture, and behave as NOPs. These encodings might be allocated to other \nhint functionality in future revisions of the architecture and therefore must \nnot be used by software.", 
        "title": "HINT", 
        "classes": [
            {
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(CRm == 0000 && op2 == 11x)", 
                        "arch": null, 
                        "asm": "HINT  #<imm>", 
                        "title": "Hints 6 and 7"
                    }, 
                    {
                        "bitdiff": "(CRm != 00x0)", 
                        "arch": null, 
                        "asm": "HINT  #<imm>", 
                        "title": "Hints 8 to 15, and 24 to 127"
                    }, 
                    {
                        "bitdiff": "(CRm == 0010 && op2 != 00x)", 
                        "arch": null, 
                        "asm": "HINT  #<imm>", 
                        "title": "Hints 18 to 23"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110010xxxxxxx11111", 
                "title": "HINT"
            }
        ], 
        "file": "hint.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Divide divides an unsigned integer register value by another unsigned \ninteger register value, and writes the result to the destination register. The \ncondition flags are not affected.", 
        "title": "UDIV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "o1": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "UDIV  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "UDIV  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx000010xxxxxxxxxx", 
                "title": "UDIV"
            }
        ], 
        "file": "udiv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or \n64-bit doubleword from memory, adds the value held in a register to it, and \nstores the result back to memory. The value initially loaded from memory is \nreturned in the destination register. \n\n* If the destination register is not one of WZR or XZR, LDADDA and LDADDAL \n  load from memory with acquire semantics. \n* LDADDL and LDADDAL store to memory with release semantics. \n* LDADD has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STADD, STADDL.", 
        "title": "LDADD, LDADDA, LDADDAL, LDADDL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx000000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADD  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDADD"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADDA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDADDA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDADDAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDADDL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADD  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDADD"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADDA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDADDA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDADDAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDADDL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldadd.html", 
        "type": "instruction", 
        "aliases": [
            "stadd_ldadd.html"
        ]
    }, 
    {
        "description": "SHA1 hash update (majority).", 
        "title": "SHA1M", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA1M  <Qd>, <Sn>, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx001000xxxxxxxxxx", 
                "title": "SHA1M"
            }
        ], 
        "file": "sha1m_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move vector. This instruction copies the vector in the source SIMD&FP register \ninto the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of ORR (vector, register). This means: \n\n* The encodings in this description are named to match the encodings of ORR \n  (vector, register). \n* The description of ORR (vector, register) gives the operational pseudocode \n  for this instruction.", 
        "title": "MOV (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MOV  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110101xxxxx000111xxxxxxxxxx", 
                "title": "MOV (vector)"
            }
        ], 
        "file": "mov_orr_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load single 4-element structure and Replicate to all lanes of four registers. \nThis instruction loads a 4-element structure from memory and replicates the \nstructure to all the lanes of the four SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "LD4R", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101011000001110xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101111xxxxx1110xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ld4r_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP \nregister and a 128-bit constant from the second SIMD&FP register. It derives \nfour iterations of the output key, in accordance with the SM4 standard, \nreturning the 128-bit result to the destination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM4EKEY", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110011xxxxx110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm4ekey_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic exclusive OR on halfword in memory, without return, atomically loads a \n16-bit halfword from memory, performs an exclusive OR with the value held in a \nregister on it, and stores the result back to memory. \n\n* STEORH has no memory ordering semantics. \n* STEORLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDEORH, LDEORAH, LDEORALH, LDEORLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDEORH, LDEORAH, LDEORALH, LDEORLH. \n* The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational \n  pseudocode for this instruction.", 
        "title": "STEORH, STEORLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx001000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STEORH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STEORLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "steorh_ldeorh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Polynomial Multiply Long. This instruction multiplies corresponding elements \nin the lower or upper half of the vectors of the two source SIMD&FP registers, \nplaces the results in a vector, and writes the vector to the destination \nSIMD&FP register. The destination vector elements are twice as long as the \nelements that are multiplied. \n\nFor information about multiplying polynomials see Polynomial arithmetic over \n{0, 1}. \n\nThe PMULL instruction extracts each source vector from the lower half of each \nsource register, while the PMULL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "PMULL, PMULL2", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx111000xxxxxxxxxx", 
                "title": "PMULL, PMULL2"
            }
        ], 
        "file": "pmull_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare Negative (shifted register) adds a register value and an \noptionally-shifted register value. It updates the condition flags based on the \nresult, and discards the result. \n\nThis is an alias of ADDS (shifted register). This means: \n\n* The encodings in this description are named to match the encodings of ADDS \n  (shifted register). \n* The description of ADDS (shifted register) gives the operational pseudocode \n  for this instruction.", 
        "title": "CMN (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CMN  <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CMN  <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101011xx0xxxxxxxxxxxxxxxx11111", 
                "title": "CMN (shifted register)"
            }
        ], 
        "file": "cmn_adds_addsub_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Subtract (scalar). This instruction subtracts the \nfloating-point value of the second source SIMD&FP register from the \nfloating-point value of the first source SIMD&FP register, and writes the \nresult to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FSUB (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FSUB  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FSUB  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FSUB  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx001110xxxxxxxxxx", 
                "title": "FSUB (scalar)"
            }
        ], 
        "file": "fsub_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Minimum across Vector. This instruction compares all the vector \nelements in the source SIMD&FP register, and writes the smallest of the values \nas a scalar to the destination SIMD&FP register. All the values in this \ninstruction are signed integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMINV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMINV  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx110001101010xxxxxxxxxx", 
                "title": "SMINV"
            }
        ], 
        "file": "sminv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to \neven (scalar). This instruction converts the floating-point value in the \nSIMD&FP source register to a 32-bit or 64-bit signed integer using the Round \nto Nearest rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTNS (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTNS  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTNS  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTNS  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTNS  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTNS  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTNS  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx100000000000xxxxxxxxxx", 
                "title": "FCVTNS (scalar)"
            }
        ], 
        "file": "fcvtns_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction \nreads each signed integer value in the vector of the source SIMD&FP register, \nright shifts each value by an immediate value, saturates the result to an \nunsigned integer value that is half the original width, places the final \nresult into a vector, and writes the vector to the destination SIMD&FP \nregister. The results are truncated. For rounded results, see SQRSHRUN. \n\nThe SQSHRUN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the SQSHRUN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQSHRUN, SQSHRUN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHRUN  <Vb><d>, <Va><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqshrun_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic add on word or doubleword in memory, without return, atomically loads a \n32-bit word or 64-bit doubleword from memory, adds the value held in a \nregister to it, and stores the result back to memory. \n\n* STADD has no memory ordering semantics. \n* STADDL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDADD, LDADDA, LDADDAL, LDADDL. This means: \n\n* The encodings in this description are named to match the encodings of LDADD, \n  LDADDA, LDADDAL, LDADDL. \n* The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational \n  pseudocode for this instruction.", 
        "title": "STADD, STADDL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx000000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STADD  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDADD alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STADDL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDADDL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STADD  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDADD alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STADDL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDADDL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stadd_ldadd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Swap halfword in memory atomically loads a 16-bit halfword from a memory \nlocation, and stores the value held in a register back to the same memory \nlocation. The value initially loaded from memory is returned in the \ndestination register. \n\n* If the destination register is not WZR, SWPAH and SWPALH load from memory \n  with acquire semantics. \n* SWPLH and SWPALH store to memory with release semantics. \n* SWPH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes.", 
        "title": "SWPH, SWPAH, SWPALH, SWPLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx100000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "SWPAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "SWPH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "swph.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply Long (by element). This instruction \nmultiplies each vector element in the lower or upper half of the first source \nSIMD&FP register by the specified vector element of the second source SIMD&FP \nregister, doubles the results, places the final results in a vector, and \nwrites the vector to the destination SIMD&FP register. All the values in this \ninstruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMULL instruction extracts the first source vector from the lower half \nof the first source register, while the SQDMULL2 instruction extracts the \nfirst source vector from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMULL, SQDMULL2 (by element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011111xxxxxxxx1011x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx1011x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmull_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store single 3-element structure from one lane of three registers. This \ninstruction stores a 3-element structure to memory from corresponding elements \nof three SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST3 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110100000000xx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 001)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101100xxxxxxx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st3_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Breakpoint instruction generates a Breakpoint Instruction exception. The PE \nrecords the exception in ESR_ELx, using the EC value 0x3c, and captures the \nvalue of the immediate argument in ESR_ELx.ISS.", 
        "title": "BRK", 
        "classes": [
            {
                "fields": {
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BRK  #<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100001xxxxxxxxxxxxxxxx00000", 
                "title": "BRK"
            }
        ], 
        "file": "brk.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Test bit and Branch if Nonzero compares the value of a bit in a \ngeneral-purpose register with zero, and conditionally branches to a label at a \nPC-relative offset if the comparison is not equal. It provides a hint that \nthis is not a subroutine call or return. This instruction does not affect \ncondition flags.", 
        "title": "TBNZ", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "b5": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "b40": {
                        "lo": 19, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm14": {
                        "lo": 5, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "TBNZ  <R><t>, #<imm>, <label>", 
                        "title": "14-bit signed PC-relative branch offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0110111xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "TBNZ"
            }
        ], 
        "file": "tbnz.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store-Release Exclusive Pair of registers stores two 32-bit words or two \n64-bit doublewords to a memory location if the PE has exclusive access to the \nmemory address, from two registers, and returns a status value of 0 if the \nstore was successful, or of 1 if no store was performed. See Synchronization \nand semaphores. A 32-bit pair requires the address to be doubleword aligned \nand is single-copy atomic at doubleword granularity. A 64-bit pair requires \nthe address to be quadword aligned and, if the Store-Exclusive succeeds, it \ncauses a single-copy atomic update of the 128-bit memory location being \nupdated. The instruction also has memory ordering semantics as described in \nLoad-Acquire, Store-Release. For information about memory accesses see \nLoad/Store addressing modes.", 
        "title": "STLXP", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sz == 0)", 
                        "arch": null, 
                        "asm": "STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sz == 1)", 
                        "arch": null, 
                        "asm": "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000001xxxxx1xxxxxxxxxxxxxxx", 
                "title": "STLXP"
            }
        ], 
        "file": "stlxp.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit clear on halfword in memory, without return, atomically loads a \n16-bit halfword from memory, performs a bitwise AND with the complement of the \nvalue held in a register on it, and stores the result back to memory. \n\n* STCLRH has no memory ordering semantics. \n* STCLRLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH. \n* The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational \n  pseudocode for this instruction.", 
        "title": "STCLRH, STCLRLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx000100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STCLRH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STCLRLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stclrh_ldclrh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse elements in 32-bit words (vector). This instruction reverses the order \nof 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP \nregister, places the results into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "REV32 (vector)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "REV32  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx100000000010xxxxxxxxxx", 
                "title": "REV32 (vector)"
            }
        ], 
        "file": "rev32_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "AES single round encryption.", 
        "title": "AESE", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "D": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "AESE  <Vd>.16B, <Vn>.16B", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0100111000101000010010xxxxxxxxxx", 
                "title": "AESE"
            }
        ], 
        "file": "aese_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed fixed-point Convert to Floating-point (vector). This instruction \nconverts each element in a vector from fixed-point to floating-point using the \nrounding mode that is specified by the FPCR, and writes the result to the \nSIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SCVTF (vector, fixed-point)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SCVTF  <V><d>, <V><n>, #<fbits>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "scvtf_advsimd_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned saturating Shift Left (register). This instruction takes each element \nin the vector of the first source SIMD&FP register, shifts the element by a \nvalue from the least significant byte of the corresponding element of the \nsecond source SIMD&FP register, places the results in a vector, and writes the \nvector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it \nis a right shift. The results are truncated. For rounded results, see UQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQSHL (register)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx010011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx010011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqshl_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Negate returns, in the destination register, the negated value of \nthe source register if the condition is TRUE, and otherwise returns the value \nof the source register. \n\nThis is an alias of CSNEG. This means: \n\n* The encodings in this description are named to match the encodings of CSNEG. \n* The description of CSNEG gives the operational pseudocode for this \n  instruction.", 
        "title": "CNEG", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "!=", 
                        "value": "111x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CNEG  <Wd>, <Wn>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CNEG  <Xd>, <Xn>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx"
                ], 
                "mask": "x1011010100xxxxxxxxx01xxxxxxxxxx", 
                "title": "CNEG"
            }
        ], 
        "file": "cneg_csneg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract (shifted register) subtracts an optionally-shifted register value \nfrom a register value, and writes the result to the destination register. \n\nThis instruction is used by the alias NEG (shifted register).", 
        "title": "SUB (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1001011xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "SUB (shifted register)"
            }
        ], 
        "file": "sub_addsub_shift.html", 
        "type": "instruction", 
        "aliases": [
            "neg_sub_addsub_shift.html"
        ]
    }, 
    {
        "description": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of \nadjacent signed integer values from the vector in the source SIMD&FP register \nand accumulates the results into the vector elements of the destination \nSIMD&FP register. The destination vector elements are twice as long as the \nsource vector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SADALP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SADALP  <Vd>.<Ta>, <Vn>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx100000011010xxxxxxxxxx", 
                "title": "SADALP"
            }
        ], 
        "file": "sadalp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Complex Add. \n\nThis instruction operates on complex numbers that are represented in SIMD&FP \nregisters as pairs of elements, with the more significant element holding the \nimaginary part of the number and the less significant element holding the real \npart of the number. Each element holds a floating-point value. It performs the \nfollowing computation on the corresponding complex number element pairs from \nthe two source registers: \n\n* Considering the complex number from the second source register on an Argand \n  diagram, the number is rotated counterclockwise by 90 or 270 degrees. \n* The rotated complex number is added to the complex number from the first \n  source register. \nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCADD", 
        "classes": [
            {
                "title": "Three registers of the same type", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "rot": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx0xxxxx111x01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "fcadd_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Data Cache operation. For more information, see . \n\nThis is an alias of SYS. This means: \n\n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", 
        "title": "DC", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0111"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DC  <dc_op>, <Xt>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101010100001xxx0111xxxxxxxxxxxx", 
                "title": "DC"
            }
        ], 
        "file": "dc_sys.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move vector element to another vector element. This instruction copies the \nvector element of the source SIMD&FP register to the specified vector element \nof the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP \nregister without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of INS (element). This means: \n\n* The encodings in this description are named to match the encodings of INS \n  (element). \n* The description of INS (element) gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm4": {
                        "lo": 11, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01101110000xxxxx0xxxx1xxxxxxxxxx", 
                "title": "MOV (element)"
            }
        ], 
        "file": "mov_ins_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse Bytes reverses the byte order in a register. \n\nThis instruction is used by the pseudo-instruction REV64.", 
        "title": "REV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && opc == 10)", 
                        "arch": null, 
                        "asm": "REV  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && opc == 11)", 
                        "arch": null, 
                        "asm": "REV  <Xd>, <Xn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10110101100000000001xxxxxxxxxxx", 
                "title": "REV"
            }
        ], 
        "file": "rev.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare signed Less than zero (vector). This instruction reads each vector \nelement in the source SIMD&FP register and if the signed integer value is less \nthan zero sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to one, otherwise sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMLT (zero)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx100000101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMLT  <V><d>, <V><n>, #0", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx100000101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMLT  <Vd>.<T>, <Vn>.<T>, #0", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmlt_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit \nword or 64-bit doubleword from memory, performs an exclusive OR with the value \nheld in a register on it, and stores the result back to memory. The value \ninitially loaded from memory is returned in the destination register. \n\n* If the destination register is not one of WZR or XZR, LDEORA and LDEORAL \n  load from memory with acquire semantics. \n* LDEORL and LDEORAL store to memory with release semantics. \n* LDEOR has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STEOR, STEORL.", 
        "title": "LDEOR, LDEORA, LDEORAL, LDEORL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "010"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx001000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEOR  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDEOR"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEORA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDEORA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDEORAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDEORL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEOR  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDEOR"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDEORA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDEORA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDEORAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDEORL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDEORL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldeor.html", 
        "type": "instruction", 
        "aliases": [
            "steor_ldeor.html"
        ]
    }, 
    {
        "description": "Load Register Signed Word (literal) calculates an address from the PC value \nand an immediate offset, loads a word from memory, and writes it to a \nregister. For information about memory accesses, see Load/Store addressing \nmodes.", 
        "title": "LDRSW (literal)", 
        "classes": [
            {
                "fields": {
                    "imm19": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "10"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDRSW  <Xt>, <label>", 
                        "title": "Literal"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011000xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "LDRSW (literal)"
            }
        ], 
        "file": "ldrsw_lit.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply-Subtract from accumulator (vector, by element). This instruction \nmultiplies the vector elements in the first source SIMD&FP register by the \nspecified value in the second source SIMD&FP register, and subtracts the \nresults from the vector elements of the destination SIMD&FP register. All the \nvalues in this instruction are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MLS (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx0100x0xxxxxxxxxx", 
                "title": "MLS (by element)"
            }
        ], 
        "file": "mls_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum Number (vector). This instruction compares \ncorresponding vector elements in the two source SIMD&FP registers, writes the \nlarger of the two floating-point values into a vector, and writes the vector \nto the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result placed in the \nvector is the numerical value, otherwise the result is identical to FMAX \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAXNM (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "a": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110010xxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx110001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmaxnm_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Form PC-relative address adds an immediate value to the PC value to form a \nPC-relative address, and writes the result to the destination register.", 
        "title": "ADR", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immlo": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "immhi": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "op": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADR  <Xd>, <label>", 
                        "title": "Literal"
                    }
                ], 
                "unallocated": null, 
                "mask": "0xx10000xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADR"
            }
        ], 
        "file": "adr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Logical Shift Right (immediate) shifts a register value right by an immediate \nnumber of bits, shifting in zeros, and writes the result to the destination \nregister. \n\nThis is an alias of UBFM. This means: \n\n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "LSR (immediate)", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "x11111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0 && imms == 011111)", 
                        "arch": null, 
                        "asm": "LSR  <Wd>, <Wn>, #<shift>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1 && imms == 111111)", 
                        "arch": null, 
                        "asm": "LSR  <Xd>, <Xn>, #<shift>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10100110xxxxxxxx11111xxxxxxxxxx", 
                "title": "LSR (immediate)"
            }
        ], 
        "file": "lsr_ubfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Greater than or Equal to zero (vector). This \ninstruction reads each floating-point value in the source SIMD&FP register and \nif the value is greater than or equal to zero sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to one, \notherwise sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMGE (zero)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111011111000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <Hd>, <Hn>, #0.0", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x100000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <V><d>, <V><n>, #0.0", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmge_advsimd_zero.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit \nregister value, and writes the result to the 64-bit destination register. \n\nThis instruction is used by the alias SMULL.", 
        "title": "SMADDL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMADDL  <Xd>, <Wn>, <Wm>, <Xa>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011001xxxxx0xxxxxxxxxxxxxxx", 
                "title": "SMADDL"
            }
        ], 
        "file": "smaddl.html", 
        "type": "instruction", 
        "aliases": [
            "smull_smaddl.html"
        ]
    }, 
    {
        "description": "Compare (shifted register) subtracts an optionally-shifted register value from \na register value. It updates the condition flags based on the result, and \ndiscards the result. \n\nThis is an alias of SUBS (shifted register). This means: \n\n* The encodings in this description are named to match the encodings of SUBS \n  (shifted register). \n* The description of SUBS (shifted register) gives the operational pseudocode \n  for this instruction.", 
        "title": "CMP (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CMP  <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CMP  <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101011xx0xxxxxxxxxxxxxxxx11111", 
                "title": "CMP (shifted register)"
            }
        ], 
        "file": "cmp_subs_addsub_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Strip Pointer Authentication Code. This instruction removes the pointer \nauthentication code from an address. The address is in the specified \ngeneral-purpose register for XPACI and XPACD, and is in LR for XPACLRI. \n\nThe XPACD instruction is used for data addresses, and XPACI and XPACLRI are \nused for instruction addresses. \n\nIt has encodings from 2 classes: Integer and System", 
        "title": "XPACD, XPACI, XPACLRI", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "D": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000101000x11111xxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(D == 1)", 
                        "arch": null, 
                        "asm": "XPACD  <Xd>", 
                        "title": "XPACD"
                    }, 
                    {
                        "bitdiff": "(D == 0)", 
                        "arch": null, 
                        "asm": "XPACI  <Xd>", 
                        "title": "XPACI"
                    }
                ], 
                "arch": "ARMv8.3"
            }, 
            {
                "title": "System", 
                "fields": {}, 
                "unallocated": null, 
                "mask": "11010101000000110010000011111111", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "XPACLRI", 
                        "title": "System"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "xpac.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of \nthe register, and writes the result to the destination register. \n\nThis is an alias of SBFM. This means: \n\n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "SXTH", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "001111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "000000"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "SXTH  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "SXTH  <Xd>, <Wn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100110x000000001111xxxxxxxxxx", 
                "title": "SXTH"
            }
        ], 
        "file": "sxth_sbfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector \nelement from the source SIMD&FP register, calculates an approximate inverse \nsquare root for each value, places the result into a vector, and writes the \nvector to the destination SIMD&FP register. All the values in this instruction \nare unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "URSQRTE", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URSQRTE  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x1011101x100001110010xxxxxxxxxx", 
                "title": "URSQRTE"
            }
        ], 
        "file": "ursqrte_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Reciprocal Square Root Step. This instruction multiplies \ncorresponding floating-point values in the vectors of the two source SIMD&FP \nregisters, subtracts each of the products from 3.0, divides these results by \n2.0, places the results into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FRSQRTS", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110110xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTS  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x1xxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTS  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110110xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x1xxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frsqrts_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Rounding Shift Left (register). This instruction takes each signed \ninteger value in the vector of the first source SIMD&FP register, shifts it by \na value from the least significant byte of the corresponding element of the \nsecond source SIMD&FP register, places the results in a vector, and writes the \nvector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift \nvalue is negative, it is a rounding right shift. For a truncating shift, see \nSSHL. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SRSHL", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRSHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "srshl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds \nthe value held in a register to it, and stores the result back to memory. The \nvalue initially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDADDAB and LDADDALB load from \n  memory with acquire semantics. \n* LDADDLB and LDADDALB store to memory with release semantics. \n* LDADDB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STADDB, STADDLB.", 
        "title": "LDADDB, LDADDAB, LDADDALB, LDADDLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx000000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADDAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADDB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldaddb.html", 
        "type": "instruction", 
        "aliases": [
            "staddb_ldaddb.html"
        ]
    }, 
    {
        "description": "Unsigned saturating Subtract. This instruction subtracts the element values of \nthe second source SIMD&FP register from the corresponding element values of \nthe first source SIMD&FP register, places the results into a vector, and \nwrites the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQSUB", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSUB  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx001011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqsub_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Multiply-Negate (scalar). This instruction multiplies the \nfloating-point values of the two source SIMD&FP registers, and writes the \nnegation of the result to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FNMUL (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FNMUL  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FNMUL  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FNMUL  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx100010xxxxxxxxxx", 
                "title": "FNMUL (scalar)"
            }
        ], 
        "file": "fnmul_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum Number across Vector. This instruction compares all the \nvector elements in the source SIMD&FP register, and writes the smallest of the \nvalues as a scalar to the destination SIMD&FP register. All the values in this \ninstruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result of the comparison \nis the numerical value, otherwise the result is identical to FMIN (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMINNMV", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111010110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNMV  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNMV  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fminnmv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads \neach vector element in the source SIMD&FP register, right shifts each result \nby an immediate value, saturates each shifted result to a value that is half \nthe original width, puts the final result into a vector, and writes the vector \nto the lower or upper half of the destination SIMD&FP register. All the values \nin this instruction are unsigned integer values. The results are truncated. \nFor rounded results, see UQRSHRN. \n\nThe UQSHRN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the UQSHRN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "UQSHRN, UQSHRN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx100101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSHRN  <Vb><d>, <Va><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx100101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "uqshrn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare unsigned Higher or Same (vector). This instruction compares each \nvector element in the first source SIMD&FP register with the corresponding \nvector element in the second source SIMD&FP register and if the first unsigned \ninteger value is greater than or equal to the second unsigned integer value \nsets every bit of the corresponding vector element in the destination SIMD&FP \nregister to one, otherwise sets every bit of the corresponding vector element \nin the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMHS (register)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMHS  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "eq": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx001111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmhs_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add (extended register) adds a register value and a sign or zero-extended \nregister value, followed by an optional left shift amount, and writes the \nresult to the destination register. The argument that is extended from the \n<Rm> register can be a byte, halfword, word, or doubleword.", 
        "title": "ADD (extended register)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm3": {
                        "lo": 10, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0001011001xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADD (extended register)"
            }
        ], 
        "file": "add_addsub_ext.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Shift Right (immediate). This instruction reads each vector element \nin the source SIMD&FP register, right shifts each result by an immediate \nvalue, writes the final result to a vector, and writes the vector to the \ndestination SIMD&FP register. All the values in this instruction are unsigned \ninteger values. The results are truncated. For rounded results, see URSHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "USHR", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USHR  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ushr_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply-Subtract Long (by element). This \ninstruction multiplies each vector element in the lower or upper half of the \nfirst source SIMD&FP register by the specified vector element of the second \nsource SIMD&FP register, doubles the results, and subtracts the final results \nfrom the vector elements of the destination SIMD&FP register. The destination \nvector elements are twice as long as the elements that are multiplied. All the \nvalues in this instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLSL instruction extracts vector elements from the lower half of the \nfirst source register, while the SQDMLSL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMLSL, SQDMLSL2 (by element)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011111xxxxxxxx0111x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx0111x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmlsl_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Absolute Difference (vector). This instruction subtracts the elements \nof the vector of the second source SIMD&FP register from the corresponding \nelements of the first source SIMD&FP register, places the the absolute values \nof the results into a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UABD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx011101xxxxxxxxxx", 
                "title": "UABD"
            }
        ], 
        "file": "uabd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Debug Change PE State to EL2, when executed in Debug state: \n\n* If executed at EL0 or EL1 changes the current Exception level and SP to EL2 \n  using SP_EL2. \n* Otherwise, if executed at ELx, selects SP_ELx. \nThe target exception level of a DCPS2 instruction is: \n\n* EL2 if the instruction is executed at an exception level that is not EL3. \n* EL3 if the instruction is executed at EL3. \nWhen the target Exception level of a DCPS2 instruction is ELx, on executing \nthis instruction: \n\n* ELR_ELx becomes unknown. \n* SPSR_ELx becomes unknown. \n* ESR_ELx becomes unknown. \n* DLR_EL0 and DSPSR_EL0 become unknown. \n* The endianness is set according to SCTLR_ELx.EE. \nThis instruction is undefined at the following exception levels: \n\n* All exception levels if EL2 is not implemented. \n* At EL0 and EL1 in Secure state if EL2 is implemented. \nThis instruction is always undefined in Non-debug state. \n\nFor more information on the operation of the DCPSn instructions, see DCPS.", 
        "title": "DCPS2", 
        "classes": [
            {
                "fields": {
                    "LL": {
                        "lo": 0, 
                        "hi": 1, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DCPS2  {#<imm>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100101xxxxxxxxxxxxxxxx00010", 
                "title": "DCPS2"
            }
        ], 
        "file": "dcps2.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to lower precision Narrow (vector). This instruction \nreads each vector element in the SIMD&FP source register, converts each result \nto half the precision of the source element, writes the final result to a \nvector, and writes the vector to the lower or upper half of the destination \nSIMD&FP register. The destination vector elements are half as long as the \nsource vector elements. The rounding mode is determined by the FPCR. \n\nThe FCVTN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the FCVTN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in FPSR \nor a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped.", 
        "title": "FCVTN, FCVTN2", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x0011100x100001011010xxxxxxxxxx", 
                "title": "FCVTN, FCVTN2"
            }
        ], 
        "file": "fcvtn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Pointer Authentication Code for Data address, using key B. This instruction \ncomputes and inserts a pointer authentication code for a data address, using a \nmodifier and key B. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACDB. \n* The value zero, for PACDZB.", 
        "title": "PACDB, PACDZB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "PACDB  <Xd>, <Xn|SP>", 
                        "title": "PACDB"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "PACDZB  <Xd>", 
                        "title": "PACDZB"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "pacdb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP \nsource register to a 32-bit or 64-bit unsigned integer using the Round towards \nPlus Infinity rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTPU (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTPU  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTPU  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTPU  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTPU  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTPU  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTPU  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx101001000000xxxxxxxxxx", 
                "title": "FCVTPU (scalar)"
            }
        ], 
        "file": "fcvtpu_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register Halfword (register) calculates an address from a base register \nvalue and an offset register value, and stores a halfword from a 32-bit \nregister to the calculated address. For information about memory accesses, see \nLoad/Store addressing modes. \n\nThe instruction uses an offset addressing mode, that calculates the address \nused for the memory access from a base register value and an offset register \nvalue. The offset can be optionally shifted and extended.", 
        "title": "STRH (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "32-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "01111000001xxxxxxxxx10xxxxxxxxxx", 
                "title": "STRH (register)"
            }
        ], 
        "file": "strh_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of \nadjacent unsigned integer values from the vector in the source SIMD&FP \nregister and accumulates the results with the vector elements of the \ndestination SIMD&FP register. The destination vector elements are twice as \nlong as the source vector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UADALP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UADALP  <Vd>.<Ta>, <Vn>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx100000011010xxxxxxxxxx", 
                "title": "UADALP"
            }
        ], 
        "file": "uadalp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Rounding Add returning High Narrow. This instruction adds each vector element \nin the first source SIMD&FP register to the corresponding vector element in \nthe second source SIMD&FP register, places the most significant half of the \nresult into a vector, and writes the vector to the lower or upper half of the \ndestination SIMD&FP register. \n\nThe results are rounded. For truncated results, see ADDHN. \n\nThe RADDHN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the RADDHN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "RADDHN, RADDHN2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx010000xxxxxxxxxx", 
                "title": "RADDHN, RADDHN2"
            }
        ], 
        "file": "raddhn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Negate. This instruction reads each vector element from the \nsource SIMD&FP register, negates each value, places the result into a vector, \nand writes the vector to the destination SIMD&FP register. All the values in \nthis instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQNEG", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx100000011110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQNEG  <V><d>, <V><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx100000011110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQNEG  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqneg_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it, \nand writes the result to a register. The address that is used for the load is \ncalculated from a base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "LDTRB", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00111000010xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDTRB"
            }
        ], 
        "file": "ldtrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Equal (vector). This instruction compares each \nfloating-point value from the first source SIMD&FP register, with the \ncorresponding floating-point value from the second source SIMD&FP register, \nand if the comparison is equal sets every bit of the corresponding vector \nelement in the destination SIMD&FP register to one, otherwise sets every bit \nof the corresponding vector element in the destination SIMD&FP register to \nzero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMEQ (register)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110010xxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111100x1xxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110010xxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmeq_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic bit clear on word or doubleword in memory, without return, atomically \nloads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND \nwith the complement of the value held in a register on it, and stores the \nresult back to memory. \n\n* STCLR has no memory ordering semantics. \n* STCLRL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDCLR, LDCLRA, LDCLRAL, LDCLRL. This means: \n\n* The encodings in this description are named to match the encodings of LDCLR, \n  LDCLRA, LDCLRAL, LDCLRL. \n* The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational \n  pseudocode for this instruction.", 
        "title": "STCLR, STCLRL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx000100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STCLR  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDCLR alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STCLRL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDCLRL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STCLR  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDCLR alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STCLRL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDCLRL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stclr_ldclr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from \nmemory, compares it against the value held in a register, and stores the \nlarger value back to memory, treating the values as signed numbers. The value \ninitially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, LDSMAXAB and LDSMAXALB load from \n  memory with acquire semantics. \n* LDSMAXLB and LDSMAXALB store to memory with release semantics. \n* LDSMAXB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMAXB, STSMAXLB.", 
        "title": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx010000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDSMAXB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDSMAXLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldsmaxb.html", 
        "type": "instruction", 
        "aliases": [
            "stsmaxb_ldsmaxb.html"
        ]
    }, 
    {
        "description": "Unsigned Move vector element to general-purpose register. This instruction \nreads the unsigned integer from the source SIMD&FP register, zero-extends it \nto form a 32-bit or 64-bit value, and writes the result to the destination \ngeneral-purpose register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis instruction is used by the alias MOV (to general).", 
        "title": "UMOV", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(Q == 0)", 
                        "arch": null, 
                        "asm": "UMOV  <Wd>, <Vn>.<Ts>[<index>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(Q == 1 && imm5 == x1000)", 
                        "arch": null, 
                        "asm": "UMOV  <Xd>, <Vn>.<Ts>[<index>]", 
                        "title": "64-reg,UMOV-64-reg"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110000xxxxx001111xxxxxxxxxx", 
                "title": "UMOV"
            }
        ], 
        "file": "umov_advsimd.html", 
        "type": "instruction", 
        "aliases": [
            "mov_umov_advsimd.html"
        ]
    }, 
    {
        "description": "Form PC-relative address to 4KB page adds an immediate value that is shifted \nleft by 12 bits, to the PC value to form a PC-relative address, with the \nbottom 12 bits masked out, and writes the result to the destination register.", 
        "title": "ADRP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immlo": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "immhi": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "op": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADRP  <Xd>, <label>", 
                        "title": "Literal"
                    }
                ], 
                "unallocated": null, 
                "mask": "1xx10000xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADRP"
            }
        ], 
        "file": "adrp.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum across Vector. This instruction compares all the vector \nelements in the source SIMD&FP register, and writes the largest of the values \nas a scalar to the destination SIMD&FP register. All the values in this \ninstruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAXV", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111000110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXV  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXV  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmaxv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Logical Shift Right (register) shifts a register value right by a variable \nnumber of bits, shifting in zeros, and writes the result to the destination \nregister. The remainder obtained by dividing the second source register by the \ndata size defines the number of bits by which the first source register is \nright-shifted. \n\nThis is an alias of LSRV. This means: \n\n* The encodings in this description are named to match the encodings of LSRV. \n* The description of LSRV gives the operational pseudocode for this \n  instruction.", 
        "title": "LSR (register)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "LSR  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "LSR  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001001xxxxxxxxxx", 
                "title": "LSR (register)"
            }
        ], 
        "file": "lsr_lsrv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Exclusive Pair of Registers derives an address from a base register \nvalue, loads two 32-bit words or two 64-bit doublewords from memory, and \nwrites them to two registers. A 32-bit pair requires the address to be \ndoubleword aligned and is single-copy atomic at doubleword granularity. A \n64-bit pair requires the address to be quadword aligned and is single-copy \natomic for each doubleword at doubleword granularity. The PE marks the \nphysical address being accessed as an exclusive access. This exclusive access \nmark is checked by Store Exclusive instructions. See Synchronization and \nsemaphores. For information about memory accesses see Load/Store addressing \nmodes.", 
        "title": "LDXP", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sz == 0)", 
                        "arch": null, 
                        "asm": "LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sz == 1)", 
                        "arch": null, 
                        "asm": "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000011xxxxx0xxxxxxxxxxxxxxx", 
                "title": "LDXP"
            }
        ], 
        "file": "ldxp.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned minimum on word or doubleword in memory atomically loads a \n32-bit word or 64-bit doubleword from memory, compares it against the value \nheld in a register, and stores the smaller value back to memory, treating the \nvalues as unsigned numbers. The value initially loaded from memory is returned \nin the destination register. \n\n* If the destination register is not one of WZR or XZR, LDUMINA and LDUMINAL \n  load from memory with acquire semantics. \n* LDUMINL and LDUMINAL store to memory with release semantics. \n* LDUMIN has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMIN, STUMINL.", 
        "title": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx011100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMIN  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMIN"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMINA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMINA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMINAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMINL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMIN  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMIN"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMINA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMINA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMINAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMINL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldumin.html", 
        "type": "instruction", 
        "aliases": [
            "stumin_ldumin.html"
        ]
    }, 
    {
        "description": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to \nthe size of the register, and writes the result to the destination register. \n\nThis is an alias of SBFM. This means: \n\n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "SXTB", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "000111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "000000"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "SXTB  <Wd>, <Wn>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "SXTB  <Xd>, <Wn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100110x000000000111xxxxxxxxxx", 
                "title": "SXTB"
            }
        ], 
        "file": "sxtb_sbfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Table vector lookup extension. This instruction reads each value from the \nvector elements in the index source SIMD&FP register, uses each result as an \nindex to perform a lookup in a table of bytes that is described by one to four \nsource table SIMD&FP registers, places the lookup result in a vector, and \nwrites the vector to the destination SIMD&FP register. If an index is out of \nrange for the table, the existing value in the vector element of the \ndestination register is left unchanged. If more than one source register is \nused to describe the table, the first source register describes the lowest \nbytes of the table. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "TBX", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "len": {
                        "lo": 13, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(len == 01)", 
                        "arch": null, 
                        "asm": "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>", 
                        "title": "Two register table"
                    }, 
                    {
                        "bitdiff": "(len == 10)", 
                        "arch": null, 
                        "asm": "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>", 
                        "title": "Three register table"
                    }, 
                    {
                        "bitdiff": "(len == 11)", 
                        "arch": null, 
                        "asm": "TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>", 
                        "title": "Four register table"
                    }, 
                    {
                        "bitdiff": "(len == 00)", 
                        "arch": null, 
                        "asm": "TBX  <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>", 
                        "title": "Single register table"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110000xxxxx0xx100xxxxxxxxxx", 
                "title": "TBX"
            }
        ], 
        "file": "tbx_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Transpose vectors (secondary). This instruction reads corresponding \nodd-numbered vector elements from the two source SIMD&FP registers, places \neach result into consecutive elements of a vector, and writes the vector to \nthe destination SIMD&FP register. Vector elements from the first source \nregister are placed into even-numbered elements of the destination vector, \nstarting at zero, while vector elements from the second source register are \nplaced into odd-numbered elements of the destination vector. \n\nBy using this instruction with TRN1, a 2 x 2 matrix can be transposed. \n\nThe following figure shows an example of the operation of TRN1 and TRN2 \nhalfword operations where Q = 0. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "TRN2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx0xxxxx011010xxxxxxxxxx", 
                "title": "TRN2"
            }
        ], 
        "file": "trn2_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Exclusive Register Byte derives an address from a base register value, \nloads a byte from memory, zero-extends it and writes it to a register. The \nmemory access is atomic. The PE marks the physical address being accessed as \nan exclusive access. This exclusive access mark is checked by Store Exclusive \ninstructions. See Synchronization and semaphores. For information about memory \naccesses see Load/Store addressing modes.", 
        "title": "LDXRB", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDXRB  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "No offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "00001000010xxxxx0xxxxxxxxxxxxxxx", 
                "title": "LDXRB"
            }
        ], 
        "file": "ldxrb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move general-purpose register to System Register allows the PE to write an \nAArch64 System register from a general-purpose register.", 
        "title": "MSR (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 19, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "110101010001xxxxxxxxxxxxxxxxxxxx", 
                "title": "MSR (register)"
            }
        ], 
        "file": "msr_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Reciprocal Estimate. This instruction finds an approximate \nreciprocal estimate for each vector element in the source SIMD&FP register, \nplaces the result in a vector, and writes the vector to the destination \nSIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FRECPE", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111011111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPE  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPE  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPE  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100001110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRECPE  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frecpe_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register (register) calculates an address from a base register value and \nan offset register value, loads a word from memory, and writes it to a \nregister. The offset register value can optionally be shifted and extended. \nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "LDR (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x111000011xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDR (register)"
            }
        ], 
        "file": "ldr_reg_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to \nAway (vector). This instruction converts each element in a vector from a \nfloating-point value to an unsigned integer value using the Round to Nearest \nwith Ties to Away rounding mode and writes the result to the SIMD&FP \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTAU (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111001111001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAU  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x100001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAU  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111001111001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x100001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtau_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA256 schedule update 0.", 
        "title": "SHA256SU0", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA256SU0  <Vd>.4S, <Vn>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0101111000101000001010xxxxxxxxxx", 
                "title": "SHA256SU0"
            }
        ], 
        "file": "sha256su0_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a \nmemory location, from a register. The instruction also has memory ordering \nsemantics as described in Load LOAcquire, Store LORelease. For information \nabout memory accesses, see Load/Store addressing modes.", 
        "title": "STLLR", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "(1)": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x001000100xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STLLR  <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STLLR  <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stllr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Address Translate. For more information, see . \n\nThis is an alias of SYS. This means: \n\n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", 
        "title": "AT", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0111"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "100x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "AT  <at_op>, <Xt>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101010100001xxx0111100xxxxxxxxx", 
                "title": "AT"
            }
        ], 
        "file": "at_sys.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move Immediate (vector). This instruction places an immediate constant into \nevery vector element of the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MOVI", 
        "classes": [
            {
                "fields": {
                    "a": {
                        "lo": 18, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "c": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "b": {
                        "lo": 17, 
                        "hi": 17, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "e": {
                        "lo": 8, 
                        "hi": 8, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "d": {
                        "lo": 9, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "g": {
                        "lo": 6, 
                        "hi": 6, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "cmode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "h": {
                        "lo": 5, 
                        "hi": 5, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "f": {
                        "lo": 7, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(op == 0 && cmode == 1110)", 
                        "arch": null, 
                        "asm": "MOVI  <Vd>.<T>, #<imm8>{, LSL #0}", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(op == 0 && cmode == 10x0)", 
                        "arch": null, 
                        "asm": "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "16-bit shifted immediate"
                    }, 
                    {
                        "bitdiff": "(op == 0 && cmode == 0xx0)", 
                        "arch": null, 
                        "asm": "MOVI  <Vd>.<T>, #<imm8>{, LSL #<amount>}", 
                        "title": "32-bit shifted immediate"
                    }, 
                    {
                        "bitdiff": "(op == 0 && cmode == 110x)", 
                        "arch": null, 
                        "asm": "MOVI  <Vd>.<T>, #<imm8>, MSL #<amount>", 
                        "title": "32-bit shifting ones"
                    }, 
                    {
                        "bitdiff": "(Q == 0 && op == 1 && cmode == 1110)", 
                        "arch": null, 
                        "asm": "MOVI  <Dd>, #<imm>", 
                        "title": "64-bit scalar"
                    }, 
                    {
                        "bitdiff": "(Q == 1 && op == 1 && cmode == 1110)", 
                        "arch": null, 
                        "asm": "MOVI  <Vd>.2D, #<imm>", 
                        "title": "64-bit vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0xx0111100000xxxxxxx01xxxxxxxxxx", 
                "title": "MOVI"
            }
        ], 
        "file": "movi_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Negate, setting flags, negates an optionally-shifted register value, and \nwrites the result to the destination register. It updates the condition flags \nbased on the result. \n\nThis is an alias of SUBS (shifted register). This means: \n\n* The encodings in this description are named to match the encodings of SUBS \n  (shifted register). \n* The description of SUBS (shifted register) gives the operational pseudocode \n  for this instruction.", 
        "title": "NEGS", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "NEGS  <Wd>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "NEGS  <Xd>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101011xx0xxxxxxxxxxx11111xxxxx", 
                "title": "NEGS"
            }
        ], 
        "file": "negs_subs_addsub_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a \n2-bit immediate index value, and returns a 128-bit result in the destination \nSIMD&FP register. It performs a three-way exclusive OR of the three 32-bit \nfields held in the upper three elements of the first source vector, and adds \nthe resulting 32-bit value and the following three other 32-bit values: \n\n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the three-way exclusive OR. \n* The result of the exclusive OR of the top 32-bit element of the second \n  source vector, Vn, with a rotation left by 12 of the top 32-bit element of \n  the first source vector. \n* A 32-bit element indexed out of the third source vector, Vm. \nThe result of this addition is returned as the top element of the result. The \nother elements of the result are taken from elements of the first source \nvector, with the element returned in bits<63:32> being rotated left by 9. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM3TT1A", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm2": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110010xxxxx10xx00xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm3tt1a_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned minimum on halfword in memory, without return, atomically \nloads a 16-bit halfword from memory, compares it against the value held in a \nregister, and stores the smaller value back to memory, treating the values as \nunsigned numbers. \n\n* STUMINH has no memory ordering semantics. \n* STUMINLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH. \n* The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the \n  operational pseudocode for this instruction.", 
        "title": "STUMINH, STUMINLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx011100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STUMINH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STUMINLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stuminh_lduminh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Sign Extend Word sign-extends a word to the size of the register, and writes \nthe result to the destination register. \n\nThis is an alias of SBFM. This means: \n\n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "SXTW", 
        "classes": [
            {
                "fields": {
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "011111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "000000"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SXTW  <Xd>, <Wn>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1001001101000000011111xxxxxxxxxx", 
                "title": "SXTW"
            }
        ], 
        "file": "sxtw_sbfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Doubling Multiply-Add Long. This instruction multiplies \ncorresponding signed integer values in the lower or upper half of the vectors \nof the two source SIMD&FP registers, doubles the results, and accumulates the \nfinal results with the vector elements of the destination SIMD&FP register. \nThe destination vector elements are twice as long as the elements that are \nmultiplied. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLAL instruction extracts each source vector from the lower half of \neach source register, while the SQDMLAL2 instruction extracts each source \nvector from the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQDMLAL, SQDMLAL2 (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx100100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx100100xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqdmlal_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Move register without conversion. This instruction copies the \nfloating-point value in the SIMD&FP source register to the SIMD&FP destination \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMOV (register)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "opc": {
                        "lo": 15, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMOV  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMOV  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMOV  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100000010000xxxxxxxxxx", 
                "title": "FMOV (register)"
            }
        ], 
        "file": "fmov_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Shift Right Narrow (immediate). This instruction reads each \nvector element in the source SIMD&FP register, right shifts and truncates each \nresult by an immediate value, saturates each shifted result to a value that is \nhalf the original width, puts the final result into a vector, and writes the \nvector to the lower or upper half of the destination SIMD&FP register. All the \nvalues in this instruction are signed integer values. The destination vector \nelements are half as long as the source vector elements. For rounded results, \nsee SQRSHRN. \n\nThe SQSHRN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the SQSHRN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQSHRN, SQSHRN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx100101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHRN  <Vb><d>, <Va><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx100101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqshrn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare and Branch on Nonzero compares the value in a register with zero, and \nconditionally branches to a label at a PC-relative offset if the comparison is \nnot equal. It provides a hint that this is not a subroutine call or return. \nThis instruction does not affect the condition flags.", 
        "title": "CBNZ", 
        "classes": [
            {
                "fields": {
                    "imm19": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CBNZ  <Wt>, <label>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CBNZ  <Xt>, <label>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0110101xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "CBNZ"
            }
        ], 
        "file": "cbnz.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Reverse Bit order (vector). This instruction reads each vector element from \nthe source SIMD&FP register, reverses the bits of the element, places the \nresults into a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "RBIT (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "RBIT  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x10111001100000010110xxxxxxxxxx", 
                "title": "RBIT (vector)"
            }
        ], 
        "file": "rbit_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point move immediate (scalar). This instruction copies a \nfloating-point immediate constant into the SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMOV (scalar, immediate)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm8": {
                        "lo": 13, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMOV  <Hd>, #<imm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMOV  <Sd>, #<imm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMOV  <Dd>, #<imm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxxxxx10000000xxxxx", 
                "title": "FMOV (scalar, immediate)"
            }
        ], 
        "file": "fmov_float_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral, to nearest with ties to Away (vector). This \ninstruction rounds a vector of floating-point values in the SIMD&FP source \nregister to integral floating-point values of the same size using the Round to \nNearest with Ties to Away rounding mode, and writes the result to the SIMD&FP \ndestination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives \nan infinite result with the same sign, and a NaN is propagated as for normal \narithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRINTA (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111001111001100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTA  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x100001100010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTA  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frinta_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned minimum on word or doubleword in memory, without return, \natomically loads a 32-bit word or 64-bit doubleword from memory, compares it \nagainst the value held in a register, and stores the smaller value back to \nmemory, treating the values as unsigned numbers. \n\n* STUMIN has no memory ordering semantics. \n* STUMINL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMIN, LDUMINA, LDUMINAL, LDUMINL. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDUMIN, LDUMINA, LDUMINAL, LDUMINL. \n* The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational \n  pseudocode for this instruction.", 
        "title": "STUMIN, STUMINL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx011100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STUMIN  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDUMIN alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STUMINL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDUMINL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STUMIN  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDUMIN alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STUMINL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDUMINL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stumin_ldumin.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Halt instruction generates a Halt Instruction debug event.", 
        "title": "HLT", 
        "classes": [
            {
                "fields": {
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "HLT  #<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100010xxxxxxxxxxxxxxxx00000", 
                "title": "HLT"
            }
        ], 
        "file": "hlt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit \ndoubleword from memory, and compares it against the value held in a first \nregister. If the comparison is equal, the value in a second register is \nwritten to memory. If the write is performed, the read and write occur \natomically such that no other modification of the memory location can take \nplace between the read and write. \n\n* CASA and CASAL load from memory with acquire semantics. \n* CASL and CASAL store to memory with release semantics. \n* CAS has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors \nassociated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the register which is \ncompared and loaded, that is <Ws>, or <Xs>, is restored to the value held in \nthe register before the instruction was executed.", 
        "title": "CAS, CASA, CASAL, CASL", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x0010001x1xxxxxx11111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && L == 0 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CAS"
                    }, 
                    {
                        "bitdiff": "(size == 10 && L == 1 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASA  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CASA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && L == 1 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASAL  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CASAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && L == 0 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASL  <Ws>, <Wt>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit CASL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && L == 0 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CAS  <Xs>, <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CAS"
                    }, 
                    {
                        "bitdiff": "(size == 11 && L == 1 && o0 == 0)", 
                        "arch": null, 
                        "asm": "CASA  <Xs>, <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CASA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && L == 1 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASAL  <Xs>, <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CASAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && L == 0 && o0 == 1)", 
                        "arch": null, 
                        "asm": "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit CASL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "cas.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Select Increment returns, in the destination register, the value \nof the first source register if the condition is TRUE, and otherwise returns \nthe value of the second source register incremented by 1. \n\nThis instruction is used by the aliases CINC, and CSET.", 
        "title": "CSINC", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CSINC  <Wd>, <Wn>, <Wm>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CSINC  <Xd>, <Xn>, <Xm>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010100xxxxxxxxx01xxxxxxxxxx", 
                "title": "CSINC"
            }
        ], 
        "file": "csinc.html", 
        "type": "instruction", 
        "aliases": [
            "cinc_csinc.html", 
            "cset_csinc.html"
        ]
    }, 
    {
        "description": "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a \nregister. \n\nThis is an alias of MOVN. This means: \n\n* The encodings in this description are named to match the encodings of MOVN. \n* The description of MOVN gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (inverted wide immediate)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "hw": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MOV  <Wd>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOV  <Xd>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100101xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "MOV (inverted wide immediate)"
            }
        ], 
        "file": "mov_movn.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "TLB Invalidate operation. For more information, see . \n\nThis is an alias of SYS. This means: \n\n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", 
        "title": "TLBI", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1000"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "TLBI  <tlbi_op>{, <Xt>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101010100001xxx1000xxxxxxxxxxxx", 
                "title": "TLBI"
            }
        ], 
        "file": "tlbi_sys.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Authenticate Data address, using key B. This instruction authenticates a data \naddress, using a modifier and key B. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTDB. \n* The value zero, for AUTDZB. \nIf the authentication passes, the upper bits of the address are restored to \nenable subsequent use of the address. If the authentication fails, the upper \nbits are corrupted and any subsequent use of the address results in a \nTranslation fault.", 
        "title": "AUTDB, AUTDZB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "AUTDB  <Xd>, <Xn|SP>", 
                        "title": "AUTDB"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "AUTDZB  <Xd>", 
                        "title": "AUTDZB"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "autdb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed maximum on byte in memory, without return, atomically loads an \n8-bit byte from memory, compares it against the value held in a register, and \nstores the larger value back to memory, treating the values as signed numbers. \n\n* STSMAXB has no memory ordering semantics. \n* STSMAXLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB. \n* The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the \n  operational pseudocode for this instruction.", 
        "title": "STSMAXB, STSMAXLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx010000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STSMAXB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STSMAXLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stsmaxb_ldsmaxb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store multiple 3-element structures from three registers. This instruction \nstores multiple 3-element structures to memory from three SIMD&FP registers, \nwith interleaving. Every element of each register is stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST3 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100000000000100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0100"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100100xxxxx0100xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st3_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Duplicate general-purpose register to vector. This instruction duplicates the \ncontents of the source general-purpose register into a scalar or each element \nin a vector, and writes the result to the SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "DUP (general)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DUP  <Vd>.<T>, <R><n>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110000xxxxx000011xxxxxxxxxx", 
                "title": "DUP (general)"
            }
        ], 
        "file": "dup_advsimd_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Bitfield Extract extracts any number of adjacent bits at any position \nfrom a register, sign-extends them to the size of the register, and writes the \nresult to the destination register. \n\nThis is an alias of SBFM. This means: \n\n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", 
        "title": "SBFX", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "SBFX  <Wd>, <Wn>, #<lsb>, #<width>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && N == 1)", 
                        "arch": null, 
                        "asm": "SBFX  <Xd>, <Xn>, #<lsb>, #<width>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x00100110xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "SBFX"
            }
        ], 
        "file": "sbfx_sbfm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register (unprivileged) stores a word or doubleword from a register to \nmemory. The address that is used for the store is calculated from a base \nregister and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "STTR", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "STTR  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "STTR  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x111000000xxxxxxxxx10xxxxxxxxxx", 
                "title": "STTR"
            }
        ], 
        "file": "sttr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum Number of Pair of elements (scalar). This instruction \ncompares two vector elements in the source SIMD&FP register and writes the \nsmallest of the floating-point values as a scalar to the destination SIMD&FP \nregister. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMINNMP (scalar)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111010110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNMP  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINNMP  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fminnmp_advsimd_pair.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum (scalar). This instruction compares the two source \nSIMD&FP registers, and writes the larger of the two floating-point values to \nthe destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMAX (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMAX  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FMAX  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FMAX  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx010010xxxxxxxxxx", 
                "title": "FMAX (scalar)"
            }
        ], 
        "file": "fmax_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Rounding Subtract returning High Narrow. This instruction subtracts each \nvector element of the second source SIMD&FP register from the corresponding \nvector element of the first source SIMD&FP register, places the most \nsignificant half of the result into a vector, and writes the vector to the \nlower or upper half of the destination SIMD&FP register. \n\nThe results are rounded. For truncated results, see SUBHN. \n\nThe RSUBHN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the RSUBHN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "RSUBHN, RSUBHN2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx011000xxxxxxxxxx", 
                "title": "RSUBHN, RSUBHN2"
            }
        ], 
        "file": "rsubhn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding toward Minus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP \nsource register to a 32-bit or 64-bit signed integer using the Round towards \nMinus Infinity rounding mode, and writes the result to the general-purpose \ndestination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTMS (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTMS  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTMS  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTMS  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTMS  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTMS  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTMS  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx110000000000xxxxxxxxxx", 
                "title": "FCVTMS (scalar)"
            }
        ], 
        "file": "fcvtms_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Absolute Difference Long. This instruction subtracts the vector \nelements of the second source SIMD&FP register from the corresponding vector \nelements of the first source SIMD&FP register, places the absolute value of \nthe results into a vector, and writes the vector to the lower or upper half of \nthe destination SIMD&FP register. The destination vector elements are twice as \nlong as the source vector elements. \n\nThe SABDL instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the SABDL2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SABDL, SABDL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx011100xxxxxxxxxx", 
                "title": "SABDL, SABDL2"
            }
        ], 
        "file": "sabdl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum of Pair of elements (scalar). This instruction compares \ntwo vector elements in the source SIMD&FP register and writes the largest of \nthe floating-point values as a scalar to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAXP (scalar)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111000110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXP  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111100x110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXP  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmaxp_advsimd_pair.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Move to or from general-purpose register without conversion. \nThis instruction transfers the contents of a SIMD&FP register to a \ngeneral-purpose register, or the contents of a general-purpose register to a \nSIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FMOV (general)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "0x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "11x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11 && rmode == 00 && opcode == 110)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMOV  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11 && rmode == 00 && opcode == 110)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMOV  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 11 && rmode == 00 && opcode == 111)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMOV  <Hd>, <Wn>", 
                        "title": "32-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00 && rmode == 00 && opcode == 111)", 
                        "arch": null, 
                        "asm": "FMOV  <Sd>, <Wn>", 
                        "title": "32-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00 && rmode == 00 && opcode == 110)", 
                        "arch": null, 
                        "asm": "FMOV  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11 && rmode == 00 && opcode == 111)", 
                        "arch": "ARMv8.2", 
                        "asm": "FMOV  <Hd>, <Xn>", 
                        "title": "64-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01 && rmode == 00 && opcode == 111)", 
                        "arch": null, 
                        "asm": "FMOV  <Dd>, <Xn>", 
                        "title": "64-bit to double-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 10 && rmode == 01 && opcode == 111)", 
                        "arch": null, 
                        "asm": "FMOV  <Vd>.D[1], <Xn>", 
                        "title": "64-bit to top half of 128-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01 && rmode == 00 && opcode == 110)", 
                        "arch": null, 
                        "asm": "FMOV  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 10 && rmode == 01 && opcode == 110)", 
                        "arch": null, 
                        "asm": "FMOV  <Xd>, <Vn>.D[1]", 
                        "title": "Top half of 128-bit to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx10x11x000000xxxxxxxxxx", 
                "title": "FMOV (general)"
            }
        ], 
        "file": "fmov_float_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed \ninteger values from the vector in the source SIMD&FP register, places the \nresult into a vector, and writes the vector to the destination SIMD&FP \nregister. The destination vector elements are twice as long as the source \nvector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SADDLP", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SADDLP  <Vd>.<Ta>, <Vn>.<Tb>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx100000001010xxxxxxxxxx", 
                "title": "SADDLP"
            }
        ], 
        "file": "saddlp_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register Byte (register) calculates an address from a base register \nvalue and an offset register value, and stores a byte from a 32-bit register \nto the calculated address. For information about memory accesses, see \nLoad/Store addressing modes. \n\nThe instruction uses an offset addressing mode, that calculates the address \nused for the memory access from a base register value and an offset register \nvalue. The offset can be optionally shifted and extended.", 
        "title": "STRB (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(option != 011)", 
                        "arch": null, 
                        "asm": "STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]", 
                        "title": "Extended register"
                    }, 
                    {
                        "bitdiff": "(option == 011)", 
                        "arch": null, 
                        "asm": "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", 
                        "title": "Shifted register"
                    }
                ], 
                "unallocated": null, 
                "mask": "00111000001xxxxxxxxx10xxxxxxxxxx", 
                "title": "STRB (register)"
            }
        ], 
        "file": "strb_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Add to accumulator (by element). This \ninstruction multiplies the vector elements in the first source SIMD&FP \nregister by the specified value in the second source SIMD&FP register, and \naccumulates the results in the vector elements of the destination SIMD&FP \nregister. All the values in this instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar, \nsingle-precision and double-precision , Vector, half-precision and Vector, \nsingle-precision and double-precision", 
        "title": "FMLA (by element)", 
        "classes": [
            {
                "title": "Scalar, half-precision", 
                "fields": {
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111100xxxxxx0001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLA  <Hd>, <Hn>, <Vm>.H[<index>]", 
                        "title": "Scalar, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111111xxxxxxx0001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", 
                        "title": "Scalar, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector, half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111100xxxxxx0001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", 
                        "title": "Vector, half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector, single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011111xxxxxxx0001x0xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector, single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmla_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare Negative (immediate) adds a register value and an optionally-shifted \nimmediate value. It updates the condition flags based on the result, and \ndiscards the result. \n\nThis is an alias of ADDS (immediate). This means: \n\n* The encodings in this description are named to match the encodings of ADDS \n  (immediate). \n* The description of ADDS (immediate) gives the operational pseudocode for \n  this instruction.", 
        "title": "CMN (immediate)", 
        "classes": [
            {
                "fields": {
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CMN  <Wn|WSP>, #<imm>{, <shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CMN  <Xn|SP>, #<imm>{, <shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0110001xxxxxxxxxxxxxxxxxxx11111", 
                "title": "CMN (immediate)"
            }
        ], 
        "file": "cmn_adds_addsub_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Maximum Number across Vector. This instruction compares all the \nvector elements in the source SIMD&FP register, and writes the largest of the \nvalues as a scalar to the destination SIMD&FP register. All the values in this \ninstruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector \nelement is numeric and the other is a quiet NaN, the result of the comparison \nis the numerical value, otherwise the result is identical to FMAX (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMAXNMV", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111000110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNMV  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x110000110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMAXNMV  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmaxnmv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity \n(vector). This instruction converts a scalar or each element in a vector from \na floating-point value to an unsigned integer value using the Round towards \nPlus Infinity rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTPU (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111111011111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPU  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPU  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111011111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPU  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtpu_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value \nand an immediate register value, and writes the result to the destination \nregister. \n\nThis instruction is used by the alias MOV (bitmask immediate).", 
        "title": "ORR (immediate)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "ORR  <Wd|WSP>, <Wn>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ORR  <Xd|SP>, <Xn>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x01100100xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "ORR (immediate)"
            }
        ], 
        "file": "orr_log_imm.html", 
        "type": "instruction", 
        "aliases": [
            "mov_orr_log_imm.html"
        ]
    }, 
    {
        "description": "Zip vectors (secondary). This instruction reads adjacent vector elements from \nthe lower half of two source SIMD&FP registers as pairs, interleaves the pairs \nand places them into a vector, and writes the vector to the destination \nSIMD&FP register. The first pair from the first source register is placed into \nthe two lowest vector elements, with subsequent pairs taken alternately from \neach source register. \n\nThis instruction can be used with ZIP1 to interleave two vectors. \n\nThe following figure shows an example of the operation of ZIP1 and ZIP2 with \nthe arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ZIP2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx0xxxxx011110xxxxxxxxxx", 
                "title": "ZIP2"
            }
        ], 
        "file": "zip2_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source \nSIMD&FP register by 12, and adds that 32-bit value to the two other 32-bit \nvalues held in the top 32 bits of each of the 128-bit vectors in the second \nand third source SIMD&FP registers, rotating this result left by 7 and writing \nthe final result into the top 32 bits of the vector in the destination SIMD&FP \nregister, with the bottom 96 bits of the vector being written to 0. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM3SS1", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110010xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm3ss1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Dot Product unsigned arithmetic (vector). This instruction performs the dot \nproduct of the four 8-bit elements in each 32-bit element of the first source \nregister with the four 8-bit elements of the corresponding 32-bit element in \nthe second source register, accumulating the result into the corresponding \n32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", 
        "title": "UDOT (vector)", 
        "classes": [
            {
                "title": "Three registers of the same type", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx0xxxxx100101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "udot_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Prefetch Memory (unscaled offset) signals the memory system that data memory \naccesses from a specified address are likely to occur in the near future. The \nmemory system can respond by taking actions that are expected to speed up the \nmemory accesses when they do occur, such as preloading the cache line \ncontaining the specified address into one or more caches. \n\nThe effect of an PRFUM instruction is implementation defined. For more \ninformation, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "PRFM (unscaled offset)", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "11111000100xxxxxxxxx00xxxxxxxxxx", 
                "title": "PRFM (unscaled offset)"
            }
        ], 
        "file": "prfum.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise NOT (vector). This instruction reads each vector element from the \nsource SIMD&FP register, places the inverse of each value into a vector, and \nwrites the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of NOT. This means: \n\n* The encodings in this description are named to match the encodings of NOT. \n* The description of NOT gives the operational pseudocode for this \n  instruction.", 
        "title": "MVN", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MVN  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x10111000100000010110xxxxxxxxxx", 
                "title": "MVN"
            }
        ], 
        "file": "mvn_not_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a \nregister value and the complement of an optionally-shifted register value, and \nwrites the result to the destination register. \n\nThis instruction is used by the alias MVN.", 
        "title": "ORN (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0101010xx1xxxxxxxxxxxxxxxxxxxxx", 
                "title": "ORN (shifted register)"
            }
        ], 
        "file": "orn_log_shift.html", 
        "type": "instruction", 
        "aliases": [
            "mvn_orn_log_shift.html"
        ]
    }, 
    {
        "description": "Branch causes an unconditional branch to a label at a PC-relative offset, with \na hint that this is not a subroutine call or return.", 
        "title": "B", 
        "classes": [
            {
                "fields": {
                    "imm26": {
                        "lo": 0, 
                        "hi": 25, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxxxxxxxxx"
                    }, 
                    "op": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "B  <label>", 
                        "title": "26-bit signed PC-relative branch offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "000101xxxxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "B"
            }
        ], 
        "file": "b_uncond.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Shift Left (register). This instruction takes each signed integer value \nin the vector of the first source SIMD&FP register, shifts each value by a \nvalue from the least significant byte of the corresponding element of the \nsecond source SIMD&FP register, places the results in a vector, and writes the \nvector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift \nvalue is negative, it is a truncating right shift. For a rounding shift, see \nSRSHL. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SSHL", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx010001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSHL  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "R": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx010001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sshl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Branch with Link to Register calls a subroutine at an address in a register, \nsetting register X30 to PC+4.", 
        "title": "BLR", 
        "classes": [
            {
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "00000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BLR  <Xn>", 
                        "title": "Integer"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101011000111111000000xxxxx00000", 
                "title": "BLR"
            }
        ], 
        "file": "blr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Select Invert returns, in the destination register, the value of \nthe first source register if the condition is TRUE, and otherwise returns the \nbitwise inversion value of the second source register. \n\nThis instruction is used by the aliases CINV, and CSETM.", 
        "title": "CSINV", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CSINV  <Wd>, <Wn>, <Wm>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CSINV  <Xd>, <Xn>, <Xm>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1011010100xxxxxxxxx00xxxxxxxxxx", 
                "title": "CSINV"
            }
        ], 
        "file": "csinv.html", 
        "type": "instruction", 
        "aliases": [
            "cinv_csinv.html", 
            "csetm_csinv.html"
        ]
    }, 
    {
        "description": "Store Register Halfword (unscaled) calculates an address from a base register \nvalue and an immediate offset, and stores a halfword to the calculated \naddress, from a 32-bit register. For information about memory accesses, see \nLoad/Store addressing modes.", 
        "title": "STURH", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STURH  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "Unscaled offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01111000000xxxxxxxxx00xxxxxxxxxx", 
                "title": "STURH"
            }
        ], 
        "file": "sturh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Compare bitwise Equal to zero (vector). This instruction reads each vector \nelement in the source SIMD&FP register and if the value is equal to zero sets \nevery bit of the corresponding vector element in the destination SIMD&FP \nregister to one, otherwise sets every bit of the corresponding vector element \nin the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "CMEQ (zero)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx100000100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMEQ  <V><d>, <V><n>, #0", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx100000100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CMEQ  <Vd>.<T>, <Vn>.<T>, #0", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "cmeq_advsimd_zero.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register (literal) calculates an address from the PC value and an \nimmediate offset, loads a word from memory, and writes it to a register. For \ninformation about memory accesses, see Load/Store addressing modes.", 
        "title": "LDR (literal)", 
        "classes": [
            {
                "fields": {
                    "imm19": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "0x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDR  <Wt>, <label>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 01)", 
                        "arch": null, 
                        "asm": "LDR  <Xt>, <label>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x011000xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "LDR (literal)"
            }
        ], 
        "file": "ldr_lit_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values, \nsubtracts the product from a 64-bit register value, and writes the result to \nthe 64-bit destination register. \n\nThis instruction is used by the alias UMNEGL.", 
        "title": "UMSUBL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011101xxxxx1xxxxxxxxxxxxxxx", 
                "title": "UMSUBL"
            }
        ], 
        "file": "umsubl.html", 
        "type": "instruction", 
        "aliases": [
            "umnegl_umsubl.html"
        ]
    }, 
    {
        "description": "Floating-point Subtract (vector). This instruction subtracts the elements in \nthe vector in the second source SIMD&FP register, from the corresponding \nelements in the vector in the first source SIMD&FP register, places each \nresult into elements of a vector, and writes the vector to the destination \nSIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FSUB (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110110xxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x1xxxxx110101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fsub_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors \nin the two source SIMD&FP registers, rotates each 64-bit element of the \nresulting 128-bit vector right by the value specified by a 6-bit immediate \nvalue, and writes the result to the destination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "XAR", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110100xxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "xar_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Prefetch Memory (immediate) signals the memory system that data memory \naccesses from a specified address are likely to occur in the near future. The \nmemory system can respond by taking actions that are expected to speed up the \nmemory accesses when they do occur, such as preloading the cache line \ncontaining the specified address into one or more caches. \n\nThe effect of an PRFM instruction is implementation defined. For more \ninformation, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "PRFM (immediate)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]", 
                        "title": "Unsigned offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "1111100110xxxxxxxxxxxxxxxxxxxxxx", 
                "title": "PRFM (immediate)"
            }
        ], 
        "file": "prfm_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add returning High Narrow. This instruction adds each vector element in the \nfirst source SIMD&FP register to the corresponding vector element in the \nsecond source SIMD&FP register, places the most significant half of the result \ninto a vector, and writes the vector to the lower or upper half of the \ndestination SIMD&FP register. \n\nThe results are truncated. For rounded results, see RADDHN. \n\nThe ADDHN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the ADDHN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "ADDHN, ADDHN2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx010000xxxxxxxxxx", 
                "title": "ADDHN, ADDHN2"
            }
        ], 
        "file": "addhn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire RCpc Register derives an address from a base register value, \nloads a 32-bit word or 64-bit doubleword from the derived address in memory, \nand writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire, \nStore-Release, except that: \n\n* There is no ordering requirement, separate from the requirements of a \n  Load-Acquirepc or a Store-Release, created by having a Store-Release \n  followed by a Load-Acquirepc instruction. \n* The reading of a value written by a Store-Release by a Load-Acquirepc \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed. \nThis difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "LDAPR", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "(1)": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000101xxxxx110000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDAPR  <Wt>, [<Xn|SP> {,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDAPR  <Xt>, [<Xn|SP> {,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "ldapr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half \n(vector). This instruction multiplies the vector elements of the first source \nSIMD&FP register with the corresponding vector elements of the second source \nSIMD&FP register without saturating the multiply results, doubles the results, \nand subtracts the most significant half of the final results from the vector \nelements of the destination SIMD&FP register. The results are rounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation \nbit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRDMLSH (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx0xxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLSH  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": "ARMv8.1"
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx0xxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "sqrdmlsh_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move (wide immediate) moves a 16-bit immediate value to a register. \n\nThis is an alias of MOVZ. This means: \n\n* The encodings in this description are named to match the encodings of MOVZ. \n* The description of MOVZ gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (wide immediate)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "hw": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MOV  <Wd>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MOV  <Xd>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x10100101xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "MOV (wide immediate)"
            }
        ], 
        "file": "mov_movz.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Dot Product signed arithmetic (vector). This instruction performs the dot \nproduct of the four 8-bit elements in each 32-bit element of the first source \nregister with the four 8-bit elements of the corresponding 32-bit element in \nthe second source register, accumulating the result into the corresponding \n32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", 
        "title": "SDOT (vector)", 
        "classes": [
            {
                "title": "Three registers of the same type", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx0xxxxx100101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sdot_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SHA256 schedule update 1.", 
        "title": "SHA256SU1", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01011110000xxxxx011000xxxxxxxxxx", 
                "title": "SHA256SU1"
            }
        ], 
        "file": "sha256su1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Halving Add. This instruction adds corresponding unsigned integer \nvalues from the two source SIMD&FP registers, shifts each result right one \nbit, places the results into a vector, and writes the vector to the \ndestination SIMD&FP register. \n\nThe results are truncated. For rounded results, see URHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UHADD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx000001xxxxxxxxxx", 
                "title": "UHADD"
            }
        ], 
        "file": "uhadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Minimum across Vector. This instruction compares all the vector \nelements in the source SIMD&FP register, and writes the smallest of the values \nas a scalar to the destination SIMD&FP register. All the values in this \ninstruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMINV", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111010110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINV  <V><d>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x110000111110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMINV  <V><d>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fminv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register \nvalue and an immediate value, and writes the result to the destination \nregister. It updates the condition flags based on the result. \n\nThis instruction is used by the alias TST (immediate).", 
        "title": "ANDS (immediate)", 
        "classes": [
            {
                "fields": {
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "N": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "imms": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "immr": {
                        "lo": 16, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && N == 0)", 
                        "arch": null, 
                        "asm": "ANDS  <Wd>, <Wn>, #<imm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ANDS  <Xd>, <Xn>, #<imm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x11100100xxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "ANDS (immediate)"
            }
        ], 
        "file": "ands_log_imm.html", 
        "type": "instruction", 
        "aliases": [
            "tst_ands_log_imm.html"
        ]
    }, 
    {
        "description": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit \nhalfword from memory, compares it against the value held in a register, and \nstores the larger value back to memory, treating the values as unsigned \nnumbers. The value initially loaded from memory is returned in the destination \nregister. \n\n* If the destination register is not WZR, LDUMAXAH and LDUMAXALH load from \n  memory with acquire semantics. \n* LDUMAXLH and LDUMAXALH store to memory with release semantics. \n* LDUMAXH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMAXH, STUMAXLH.", 
        "title": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx011000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAXH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDUMAXLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldumaxh.html", 
        "type": "instruction", 
        "aliases": [
            "stumaxh_ldumaxh.html"
        ]
    }, 
    {
        "description": "Signed saturating extract Narrow. This instruction reads each vector element \nfrom the source SIMD&FP register, saturates the value to half the original \nwidth, places the result into a vector, and writes the vector to the lower or \nupper half of the destination SIMD&FP register. The destination vector \nelements are half as long as the source vector elements. All the values in \nthis instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQXTN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the SQXTN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQXTN, SQXTN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx100001010010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQXTN  <Vb><d>, <Va><n>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx100001010010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqxtn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction \nreads each vector element in the source SIMD&FP register, right shifts each \nresult by an immediate value, and accumulates the final results with the \nvector elements of the destination SIMD&FP register. All the values in this \ninstruction are unsigned integer values. The results are rounded. For \ntruncated results, see USRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "URSRA", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URSRA  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx001101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ursra_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract (vector). This instruction subtracts each vector element in the \nsecond source SIMD&FP register from the corresponding vector element in the \nfirst source SIMD&FP register, places the result into a vector, and writes the \nvector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SUB (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SUB  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sub_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to \nAway (vector). This instruction converts each element in a vector from a \nfloating-point value to a signed integer value using the Round to Nearest with \nTies to Away rounding mode and writes the result to the SIMD&FP destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTAS (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111001111001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAS  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111100x100001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAS  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111001111001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x100001110010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTAS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtas_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Negate with Carry negates the sum of a register value and the value of NOT \n(Carry flag), and writes the result to the destination register. \n\nThis is an alias of SBC. This means: \n\n* The encodings in this description are named to match the encodings of SBC. \n* The description of SBC gives the operational pseudocode for this \n  instruction.", 
        "title": "NGC", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "NGC  <Wd>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "NGC  <Xd>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1011010000xxxxx00000011111xxxxx", 
                "title": "NGC"
            }
        ], 
        "file": "ngc_sbc.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Secure Monitor Call causes an exception to EL3. \n\nSMC is available only for software executing at EL1 or higher. It is undefined \nin EL0. \n\nIf the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC \ninstruction at EL1 or higher generates a Secure Monitor Call exception, \nrecording it in ESR_ELx, using the EC value 0x17, that is taken to EL3. \n\nIf the value of HCR_EL2.TSC is 1, execution of an SMC instruction in a \nNon-secure EL1 state generates an exception that is taken to EL2, regardless \nof the value of SCR_EL3.SMD. For more information, see Traps to EL2 of \nNon-secure EL1 execution of SMC instructions. \n\nIf the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC \ninstruction is undefined.", 
        "title": "SMC", 
        "classes": [
            {
                "fields": {
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMC  #<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100000xxxxxxxxxxxxxxxx00011", 
                "title": "SMC"
            }
        ], 
        "file": "smc.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Three-way Exclusive OR performs a three-way exclusive OR of the values in the \nthree source SIMD&FP registers, and writes the result to the destination \nSIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "EOR3", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110000xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "eor3_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply-Add Long (vector, by element). This instruction multiplies \neach vector element in the lower or upper half of the first source SIMD&FP \nregister by the specified vector element in the second source SIMD&FP \nregister, and accumulates the results with the vector elements of the \ndestination SIMD&FP register. The destination vector elements are twice as \nlong as the elements that are multiplied. All the values in this instruction \nare signed integer values. \n\nThe SMLAL instruction extracts vector elements from the lower half of the \nfirst source register, while the SMLAL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SMLAL, SMLAL2 (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx0010x0xxxxxxxxxx", 
                "title": "SMLAL, SMLAL2 (by element)"
            }
        ], 
        "file": "smlal_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Absolute Difference. This instruction subtracts the elements of the \nvector of the second source SIMD&FP register from the corresponding elements \nof the first source SIMD&FP register, places the the absolute values of the \nresults into a vector, and writes the vector to the destination SIMD&FP \nregister. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SABD", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx011101xxxxxxxxxx", 
                "title": "SABD"
            }
        ], 
        "file": "sabd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Pointer Authentication Code for Instruction address, using key A. This \ninstruction computes and inserts a pointer authentication code for an \ninstruction address, using a modifier and key A. \n\nThe address is: \n\n* In the general-purpose register that is specified by <Xd> for PACIA and \n  PACIZA. \n* In X17, for PACIA1716. \n* In X30, for PACIASP and PACIAZ. \nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACIA. \n* The value zero, for PACIZA and PACIAZ. \n* In X16, for PACIA1716. \n* In SP, for PACIASP. \nIt has encodings from 2 classes: Integer and System", 
        "title": "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "unallocated": null, 
                "mask": "110110101100000100x000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0)", 
                        "arch": null, 
                        "asm": "PACIA  <Xd>, <Xn|SP>", 
                        "title": "PACIA"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && Rn == 11111)", 
                        "arch": null, 
                        "asm": "PACIZA  <Xd>", 
                        "title": "PACIZA"
                    }
                ], 
                "arch": "ARMv8.3"
            }, 
            {
                "title": "System", 
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "00x"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "00x1"
                    }
                }, 
                "unallocated": null, 
                "mask": "1101010100000011001000x100x11111", 
                "encodings": [
                    {
                        "bitdiff": "(CRm == 0001 && op2 == 000)", 
                        "arch": null, 
                        "asm": "PACIA1716", 
                        "title": "PACIA1716"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 001)", 
                        "arch": null, 
                        "asm": "PACIASP", 
                        "title": "PACIASP"
                    }, 
                    {
                        "bitdiff": "(CRm == 0011 && op2 == 000)", 
                        "arch": null, 
                        "asm": "PACIAZ", 
                        "title": "PACIAZ"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "pacia.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Shift Right (immediate). This instruction reads each vector element in \nthe source SIMD&FP register, right shifts each result by an immediate value, \nplaces the final result into a vector, and writes the vector to the \ndestination SIMD&FP register. All the values in this instruction are signed \ninteger values. The results are truncated. For rounded results, see SRSHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SSHR", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSHR  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o0": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx000001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sshr_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register Halfword (immediate) stores the least significant halfword of a \n32-bit register to memory. The address that is used for the store is \ncalculated from a base register and an immediate offset. For information about \nmemory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "STRH (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000000xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STRH  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "Post-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000000xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STRH  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "Pre-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "0111100100xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "Unsigned offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "strh_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value \nheld in a general-purpose register. It takes an input CRC value in the first \nsource operand, performs a CRC on the input value in the second source \noperand, and returns the output CRC value. The second source operand can be 8, \n16, 32, or 64 bits. To align with common usage, the bit order of the values is \nreversed as part of the operation, and the polynomial 0x04C11DB7 is used for \nthe CRC calculation. \n\nIn ARMv8-A, this is an optional instruction, and in ARMv8.1 it is mandatory \nfor all implementations to implement it. \n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.", 
        "title": "CRC32B, CRC32H, CRC32W, CRC32X", 
        "classes": [
            {
                "fields": {
                    "sz": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "C": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && sz == 00)", 
                        "arch": null, 
                        "asm": "CRC32B  <Wd>, <Wn>, <Wm>", 
                        "title": "CRC32B"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && sz == 01)", 
                        "arch": null, 
                        "asm": "CRC32H  <Wd>, <Wn>, <Wm>", 
                        "title": "CRC32H"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && sz == 10)", 
                        "arch": null, 
                        "asm": "CRC32W  <Wd>, <Wn>, <Wm>", 
                        "title": "CRC32W"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && sz == 11)", 
                        "arch": null, 
                        "asm": "CRC32X  <Wd>, <Wn>, <Xm>", 
                        "title": "CRC32X"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx0100xxxxxxxxxxxx", 
                "title": "CRC32B, CRC32H, CRC32W, CRC32X"
            }
        ], 
        "file": "crc32.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit \ndoublewords from two registers to a memory location if the PE has exclusive \naccess to the memory address, and returns a status value of 0 if the store was \nsuccessful, or of 1 if no store was performed. See Synchronization and \nsemaphores. A 32-bit pair requires the address to be doubleword aligned and is \nsingle-copy atomic at doubleword granularity. A 64-bit pair requires the \naddress to be quadword aligned and, if the Store-Exclusive succeeds, it causes \na single-copy atomic update of the 128-bit memory location being updated. For \ninformation about memory accesses see Load/Store addressing modes.", 
        "title": "STXP", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sz == 0)", 
                        "arch": null, 
                        "asm": "STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sz == 1)", 
                        "arch": null, 
                        "asm": "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000001xxxxx0xxxxxxxxxxxxxxx", 
                "title": "STXP"
            }
        ], 
        "file": "stxp.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a \nsource SIMD&FP register and the complement of the vector in another source \nSIMD&FP register, then performs a bitwise exclusive OR of the resulting vector \nand the vector in a third source SIMD&FP register, and writes the result to \nthe destination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SHA is implemented.", 
        "title": "BCAX", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110001xxxxx0xxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "bcax_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Supervisor Call causes an exception to be taken to EL1. \n\nOn executing an SVC instruction, the PE records the exception as a Supervisor \nCall exception in ESR_ELx, using the EC value 0x15, and the value of the \nimmediate argument.", 
        "title": "SVC", 
        "classes": [
            {
                "fields": {
                    "imm16": {
                        "lo": 5, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SVC  #<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010100000xxxxxxxxxxxxxxxx00001", 
                "title": "SVC"
            }
        ], 
        "file": "svc.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Conditional Invert returns, in the destination register, the bitwise inversion \nof the value of the source register if the condition is TRUE, and otherwise \nreturns the value of the source register. \n\nThis is an alias of CSINV. This means: \n\n* The encodings in this description are named to match the encodings of CSINV. \n* The description of CSINV gives the operational pseudocode for this \n  instruction.", 
        "title": "CINV", 
        "classes": [
            {
                "fields": {
                    "o2": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "!=", 
                        "value": "111x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "!=", 
                        "value": "11111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "!=", 
                        "value": "11111"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "CINV  <Wd>, <Wn>, <cond>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "CINV  <Xd>, <Xn>, <cond>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": [
                    "xxxxxxxxxxx11111xxxxxxxxxxxxxxxx", 
                    "xxxxxxxxxxxxxxxx111xxxxxxxxxxxxx", 
                    "xxxxxxxxxxxxxxxxxxxxxx11111xxxxx"
                ], 
                "mask": "x1011010100xxxxxxxxx00xxxxxxxxxx", 
                "title": "CINV"
            }
        ], 
        "file": "cinv_csinv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load-Acquire Exclusive Pair of Registers derives an address from a base \nregister value, loads two 32-bit words or two 64-bit doublewords from memory, \nand writes them to two registers. A 32-bit pair requires the address to be \ndoubleword aligned and is single-copy atomic at doubleword granularity. A \n64-bit pair requires the address to be quadword aligned and is single-copy \natomic for each doubleword at doubleword granularity. The PE marks the \nphysical address being accessed as an exclusive access. This exclusive access \nmark is checked by Store Exclusive instructions. See Synchronization and \nsemaphores. The instruction also has memory ordering semantics as described in \nLoad-Acquire, Store-Release. For information about memory accesses see \nLoad/Store addressing modes.", 
        "title": "LDAXP", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "(1)": {
                        "lo": 16, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sz == 0)", 
                        "arch": null, 
                        "asm": "LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sz == 1)", 
                        "arch": null, 
                        "asm": "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x001000011xxxxx1xxxxxxxxxxxxxxx", 
                "title": "LDAXP"
            }
        ], 
        "file": "ldaxp.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Insert if False. This instruction inserts each bit from the first \nsource SIMD&FP register into the destination SIMD&FP register if the \ncorresponding bit of the second source SIMD&FP register is 0, otherwise leaves \nthe bit in the destination register unchanged. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "BIF", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc2": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110111xxxxx000111xxxxxxxxxx", 
                "title": "BIF"
            }
        ], 
        "file": "bif_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Shift Left (immediate). This instruction reads each value from a vector, left \nshifts each result by an immediate value, writes the final result to a vector, \nand writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SHL", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHL  <V><d>, <V><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx010101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "shl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Debug restore process state.", 
        "title": "DRPS", 
        "classes": [
            {
                "fields": {}, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "DRPS", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010110101111110000001111100000", 
                "title": "DRPS"
            }
        ], 
        "file": "drps.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add with Carry, setting flags, adds two register values and the Carry flag \nvalue, and writes the result to the destination register. It updates the \ncondition flags based on the result.", 
        "title": "ADCS", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADCS  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADCS  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0111010000xxxxx000000xxxxxxxxxx", 
                "title": "ADCS"
            }
        ], 
        "file": "adcs.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR \nNOT of a register value and an optionally-shifted register value, and writes \nthe result to the destination register.", 
        "title": "EON (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1001010xx1xxxxxxxxxxxxxxxxxxxxx", 
                "title": "EON (shifted register)"
            }
        ], 
        "file": "eon.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed maximum on word or doubleword in memory, without return, \natomically loads a 32-bit word or 64-bit doubleword from memory, compares it \nagainst the value held in a register, and stores the larger value back to \nmemory, treating the values as signed numbers. \n\n* STSMAX has no memory ordering semantics. \n* STSMAXL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL. \n* The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational \n  pseudocode for this instruction.", 
        "title": "STSMAX, STSMAXL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x1110000x1xxxxx010000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && R == 0)", 
                        "arch": null, 
                        "asm": "STSMAX  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDSMAX alias"
                    }, 
                    {
                        "bitdiff": "(size == 10 && R == 1)", 
                        "arch": null, 
                        "asm": "STSMAXL  <Ws>, [<Xn|SP>]", 
                        "title": "32-bit LDSMAXL alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 0)", 
                        "arch": null, 
                        "asm": "STSMAX  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDSMAX alias"
                    }, 
                    {
                        "bitdiff": "(size == 11 && R == 1)", 
                        "arch": null, 
                        "asm": "STSMAXL  <Xs>, [<Xn|SP>]", 
                        "title": "64-bit LDSMAXL alias"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stsmax_ldsmax.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Logical Shift Right Variable shifts a register value right by a variable \nnumber of bits, shifting in zeros, and writes the result to the destination \nregister. The remainder obtained by dividing the second source register by the \ndata size defines the number of bits by which the first source register is \nright-shifted. \n\nThis instruction is used by the alias LSR (register).", 
        "title": "LSRV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "LSRV  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "LSRV  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001001xxxxxxxxxx", 
                "title": "LSRV"
            }
        ], 
        "file": "lsrv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Absolute Difference (vector). This instruction subtracts the \nfloating-point values in the elements of the second source SIMD&FP register, \nfrom the corresponding floating-point values in the elements of the first \nsource SIMD&FP register, places the absolute value of each result in a vector, \nand writes the vector to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FABD", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110110xxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FABD  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x1xxxxx110101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FABD  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110110xxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x1xxxxx110101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fabd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unzip vectors (primary). This instruction reads corresponding even-numbered \nvector elements from the two source SIMD&FP registers, starting at zero, \nplaces the result from the first source register into consecutive elements in \nthe lower half of a vector, and the result from the second source register \ninto consecutive elements in the upper half of a vector, and writes the vector \nto the destination SIMD&FP register. \n\nThis instruction can be used with UZP2 to de-interleave two vectors. \n\nThe following figure shows an example of the operation of UZP1 and UZP2 with \nthe arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UZP1", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx0xxxxx000110xxxxxxxxxx", 
                "title": "UZP1"
            }
        ], 
        "file": "uzp1_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract (shifted register), setting flags, subtracts an optionally-shifted \nregister value from a register value, and writes the result to the destination \nregister. It updates the condition flags based on the result. \n\nThis instruction is used by the aliases CMP (shifted register), and NEGS.", 
        "title": "SUBS (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101011xx0xxxxxxxxxxxxxxxxxxxxx", 
                "title": "SUBS (shifted register)"
            }
        ], 
        "file": "subs_addsub_shift.html", 
        "type": "instruction", 
        "aliases": [
            "cmp_subs_addsub_shift.html", 
            "negs_subs_addsub_shift.html"
        ]
    }, 
    {
        "description": "Count Leading Zero bits (vector). This instruction counts the number of \nconsecutive zeros, starting from the most significant bit, in each vector \nelement in the source SIMD&FP register, places the result into a vector, and \nwrites the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "CLZ (vector)", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "CLZ  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx100000010010xxxxxxxxxx", 
                "title": "CLZ (vector)"
            }
        ], 
        "file": "clz_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Subtract from accumulator (vector). This \ninstruction multiplies corresponding floating-point values in the vectors in \nthe two source SIMD&FP registers, negates the product, adds the result to the \ncorresponding vector element of the destination SIMD&FP register, and writes \nthe result to the destination SIMD&FP register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FMLS (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "a": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110110xxxxx000011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x1xxxxx110011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmls_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit \ndoubleword from a memory location, and stores the value held in a register \nback to the same memory location. The value initially loaded from memory is \nreturned in the destination register. \n\n* If the destination register is not one of WZR or XZR, SWPA and SWPAL load \n  from memory with acquire semantics. \n* SWPL and SWPAL store to memory with release semantics. \n* SWP has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes.", 
        "title": "SWP, SWPA, SWPAL, SWPL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx100000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "SWP  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit SWP"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "SWPA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit SWPA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit SWPAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit SWPL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "SWP  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit SWP"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "SWPA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit SWPA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit SWPAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit SWPL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "swp.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates \nthe product, and writes the result to the 64-bit destination register. \n\nThis is an alias of UMSUBL. This means: \n\n* The encodings in this description are named to match the encodings of \n  UMSUBL. \n* The description of UMSUBL gives the operational pseudocode for this \n  instruction.", 
        "title": "UMNEGL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMNEGL  <Xd>, <Wn>, <Wm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011101xxxxx111111xxxxxxxxxx", 
                "title": "UMNEGL"
            }
        ], 
        "file": "umnegl_umsubl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic signed maximum on halfword in memory, without return, atomically loads \na 16-bit halfword from memory, compares it against the value held in a \nregister, and stores the larger value back to memory, treating the values as \nsigned numbers. \n\n* STSMAXH has no memory ordering semantics. \n* STSMAXLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH. \n* The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the \n  operational pseudocode for this instruction.", 
        "title": "STSMAXH, STSMAXLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "011110000x1xxxxx010000xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STSMAXH  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STSMAXLH  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stsmaxh_ldsmaxh.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store a single-element structure from one lane of one register. This \ninstruction stores the specified element of a SIMD&FP register to memory. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST1 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110100000000xx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 000)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101100xxxxxxx0xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 000)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.H }[<index>], [<Xn|SP>], #2", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 010 && size == x0)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.S }[<index>], [<Xn|SP>], #4", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && size == 00)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.D }[<index>], [<Xn|SP>], #8", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 100 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST1  { <Vt>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st1_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point fused Multiply-Subtract Long from accumulator (vector). This \ninstruction negates the values in the vector of one SIMD&FP register, \nmultiplies these with the corresponding values in another vector, and \naccumulates the product to the corresponding vector element of the destination \nSIMD&FP register. The instruction does not round the result of the multiply \nbefore the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nFrom ARMv8.2, this is an optional instruction. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLSL and FMLSL2", 
        "title": "FMLSL, FMLSL2 (vector)", 
        "classes": [
            {
                "title": "FMLSL", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x1xxxxx111011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "FMLSL"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "FMLSL2", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x1xxxxx110011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "FMLSL2"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "fmlsl_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move immediate value to Special Register moves an immediate value to selected \nbits of the PSTATE. For more information, see Process state, PSTATE. \n\nThe bits that can be written are D, A, I, F, and SP. This set of bits is \nexpanded in extensions to the architecture as follows: \n\n* ARMv8.1-PAN adds the PAN bit. \n* ARMv8.2-UAO adds the UAO bit.", 
        "title": "MSR (immediate)", 
        "classes": [
            {
                "fields": {
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MSR  <pstatefield>, #<imm>", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101010100000xxx0100xxxxxxx11111", 
                "title": "MSR (immediate)"
            }
        ], 
        "file": "msr_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Branch to Register, with pointer authentication. This instruction \nauthenticates the address in the general-purpose register that is specified by \n<Xn>, using a modifier and the specified key, and branches to the \nauthenticated address. \n\nThe modifier is: \n\n* In the general-purpose register or stack pointer that is specified by \n  <Xm|SP> for BRAA and BRAB. \n* The value zero, for BRAAZ and BRABZ. \nKey A is used for BRAA and BRAAZ, and key B is used for BRAB and BRABZ. \n\nIf the authentication passes, the PE continues execution at the target of the \nbranch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to the general-purpose register.", 
        "title": "BRAA, BRAAZ, BRAB, BRABZ", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "M": {
                        "lo": 10, 
                        "hi": 10, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Z": {
                        "lo": 24, 
                        "hi": 24, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 21, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "1101011x0001111100001xxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Z == 0 && M == 0 && Rm == 11111)", 
                        "arch": null, 
                        "asm": "BRAAZ  <Xn>", 
                        "title": "Key A, zero modifier"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && M == 0)", 
                        "arch": null, 
                        "asm": "BRAA  <Xn>, <Xm|SP>", 
                        "title": "Key A, register modifier"
                    }, 
                    {
                        "bitdiff": "(Z == 0 && M == 1 && Rm == 11111)", 
                        "arch": null, 
                        "asm": "BRABZ  <Xn>", 
                        "title": "Key B, zero modifier"
                    }, 
                    {
                        "bitdiff": "(Z == 1 && M == 1)", 
                        "arch": null, 
                        "asm": "BRAB  <Xn>, <Xm|SP>", 
                        "title": "Key B, register modifier"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "bra.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Branch conditionally to a label at a PC-relative offset, with a hint that this \nis not a subroutine call or return.", 
        "title": "B.cond", 
        "classes": [
            {
                "fields": {
                    "imm19": {
                        "lo": 5, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxxxxxxxxx"
                    }, 
                    "cond": {
                        "lo": 0, 
                        "hi": 3, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "B.<cond>  <label>", 
                        "title": "19-bit signed PC-relative branch offset"
                    }
                ], 
                "unallocated": null, 
                "mask": "01010100xxxxxxxxxxxxxxxxxxx0xxxx", 
                "title": "B.cond"
            }
        ], 
        "file": "b_cond.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Round to Integral exact, using current rounding mode (vector). \nThis instruction rounds a vector of floating-point values in the SIMD&FP \nsource register to integral floating-point values of the same size using the \nrounding mode that is determined by the FPCR, and writes the result to the \nSIMD&FP destination register. \n\nAn Inexact exception is raised when the result value is not numerically equal \nto the input value. A zero input gives a zero result with the same sign, an \ninfinite input gives an infinite result with the same sign, and a NaN is \npropagated as for normal arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FRINTX (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x10111001111001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTX  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x100001100110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FRINTX  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "frintx_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and \nstores the value held in a register back to the same memory location. The \nvalue initially loaded from memory is returned in the destination register. \n\n* If the destination register is not WZR, SWPAB and SWPALB load from memory \n  with acquire semantics. \n* SWPLB and SWPALB store to memory with release semantics. \n* SWPB has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes.", 
        "title": "SWPB, SWPAB, SWPALB, SWPLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000xx1xxxxx100000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "SWPAB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPAB"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPALB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPALB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "SWPB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPB"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "SWPLB  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "SWPLB"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "swpb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Multiply Long (vector, by element). This instruction multiplies each \nvector element in the lower or upper half of the first source SIMD&FP register \nby the specified vector element of the second source SIMD&FP register, places \nthe results in a vector, and writes the vector to the destination SIMD&FP \nregister. The destination vector elements are twice as long as the elements \nthat are multiplied. \n\nThe UMULL instruction extracts vector elements from the lower half of the \nfirst source register, while the UMULL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMULL, UMULL2 (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx1010x0xxxxxxxxxx", 
                "title": "UMULL, UMULL2 (by element)"
            }
        ], 
        "file": "umull_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Add Pairwise (vector). This instruction creates a vector by \nconcatenating the vector elements of the first source SIMD&FP register after \nthe vector elements of the second source SIMD&FP register, reads each pair of \nadjacent vector elements from the concatenated vector, adds each pair of \nvalues together, places the result into a vector, and writes the vector to the \ndestination SIMD&FP register. All the values in this instruction are \nfloating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and \ndouble-precision", 
        "title": "FADDP (vector)", 
        "classes": [
            {
                "title": "Half-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110010xxxxx000101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Half-precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011100x1xxxxx110101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "faddp_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store Register Byte (immediate) stores the least significant byte of a 32-bit \nregister to memory. The address that is used for the store is calculated from \na base register and an immediate offset. For information about memory \naccesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", 
        "title": "STRB (immediate)", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000000xxxxxxxxx01xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STRB  <Wt>, [<Xn|SP>], #<simm>", 
                        "title": "Post-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "00111000000xxxxxxxxx11xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STRB  <Wt>, [<Xn|SP>, #<simm>]!", 
                        "title": "Pre-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Unsigned offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "0011100100xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]", 
                        "title": "Unsigned offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "strb_imm.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Conditional quiet Compare (scalar). This instruction compares \nthe two SIMD&FP source register values and writes the result to the PSTATE.{N, \nZ, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V} \nflags are set to the flag bit specifier. \n\nIt raises an Invalid Operation exception only if either operand is a signaling \nNaN. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCCMP", 
        "classes": [
            {
                "fields": {
                    "nzcv": {
                        "lo": 0, 
                        "hi": 3, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "cond": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 4, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FCCMP  <Sn>, <Sm>, #<nzcv>, <cond>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxxxxxx01xxxxx0xxxx", 
                "title": "FCCMP"
            }
        ], 
        "file": "fccmp_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding toward Plus infinity \n(vector). This instruction converts a scalar or each element in a vector from \na floating-point value to a signed integer value using the Round towards Plus \nInfinity rounding mode, and writes the result to the SIMD&FP destination \nregister. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCVTPS (vector)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111011111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPS  <Hd>, <Hn>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPS  <V><d>, <V><n>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "o1": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100001101010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTPS  <Vd>.<T>, <Vn>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtps_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to \nAway (scalar). This instruction converts the floating-point value in the \nSIMD&FP source register to a 32-bit or 64-bit signed integer using the Round \nto Nearest with Ties to Away rounding mode, and writes the result to the \ngeneral-purpose destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCVTAS (scalar)", 
        "classes": [
            {
                "fields": {
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "100"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTAS  <Wd>, <Hn>", 
                        "title": "Half-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FCVTAS  <Xd>, <Hn>", 
                        "title": "Half-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTAS  <Wd>, <Sn>", 
                        "title": "Single-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "FCVTAS  <Xd>, <Sn>", 
                        "title": "Single-precision to 64-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTAS  <Wd>, <Dn>", 
                        "title": "Double-precision to 32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "FCVTAS  <Xd>, <Dn>", 
                        "title": "Double-precision to 64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx100100000000xxxxxxxxxx", 
                "title": "FCVTAS (scalar)"
            }
        ], 
        "file": "fcvtas_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Rounding Doubling Multiply returning High half. This \ninstruction multiplies the values of corresponding elements of the two source \nSIMD&FP registers, doubles the results, places the most significant half of \nthe final results into a vector, and writes the vector to the destination \nSIMD&FP register. \n\nThe results are rounded. For truncated results, see SQDMULH. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRDMULH (vector)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110xx1xxxxx101101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMULH  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx101101xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqrdmulh_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned Subtract Wide. This instruction subtracts each vector element of the \nsecond source SIMD&FP register from the corresponding vector element in the \nlower or upper half of the first source SIMD&FP register, places the result in \na vector, and writes the vector to the SIMD&FP destination register. All the \nvalues in this instruction are signed integer values. \n\nThe vector elements of the destination register and the first source register \nare twice as long as the vector elements of the second source register. \n\nThe USUBW instruction extracts vector elements from the lower half of the \nfirst source register, while the USUBW2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "USUBW, USUBW2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101110xx1xxxxx001100xxxxxxxxxx", 
                "title": "USUBW, USUBW2"
            }
        ], 
        "file": "usubw_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "YIELD is a hint instruction. Software with a multithreading capability can use \na YIELD instruction to indicate to the PE that it is performing a task, for \nexample a spin-lock, that could be swapped out to improve overall system \nperformance. The PE can use this hint to suspend and resume multiple software \nthreads if it supports the capability. \n\nFor more information about the recommended use of this instruction, see The \nYIELD instruction.", 
        "title": "YIELD", 
        "classes": [
            {
                "fields": {
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "001"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0000"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "YIELD", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "11010101000000110010000000111111", 
                "title": "YIELD"
            }
        ], 
        "file": "yield.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Register (unprivileged) loads a word or doubleword from memory, and \nwrites it to a register. The address that is used for the load is calculated \nfrom a base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was \nexecuted at EL0 if the Effective value of PSTATE.UAO is 0 and either: \n\n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}. \nOtherwise, the memory access operates with the restrictions determined by the \nException level at which the instruction is executed. For information about \nmemory accesses, see Load/Store addressing modes.", 
        "title": "LDTR", 
        "classes": [
            {
                "fields": {
                    "imm9": {
                        "lo": 12, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxxxxxx"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(size == 10)", 
                        "arch": null, 
                        "asm": "LDTR  <Wt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(size == 11)", 
                        "arch": null, 
                        "asm": "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "1x111000010xxxxxxxxx10xxxxxxxxxx", 
                "title": "LDTR"
            }
        ], 
        "file": "ldtr.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP \nregister, and four iterations of the round key held as the elements of the \n128-bit vector in the second source SIMD&FP register. It encrypts the data by \nfour rounds, in accordance with the SM4 standard, returning the 128-bit result \nto the destination SIMD&FP register. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM4E", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "1100111011000000100001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM4E  <Vd>.4S, <Vn>.4S", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm4e_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Greater than (vector). This instruction reads each \nfloating-point value in the first source SIMD&FP register and if the value is \ngreater than the corresponding floating-point value in the second source \nSIMD&FP register sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to one, otherwise sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMGT (register)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111110110xxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "011111101x1xxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110110xxxxx001001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "ac": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "E": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x1011101x1xxxxx111001xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmgt_advsimd_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts \nthe product from a 64-bit register value, and writes the result to the 64-bit \ndestination register. \n\nThis instruction is used by the alias SMNEGL.", 
        "title": "SMSUBL", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "10011011001xxxxx1xxxxxxxxxxxxxxx", 
                "title": "SMSUBL"
            }
        ], 
        "file": "smsubl.html", 
        "type": "instruction", 
        "aliases": [
            "smnegl_smsubl.html"
        ]
    }, 
    {
        "description": "Store multiple 2-element structures from two registers. This instruction \nstores multiple 2-element structures from two SIMD&FP registers to memory, \nwith interleaving. Every element of each register is stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST2 (multiple structures)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100000000001000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", 
                        "title": "No offset"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opcode": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1000"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001100100xxxxx1000xxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>", 
                        "title": "Immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111)", 
                        "arch": null, 
                        "asm": "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>", 
                        "title": "Register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st2_advsimd_mult.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Pair of Registers Signed Word calculates an address from a base register \nvalue and an immediate offset, loads two 32-bit words from memory, \nsign-extends them, and writes them to two registers. For information about \nmemory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", 
        "title": "LDPSW", 
        "classes": [
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0110100011xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>", 
                        "title": "Post-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Pre-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0110100111xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!", 
                        "title": "Pre-index"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Signed offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0110100101xxxxxxxxxxxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "Signed offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "ldpsw.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Add (scalar). This instruction adds the floating-point values \nof the two source SIMD&FP registers, and writes the result to the destination \nSIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FADD (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FADD  <Hd>, <Hn>, <Hm>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FADD  <Sd>, <Sn>, <Sm>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FADD  <Dd>, <Dn>, <Dm>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx1xxxxx001010xxxxxxxxxx", 
                "title": "FADD (scalar)"
            }
        ], 
        "file": "fadd_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned minimum on byte in memory, without return, atomically loads an \n8-bit byte from memory, compares it against the value held in a register, and \nstores the smaller value back to memory, treating the values as unsigned \nnumbers. \n\n* STUMINB has no memory ordering semantics. \n* STUMINLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release. \nFor information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB. This means: \n\n* The encodings in this description are named to match the encodings of \n  LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB. \n* The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the \n  operational pseudocode for this instruction.", 
        "title": "STUMINB, STUMINLB", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "111"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "00"
                    }
                }, 
                "unallocated": null, 
                "mask": "001110000x1xxxxx011100xxxxx11111", 
                "encodings": [
                    {
                        "bitdiff": "(R == 0)", 
                        "arch": null, 
                        "asm": "STUMINB  <Ws>, [<Xn|SP>]", 
                        "title": "No memory ordering"
                    }, 
                    {
                        "bitdiff": "(R == 1)", 
                        "arch": null, 
                        "asm": "STUMINLB  <Ws>, [<Xn|SP>]", 
                        "title": "Release"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "stuminb_lduminb.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Subtract returning High Narrow. This instruction subtracts each vector element \nin the second source SIMD&FP register from the corresponding vector element in \nthe first source SIMD&FP register, places the most significant half of the \nresult into a vector, and writes the vector to the lower or upper half of the \ndestination SIMD&FP register. All the values in this instruction are signed \ninteger values. \n\nThe results are truncated. For rounded results, see RSUBHN. \n\nThe SUBHN instruction writes the vector to the lower half of the destination \nregister and clears the upper half, while the SUBHN2 instruction writes the \nvector to the upper half of the destination register without affecting the \nother bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SUBHN, SUBHN2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx011000xxxxxxxxxx", 
                "title": "SUBHN, SUBHN2"
            }
        ], 
        "file": "subhn_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Complex Multiply Accumulate. \n\nThis instruction operates on complex numbers that are represented in SIMD&FP \nregisters as pairs of elements, with the more significant element holding the \nimaginary part of the number and the less significant element holding the real \npart of the number. Each element holds a floating-point value. It performs the \nfollowing computation on the corresponding complex number element pairs from \nthe two source registers and the destination register: \n\n* Considering the complex number from the second source register on an Argand \n  diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 \n  degrees. \n* The two elements of the transformed complex number are multiplied by:The \n  real element of the complex number from the first source register, if the \n  transformation was a rotation by 0 or 180 degrees.The imaginary element of \n  the complex number from the first source register, if the transformation was \n  a rotation by 90 or 270 degrees. \n* The complex number resulting from that multiplication is added to the \n  complex number from the destination register. \nThe multiplication and addition operations are performed as a fused \nmultiply-add, without any intermediate rounding. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FCMLA", 
        "classes": [
            {
                "title": "Three registers of the same type", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "rot": {
                        "lo": 11, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x101110xx0xxxxx110xx1xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>", 
                        "title": "Three registers of the same type"
                    }
                ], 
                "arch": "ARMv8.3"
            }
        ], 
        "file": "fcmla_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Prefetch Memory (register) signals the memory system that data memory accesses \nfrom a specified address are likely to occur in the near future. The memory \nsystem can respond by taking actions that are expected to speed up the memory \naccesses when they do occur, such as preloading the cache line containing the \nspecified address into one or more caches. \n\nThe effect of an PRFM instruction is implementation defined. For more \ninformation, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", 
        "title": "PRFM (register)", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "option": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "10"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]", 
                        "title": "Integer"
                    }
                ], 
                "unallocated": null, 
                "mask": "11111000101xxxxxxxxx10xxxxxxxxxx", 
                "title": "PRFM (register)"
            }
        ], 
        "file": "prfm_reg.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Unsigned fixed-point Convert to Floating-point (scalar). This instruction \nconverts the unsigned value in the 32-bit or 64-bit general-purpose source \nregister to a floating-point value using the rounding mode that is specified \nby the FPCR, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped.", 
        "title": "UCVTF (scalar, fixed-point)", 
        "classes": [
            {
                "fields": {
                    "scale": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }, 
                    "rmode": {
                        "lo": 19, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "00"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "opcode": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "011"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "UCVTF  <Hd>, <Wn>, #<fbits>", 
                        "title": "32-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 00)", 
                        "arch": null, 
                        "asm": "UCVTF  <Sd>, <Wn>, #<fbits>", 
                        "title": "32-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 0 && type == 01)", 
                        "arch": null, 
                        "asm": "UCVTF  <Dd>, <Wn>, #<fbits>", 
                        "title": "32-bit to double-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "UCVTF  <Hd>, <Xn>, #<fbits>", 
                        "title": "64-bit to half-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 00)", 
                        "arch": null, 
                        "asm": "UCVTF  <Sd>, <Xn>, #<fbits>", 
                        "title": "64-bit to single-precision"
                    }, 
                    {
                        "bitdiff": "(sf == 1 && type == 01)", 
                        "arch": null, 
                        "asm": "UCVTF  <Dd>, <Xn>, #<fbits>", 
                        "title": "64-bit to double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011110xx000011xxxxxxxxxxxxxxxx", 
                "title": "UCVTF (scalar, fixed-point)"
            }
        ], 
        "file": "ucvtf_float_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply-Negate multiplies two register values, negates the product, and \nwrites the result to the destination register. \n\nThis is an alias of MSUB. This means: \n\n* The encodings in this description are named to match the encodings of MSUB. \n* The description of MSUB gives the operational pseudocode for this \n  instruction.", 
        "title": "MNEG", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Ra": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "o0": {
                        "lo": 15, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "MNEG  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "MNEG  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011011000xxxxx111111xxxxxxxxxx", 
                "title": "MNEG"
            }
        ], 
        "file": "mneg_msub.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Multiply (vector, by element). This instruction multiplies the vector elements \nin the first source SIMD&FP register by the specified value in the second \nsource SIMD&FP register, places the results in a vector, and writes the vector \nto the destination SIMD&FP register. All the values in this instruction are \nunsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "MUL (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001111xxxxxxxx1000x0xxxxxxxxxx", 
                "title": "MUL (by element)"
            }
        ], 
        "file": "mul_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Multiply extended. This instruction multiplies corresponding \nfloating-point values in the vectors of the two source SIMD&FP registers, \nplaces the resulting floating-point values in a vector, and writes the vector \nto the destination SIMD&FP register. \n\nIf one value is zero and the other value is infinite, the result is 2.0. In \nthis case, the result is negative if only one of the values is negative, \notherwise the result is positive. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FMULX", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110010xxxxx000111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <Hd>, <Hn>, <Hm>", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111100x1xxxxx110111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110010xxxxx000111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011100x1xxxxx110111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fmulx_advsimd_vec.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This \ninstruction reads each signed integer value in the vector of the source \nSIMD&FP register, right shifts each value by an immediate value, saturates the \nresult to an unsigned integer value that is half the original width, places \nthe final result into a vector, and writes the vector to the destination \nSIMD&FP register. The results are rounded. For truncated results, see SQSHRUN. \n\nThe SQRSHRUN instruction writes the vector to the lower half of the \ndestination register and clears the upper half, while the SQRSHRUN2 \ninstruction writes the vector to the upper half of the destination register \nwithout affecting the other bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQRSHRUN, SQRSHRUN2", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "011111110xxxxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRSHRUN  <Vb><d>, <Va><n>, #<shift>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x1011110xxxxxxx100011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqrshrun_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Square Root (scalar). This instruction calculates the square \nroot of the value in the SIMD&FP source register and writes the result to the \nSIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "FSQRT (scalar)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "type": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "opc": {
                        "lo": 15, 
                        "hi": 16, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(type == 11)", 
                        "arch": "ARMv8.2", 
                        "asm": "FSQRT  <Hd>, <Hn>", 
                        "title": "Half-precision"
                    }, 
                    {
                        "bitdiff": "(type == 00)", 
                        "arch": null, 
                        "asm": "FSQRT  <Sd>, <Sn>", 
                        "title": "Single-precision"
                    }, 
                    {
                        "bitdiff": "(type == 01)", 
                        "arch": null, 
                        "asm": "FSQRT  <Dd>, <Dn>", 
                        "title": "Double-precision"
                    }
                ], 
                "unallocated": null, 
                "mask": "00011110xx100001110000xxxxxxxxxx", 
                "title": "FSQRT (scalar)"
            }
        ], 
        "file": "fsqrt_float.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Less than zero (vector). This instruction reads each \nfloating-point value in the source SIMD&FP register and if the value is less \nthan zero sets every bit of the corresponding vector element in the \ndestination SIMD&FP register to one, otherwise sets every bit of the \ncorresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMLT (zero)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111011111000111010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLT  <Hd>, <Hn>, #0.0", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x100000111010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLT  <V><d>, <V><n>, #0.0", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111000111010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100000111010xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmlt_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic add on halfword in memory atomically loads a 16-bit halfword from \nmemory, adds the value held in a register to it, and stores the result back to \nmemory. The value initially loaded from memory is returned in the destination \nregister. \n\n* If the destination register is not WZR, LDADDAH and LDADDALH load from \n  memory with acquire semantics. \n* LDADDLH and LDADDALH store to memory with release semantics. \n* LDADDH has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STADDH, STADDLH.", 
        "title": "LDADDH, LDADDAH, LDADDALH, LDADDLH", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "01"
                    }
                }, 
                "unallocated": null, 
                "mask": "01111000xx1xxxxx000000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADDAH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDAH"
                    }, 
                    {
                        "bitdiff": "(A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDALH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDALH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDADDH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDH"
                    }, 
                    {
                        "bitdiff": "(A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "LDADDLH"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldaddh.html", 
        "type": "instruction", 
        "aliases": [
            "staddh_ldaddh.html"
        ]
    }, 
    {
        "description": "System instruction. For more information, see Op0 equals 0b01, cache \nmaintenance, TLB maintenance, and address translation instructions for the \nencodings of System instructions. \n\nThis instruction is used by the aliases AT, DC, IC, and TLBI.", 
        "title": "SYS", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op1": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "op2": {
                        "lo": 5, 
                        "hi": 7, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "CRn": {
                        "lo": 12, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "CRm": {
                        "lo": 8, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}", 
                        "title": "System"
                    }
                ], 
                "unallocated": null, 
                "mask": "1101010100001xxxxxxxxxxxxxxxxxxx", 
                "title": "SYS"
            }
        ], 
        "file": "sys.html", 
        "type": "instruction", 
        "aliases": [
            "at_sys.html", 
            "dc_sys.html", 
            "ic_sys.html", 
            "tlbi_sys.html"
        ]
    }, 
    {
        "description": "Test (shifted register) performs a bitwise AND operation on a register value \nand an optionally-shifted register value. It updates the condition flags based \non the result, and discards the result. \n\nThis is an alias of ANDS (shifted register). This means: \n\n* The encodings in this description are named to match the encodings of ANDS \n  (shifted register). \n* The description of ANDS (shifted register) gives the operational pseudocode \n  for this instruction.", 
        "title": "TST (shifted register)", 
        "classes": [
            {
                "fields": {
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "N": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "11111"
                    }, 
                    "opc": {
                        "lo": 29, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "11"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "imm6": {
                        "lo": 10, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "TST  <Wn>, <Wm>{, <shift> #<amount>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "TST  <Xn>, <Xm>{, <shift> #<amount>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x1101010xx0xxxxxxxxxxxxxxxx11111", 
                "title": "TST (shifted register)"
            }
        ], 
        "file": "tst_ands_log_shift.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Store single 4-element structure from one lane of four registers. This \ninstruction stores a 4-element structure to memory from corresponding elements \nof four SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", 
        "title": "ST4 (single structure)", 
        "classes": [
            {
                "title": "No offset", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00110100100000xx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(opcode == 001)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]", 
                        "title": "8-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]", 
                        "title": "16-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]", 
                        "title": "64-bit"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Post-index", 
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "S": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "R": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opcode": {
                        "lo": 13, 
                        "hi": 15, 
                        "equal": "==", 
                        "value": "xx1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001101101xxxxxxx1xxxxxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4", 
                        "title": "8-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 001)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "8-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8", 
                        "title": "16-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 011 && size == x0)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "16-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16", 
                        "title": "32-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && size == 00)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "32-bit, register offset"
                    }, 
                    {
                        "bitdiff": "(Rm == 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32", 
                        "title": "64-bit, immediate offset"
                    }, 
                    {
                        "bitdiff": "(Rm != 11111 && opcode == 101 && S == 0 && size == 01)", 
                        "arch": null, 
                        "asm": "ST4  { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>", 
                        "title": "64-bit, register offset"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "st4_advsimd_sngl.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Compare Equal to zero (vector). This instruction reads each \nfloating-point value in the source SIMD&FP register and if the value is equal \nto zero sets every bit of the corresponding vector element in the destination \nSIMD&FP register to one, otherwise sets every bit of the corresponding vector \nelement in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the \nsettings in FPCR, the exception results in either a flag being set in FPSR, or \na synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar \nsingle-precision and double-precision , Vector half precision and Vector \nsingle-precision and double-precision", 
        "title": "FCMEQ (zero)", 
        "classes": [
            {
                "title": "Scalar half precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0101111011111000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <Hd>, <Hn>, #0.0", 
                        "title": "Scalar half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Scalar single-precision and double-precision", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "010111101x100000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <V><d>, <V><n>, #0.0", 
                        "title": "Scalar single-precision and double-precision"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector half precision", 
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x00111011111000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector half precision"
                    }
                ], 
                "arch": "ARMv8.2"
            }, 
            {
                "title": "Vector single-precision and double-precision", 
                "fields": {
                    "sz": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "op": {
                        "lo": 12, 
                        "hi": 12, 
                        "equal": "==", 
                        "value": "1"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x0011101x100000110110xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0", 
                        "title": "Vector single-precision and double-precision"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcmeq_advsimd_zero.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Load Pair of Registers, with non-temporal hint, calculates an address from a \nbase register value and an immediate offset, loads two 32-bit words or two \n64-bit doublewords from memory, and writes them to two registers. \n\nFor information about memory accesses, see Load/Store addressing modes. For \ninformation about Non-temporal pair instructions, see Load/Store Non-temporal \npair.", 
        "title": "LDNP", 
        "classes": [
            {
                "fields": {
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rt2": {
                        "lo": 10, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "L": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "opc": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm7": {
                        "lo": 15, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(opc == 00)", 
                        "arch": null, 
                        "asm": "LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(opc == 10)", 
                        "arch": null, 
                        "asm": "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x010100001xxxxxxxxxxxxxxxxxxxxxx", 
                "title": "LDNP"
            }
        ], 
        "file": "ldnp_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Atomic unsigned maximum on word or doubleword in memory atomically loads a \n32-bit word or 64-bit doubleword from memory, compares it against the value \nheld in a register, and stores the larger value back to memory, treating the \nvalues as unsigned numbers. The value initially loaded from memory is returned \nin the destination register. \n\n* If the destination register is not one of WZR or XZR, LDUMAXA and LDUMAXAL \n  load from memory with acquire semantics. \n* LDUMAXL and LDUMAXAL store to memory with release semantics. \n* LDUMAX has no memory ordering requirements. \nFor more information about memory ordering semantics see Load-Acquire, \nStore-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMAX, STUMAXL.", 
        "title": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL", 
        "classes": [
            {
                "title": "Integer", 
                "fields": {
                    "A": {
                        "lo": 23, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rt": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rs": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "R": {
                        "lo": 22, 
                        "hi": 22, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "opc": {
                        "lo": 12, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "110"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 30, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "1x"
                    }
                }, 
                "unallocated": null, 
                "mask": "1x111000xx1xxxxx011000xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAX  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMAX"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAXA  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMAXA"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXAL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMAXAL"
                    }, 
                    {
                        "bitdiff": "(size == 10 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXL  <Ws>, <Wt>, [<Xn|SP>]", 
                        "title": "32-bit LDUMAXL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAX  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMAX"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 0)", 
                        "arch": null, 
                        "asm": "LDUMAXA  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMAXA"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 1 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXAL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMAXAL"
                    }, 
                    {
                        "bitdiff": "(size == 11 && A == 0 && R == 1)", 
                        "arch": null, 
                        "asm": "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]", 
                        "title": "64-bit LDUMAXL"
                    }
                ], 
                "arch": "ARMv8.1"
            }
        ], 
        "file": "ldumax.html", 
        "type": "instruction", 
        "aliases": [
            "stumax_ldumax.html"
        ]
    }, 
    {
        "description": "Unsigned Multiply-Subtract Long (vector, by element). This instruction \nmultiplies each vector element in the lower or upper half of the first source \nSIMD&FP register by the specified vector element of the second source SIMD&FP \nregister and subtracts the results from the vector elements of the destination \nSIMD&FP register. The destination vector elements are twice as long as the \nelements that are multiplied. \n\nThe UMLSL instruction extracts vector elements from the lower half of the \nfirst source register, while the UMLSL2 instruction extracts vector elements \nfrom the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "UMLSL, UMLSL2 (by element)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "H": {
                        "lo": 11, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "M": {
                        "lo": 20, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "L": {
                        "lo": 21, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 19, 
                        "equal": "==", 
                        "value": "xxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o2": {
                        "lo": 14, 
                        "hi": 14, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", 
                        "title": "Vector"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x101111xxxxxxxx0110x0xxxxxxxxxx", 
                "title": "UMLSL, UMLSL2 (by element)"
            }
        ], 
        "file": "umlsl_advsimd_elt.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector). \nThis instruction converts a scalar or each element in a vector from \nfloating-point to fixed-point signed integer using the Round towards Zero \nrounding mode, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on \nthe settings in FPCR, the exception results in either a flag being set in \nFPSR, or a synchronous exception being generated. For more information, see \nFloating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the Security state and Exception level in which the instruction is \nexecuted, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "FCVTZS (vector, fixed-point)", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "010111110xxxxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZS  <V><d>, <V><n>, #<fbits>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "immh": {
                        "lo": 19, 
                        "hi": 22, 
                        "equal": "!=", 
                        "value": "0000"
                    }, 
                    "immb": {
                        "lo": 16, 
                        "hi": 18, 
                        "equal": "==", 
                        "value": "xxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "unallocated": [
                    "xxxxxxxxx0000xxxxxxxxxxxxxxxxxxx"
                ], 
                "mask": "0x0011110xxxxxxx111111xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "fcvtzs_advsimd_fix.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Move general-purpose register to a vector element. This instruction copies the \ncontents of the source general-purpose register to the specified vector \nelement in the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP \nregister without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nThis is an alias of INS (general). This means: \n\n* The encodings in this description are named to match the encodings of INS \n  (general). \n* The description of INS (general) gives the operational pseudocode for this \n  instruction.", 
        "title": "MOV (from general)", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm5": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "MOV  <Vd>.<Ts>[<index>], <R><n>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "01001110000xxxxx000111xxxxxxxxxx", 
                "title": "MOV (from general)"
            }
        ], 
        "file": "mov_ins_advsimd_gen.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Rotate Right Variable provides the value of the contents of a register rotated \nby a variable number of bits. The bits that are rotated off the right end are \ninserted into the vacated bit positions on the left. The remainder obtained by \ndividing the second source register by the data size defines the number of \nbits by which the first source register is right-shifted. \n\nThis instruction is used by the alias ROR (register).", 
        "title": "RORV", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op2": {
                        "lo": 10, 
                        "hi": 11, 
                        "equal": "==", 
                        "value": "11"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "RORV  <Wd>, <Wn>, <Wm>", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "RORV  <Xd>, <Xn>, <Xm>", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0011010110xxxxx001011xxxxxxxxxx", 
                "title": "RORV"
            }
        ], 
        "file": "rorv.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a \n2-bit immediate index value, and returns a 128-bit result in the destination \nSIMD&FP register. It performs a three-way exclusive OR of the three 32-bit \nfields held in the upper three elements of the first source vector, and adds \nthe resulting 32-bit value and the following three other 32-bit values: \n\n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the three-way exclusive OR. \n* The 32-bit element held in the top 32 bits of the second source vector, Vn. \n* A 32-bit element indexed out of the third source vector, Vm. \nA three-way exclusive OR is performed of the result of this addition, the \nresult of the addition rotated left by 9, and the result of the addition \nrotated left by 17. The result of this exclusive OR is returned as the top \nelement of the returned result. The other elements of this result are taken \nfrom elements of the first source vector, with the element returned in \nbits<63:32> being rotated left by 19. \n\nThis instruction is implemented only when ARMv8.2-SM is implemented.", 
        "title": "SM3TT2A", 
        "classes": [
            {
                "title": "Advanced SIMD", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "imm2": {
                        "lo": 12, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "11001110010xxxxx10xx10xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "arch": "ARMv8.2"
            }
        ], 
        "file": "sm3tt2a_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Add (immediate), setting flags, adds a register value and an \noptionally-shifted immediate value, and writes the result to the destination \nregister. It updates the condition flags based on the result. \n\nThis instruction is used by the alias CMN (immediate).", 
        "title": "ADDS (immediate)", 
        "classes": [
            {
                "fields": {
                    "imm12": {
                        "lo": 10, 
                        "hi": 21, 
                        "equal": "==", 
                        "value": "xxxxxxxxxxxx"
                    }, 
                    "shift": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "S": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "1"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "sf": {
                        "lo": 31, 
                        "hi": 31, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "op": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "0"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": "(sf == 0)", 
                        "arch": null, 
                        "asm": "ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}", 
                        "title": "32-bit"
                    }, 
                    {
                        "bitdiff": "(sf == 1)", 
                        "arch": null, 
                        "asm": "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}", 
                        "title": "64-bit"
                    }
                ], 
                "unallocated": null, 
                "mask": "x0110001xxxxxxxxxxxxxxxxxxxxxxxx", 
                "title": "ADDS (immediate)"
            }
        ], 
        "file": "adds_addsub_imm.html", 
        "type": "instruction", 
        "aliases": [
            "cmn_adds_addsub_imm.html"
        ]
    }, 
    {
        "description": "Signed Add Long across Vector. This instruction adds every vector element in \nthe source SIMD&FP register together, and writes the scalar result to the \ndestination SIMD&FP register. The destination scalar is twice as long as the \nsource vector elements. All the values in this instruction are signed integer \nvalues. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SADDLV", 
        "classes": [
            {
                "fields": {
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SADDLV  <V><d>, <Vn>.<T>", 
                        "title": "Advanced SIMD"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx110000001110xxxxxxxxxx", 
                "title": "SADDLV"
            }
        ], 
        "file": "saddlv_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed Add Long (vector). This instruction adds each vector element in the \nlower or upper half of the first source SIMD&FP register to the corresponding \nvector element of the second source SIMD&FP register, places the results into \na vector, and writes the vector to the destination SIMD&FP register. The \ndestination vector elements are twice as long as the source vector elements. \nAll the values in this instruction are signed integer values. \n\nThe SADDL instruction extracts each source vector from the lower half of each \nsource register, while the SADDL2 instruction extracts each source vector from \nthe upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped.", 
        "title": "SADDL, SADDL2", 
        "classes": [
            {
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "o1": {
                        "lo": 13, 
                        "hi": 13, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", 
                        "title": "Three registers, not all the same type"
                    }
                ], 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx000000xxxxxxxxxx", 
                "title": "SADDL, SADDL2"
            }
        ], 
        "file": "saddl_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }, 
    {
        "description": "Signed saturating Add. This instruction adds the values of corresponding \nelements of the two source SIMD&FP registers, places the results into a \nvector, and writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If \nsaturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers, \nand the current Security state and Exception level, an attempt to execute the \ninstruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", 
        "title": "SQADD", 
        "classes": [
            {
                "title": "Scalar", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "01011110xx1xxxxx000011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQADD  <V><d>, <V><n>, <V><m>", 
                        "title": "Scalar"
                    }
                ], 
                "arch": null
            }, 
            {
                "title": "Vector", 
                "fields": {
                    "Rd": {
                        "lo": 0, 
                        "hi": 4, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Q": {
                        "lo": 30, 
                        "hi": 30, 
                        "equal": "==", 
                        "value": "x"
                    }, 
                    "U": {
                        "lo": 29, 
                        "hi": 29, 
                        "equal": "==", 
                        "value": "0"
                    }, 
                    "Rm": {
                        "lo": 16, 
                        "hi": 20, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "Rn": {
                        "lo": 5, 
                        "hi": 9, 
                        "equal": "==", 
                        "value": "xxxxx"
                    }, 
                    "size": {
                        "lo": 22, 
                        "hi": 23, 
                        "equal": "==", 
                        "value": "xx"
                    }
                }, 
                "unallocated": null, 
                "mask": "0x001110xx1xxxxx000011xxxxxxxxxx", 
                "encodings": [
                    {
                        "bitdiff": null, 
                        "arch": null, 
                        "asm": "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", 
                        "title": "Vector"
                    }
                ], 
                "arch": null
            }
        ], 
        "file": "sqadd_advsimd.html", 
        "type": "instruction", 
        "aliases": null
    }
]